<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>人的精力</title>
    <url>/life/human_energy/</url>
    <content><![CDATA[<h1 id="人的精力"><a href="#人的精力" class="headerlink" title="人的精力"></a>人的精力</h1><blockquote>
<p>摘自：<a href="https://zhuanlan.zhihu.com/p/266759994">https://zhuanlan.zhihu.com/p/266759994</a></p>
</blockquote>
<h2 id="一、人的精力是有限的"><a href="#一、人的精力是有限的" class="headerlink" title="一、人的精力是有限的"></a>一、人的精力是有限的</h2><p>人的精力是有限的，做任何有益于自身成长的事情，都需要耗费大量的精力，这也就要求人要有节制地使用这一无形资本。</p>
<blockquote>
<p>曾经有很长的一段时间我不明白为什么每当我参加一些人数众多，气氛热闹，互动频繁的活动时就会情绪低落，即使是参加大型同学聚会，面对大家欢快的讨论，我也多少有些拘谨。直到很久以后，我才明白这种性格特质叫：内向。而内向意味着个体在独处或面对有限的对象时精力充沛，而却对超出自我界限的对象则感到茫然无助，乃至疲惫不堪。</p>
</blockquote>
<h2 id="二、精力的损失"><a href="#二、精力的损失" class="headerlink" title="二、精力的损失"></a>二、精力的损失</h2><span id="more"></span>

<p>有很多人喜欢抱怨“无聊”，“无聊”其实就是精力不济的一种标志。在这种状态下，你几乎不可能做任何“有意义”的事情——比如高效率的工作、学习。你只能做一些娱乐性较高看似放松的事情，比如吃零食，上网，看肥皂剧，玩游戏等等。但在这一过程中，你内心的斗志实质上是被逐渐消磨的。随着时间逐渐拉长，你的精力愈发的懈怠，往往会坠入更深的无聊之中。</p>
<p>追究到底，人的精力是有限的，即使是“无聊”的事情，也会耗费精力。所以，当你发现自己很“无聊”时，就不应该再用“无聊”的事来打发时间，这样只会让自己陷入更“无聊”的无限死循环。</p>
<p>想要打破这个循环，就要从根本上了解自己的精力状况，合理的分配和使用精力。</p>
<h2 id="三、精力与体力"><a href="#三、精力与体力" class="headerlink" title="三、精力与体力"></a>三、精力与体力</h2><p>体力是一个非常重要的存在，它可以说是精力存在的保证，乃至来源。</p>
<p>体力是一个人健康程度的象征，如果不够健康的话，自然会常受各种因素影响，没有办法把注意力集中到做有益的事情上去。</p>
<p>体力和精力都是一种可快速恢复的，弹性十足且通过训练可以显着提高的能量，尤其对于那些已经进行过训练的人而言。而当人因体育锻炼而精神焕发的时候，他的精力也随之反弹，而且这一过程经常性并不随着体力值的降低而呈正相关。</p>
<p>你是不是有过这样一种体验：有时候你经过一天的奔波，体力运动，你反而感到精力旺盛，异常兴奋，甚至不能快速睡着。也许这种特例并不能说明体力值降低时人们的精力甚至能随之增长，但它也说明了运动的重要性。</p>
<p>显而易见的是，如果你一整天甚至更长的时间都待在家里，那你恐怕根本没法保持精力旺盛。</p>
<h2 id="四、保护精力"><a href="#四、保护精力" class="headerlink" title="四、保护精力"></a>四、保护精力</h2><h3 id="4-1-避免关注于己无关-没有意义的事情"><a href="#4-1-避免关注于己无关-没有意义的事情" class="headerlink" title="4.1 避免关注于己无关/没有意义的事情"></a>4.1 避免关注于己无关/没有意义的事情</h3><p>有太多的人每天把注意力放在与自己完全无关的事情上，以此消磨自己的意志、精力和时间，原因只是因为他们很“无聊”，不得不说这是一种恶劣的恶性循环。</p>
<h3 id="4-2-避免情绪的波动"><a href="#4-2-避免情绪的波动" class="headerlink" title="4.2 避免情绪的波动"></a>4.2 避免情绪的波动</h3><p>没有什么比强烈的情绪更能直接损耗一个人的精力。如果是强烈的快乐和兴奋还好，但如果是强烈的负面情绪，则会直接让一个人的精力陷入瘫痪。</p>
<h3 id="4-3-保持生活的平衡"><a href="#4-3-保持生活的平衡" class="headerlink" title="4.3 保持生活的平衡"></a>4.3 保持生活的平衡</h3><p>保持生活的平衡包括两部分，身体的平衡和心理的平衡。</p>
<p>身体的平衡要求人们对自己的摄入、睡眠、运动保持掌控，对需要身体的任何情况应对自如。</p>
<p>心理平衡则是同理，它是在“避免情绪波动”之上的一个范畴。这是一个很玄乎的状态，很难用文字表达出来。但当你处于这种状态时，则会时常感觉到平和、富足，而如果这种状态鲜有出现，则应该努力往这个方向靠拢。</p>
<h3 id="4-4-不要在精力充沛的时候做一些损害精力的事情"><a href="#4-4-不要在精力充沛的时候做一些损害精力的事情" class="headerlink" title="4.4 不要在精力充沛的时候做一些损害精力的事情"></a>4.4 不要在精力充沛的时候做一些损害精力的事情</h3><p>错误的放松方式是一种恶性循环，你会在不知不觉之中毁掉自己良好的状态和之前的努力。不要在精力充沛的时间做一些“无聊”的事来消耗自己的精力。</p>
<h2 id="五、获取精力"><a href="#五、获取精力" class="headerlink" title="五、获取精力"></a>五、获取精力</h2><p>获取精力其实是和保护精力不受损害对应的概念，但它更侧重于我们要去做什么，而不是不去做什么。</p>
<h3 id="5-1-保持规律而充足的睡眠"><a href="#5-1-保持规律而充足的睡眠" class="headerlink" title="5.1 保持规律而充足的睡眠"></a>5.1 保持规律而充足的睡眠</h3><p>保持规律而充足的睡眠是如此的重要，重要到那些即使在生活其他方面一团糟的人经过睡眠的修复，也能快速的恢复到一个不错的状态。</p>
<p>大多数人晚睡的原因都不是什么正经的事儿，将注意力集中在没有必要的事情上让人疲惫，睡前刷新网页，玩手机更是会直接损害睡眠质量……何必呢？看看书，保持沉静，安稳睡去，你的七到八个小时睡眠时间绝对不会在白天辜负你。</p>
<p>至于睡眠时间，最好的一种莫过于每天早晨在一个准确的时间起床，并长期坚持。</p>
<h3 id="5-2-培养正确的爱好"><a href="#5-2-培养正确的爱好" class="headerlink" title="5.2 培养正确的爱好"></a>5.2 培养正确的爱好</h3><p>有些爱好就是比其他爱好要更好，比如阅读、观影、写作、摄影、画画，等等。这些爱好会让你感到开心，愉悦，幸福，满足，起到一些其他爱好无法满足的作用。</p>
<p>有些看起来并不怎么有意义的爱好会因人而异产生完全不同的效果。如果你做了而使自己获得了真正的放松——比如狂欢之后感到情绪被宣泄（换到我只会感觉到空虚）。归根结底还是要弄清自己真正适合做的是什么。</p>
<h3 id="5-3-保持活动"><a href="#5-3-保持活动" class="headerlink" title="5.3 保持活动"></a>5.3 保持活动</h3><p>谨记：生命是一种流动中的形式，一个不动的人是很难有活力的。</p>
<h2 id="六、训练精力"><a href="#六、训练精力" class="headerlink" title="六、训练精力"></a>六、训练精力</h2><p>任何事情都需要训练，运动员要训练肌肉记忆，做学问的要训练神经突触，蓄养精力也是同样的道理。将做有意义的事情时的精力上限提高并不仅仅意味着下次再做这件事情的时候能坚持的时间更长，而是意味着即使你只做一定的时间，你的效率也会大为增强。</p>
<p>比如，每天坚持读一个小时的书，或运动一个小时，而当一个小时之后，就可以休息一小会儿或看些轻松的东西。</p>
<p>在逐步的训练中，做某件事的精力值逐步提高了，而因为其趣味性也不断增强，你做其他相较之“不重要”的事情的时间也就缩短了。你的生活将变得更有意义，更加充实，对自我的成长帮助也越大。</p>
<h2 id="七、分配精力"><a href="#七、分配精力" class="headerlink" title="七、分配精力"></a>七、分配精力</h2><h3 id="7-1-不要一次性做完乐意的事"><a href="#7-1-不要一次性做完乐意的事" class="headerlink" title="7.1 不要一次性做完乐意的事"></a>7.1 不要一次性做完乐意的事</h3><p>人的精力是有限的，如果一大早就把自己乐意做的事情都做完了，难的不想做的事留在后面，那么后面的时间里，你整个人都会感到非常疲惫、倦怠。</p>
<p>而且很多人经常用错误的方法去放松自己，也就是做更“无聊”的事，周而复始，很多人的生活就会呈现出一种下滑的状态。</p>
<p>所以，合理分配自己的精力，保持充足的精神，是相当重要的，这样可以避免自己去做“无聊”的事情来打发时间。</p>
<h3 id="7-2-交叉进行耗费和恢复精力的事情"><a href="#7-2-交叉进行耗费和恢复精力的事情" class="headerlink" title="7.2 交叉进行耗费和恢复精力的事情"></a>7.2 交叉进行耗费和恢复精力的事情</h3><p>把一些乐意做的事和不想做的事交叉来做，这样两者都能够完成，并且还可以持续保持状态。</p>
<p>为了做那些我们需要耗费很大精力去完成的事情——比如工作——我们需要做充足的准备，留出足够的空档，并在其后对自己进行恢复。</p>
<p>在除了学习和工作以外的其他时间，分配同样重要。如果你决定每天晚上回家的时间是自己的充电时间——看书，看电影，写作——那你就不可以让自己回家的时候已经感到难受和疲惫。你可以将事情挪到其他时间去做，可以在下班后先做一些让自己兴奋的事情，可以通过训练让自己在某些事情上如鱼得水……不管怎样，你总要找到办法让自己每天的生活更加均衡，而不是完成中间的某一个部分之后就做不了别的事情了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>要知道，我们所有人都会老去，而我们中的几乎所有人都会比自己想像之中更早的老去，而老去时最常见的语言莫过于“精力有限”，“心有余而力不足”。</p>
<p>等到这一能量无可救药离我们远去的时候，我们应该有让自己骄傲的珍惜。到时候你才不会后悔的说，当我在还有机会发挥潜能的时候，却让财富从我的生命中偷偷流走。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/book/clean_code/annotation/</url>
    <content><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="1-注释的作用"><a href="#1-注释的作用" class="headerlink" title="1. 注释的作用"></a>1. 注释的作用</h2><ul>
<li>为了弥补代码表达某种意图时不够清晰的一种手段</li>
</ul>
<h2 id="2-注释的缺点"><a href="#2-注释的缺点" class="headerlink" title="2. 注释的缺点"></a>2. 注释的缺点</h2><ul>
<li>需要写注释，就说明代码很糟糕，代码不能够清晰表达它的意思</li>
<li>注释会随着时间变得腐烂，离其描述的代码越来越远，甚至变得全部是错误的，因为程序员往往不能坚持维护注释</li>
</ul>
<h2 id="3-好注释"><a href="#3-好注释" class="headerlink" title="3. 好注释"></a>3. 好注释</h2><span id="more"></span>

<ul>
<li>不需要写注释就是最好的注释，由代码自己来阐述自己的意义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File tempDirectory = FileUtils.getTempDirectory();</span><br></pre></td></tr></table></figure>

<ul>
<li>法律信息类型的注释，例如版权及著作权声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"> * contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"> * this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"> * The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"> * (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"> * the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提供有用信息的注释，凡是能够根据注释去理解代码所代表的含义的信息，都可以称为有用信息，这个范围比较广</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(<span class="keyword">final</span> File file1, <span class="keyword">final</span> File file2)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> file1Exists = file1.exists();</span><br><span class="line">    <span class="keyword">if</span> (file1Exists != file2.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file1Exists) &#123;</span><br><span class="line">        <span class="comment">// two not existing files are equal</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对意图解释的注释，用于解释当前代码这么做的原因，往往是因为代码中进行了特殊处理，例如性能优化，特例处理等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!directory.mkdirs()) &#123;</span><br><span class="line">    <span class="comment">// Double-check that some other thread or process hasn&#x27;t made</span></span><br><span class="line">    <span class="comment">// the directory in the background</span></span><br><span class="line">    <span class="keyword">if</span> (!directory.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">final</span> String message =</span><br><span class="line">                <span class="string">&quot;Unable to create directory &quot;</span> + directory;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>阐释型注释，这类注释一般是由于代码结构和含义比较难以理解，因而专门进行介绍，例如算法，多参数函数等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Implementation notes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This map usually acts as a binned (bucketed) hash table, but</span></span><br><span class="line"><span class="comment"> * when bins get too large, they are transformed into bins of</span></span><br><span class="line"><span class="comment"> * TreeNodes, each structured similarly to those in</span></span><br><span class="line"><span class="comment"> * java.util.TreeMap. Most methods try to use normal bins, but</span></span><br><span class="line"><span class="comment"> * relay to TreeNode methods when applicable (simply by checking</span></span><br><span class="line"><span class="comment"> * instanceof a node).  Bins of TreeNodes may be traversed and</span></span><br><span class="line"><span class="comment"> * used like any others, but additionally support faster lookup</span></span><br><span class="line"><span class="comment"> * when overpopulated. However, since the vast majority of bins in</span></span><br><span class="line"><span class="comment"> * normal use are not overpopulated, checking for existence of</span></span><br><span class="line"><span class="comment"> * tree bins may be delayed in the course of table methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>警示型注释，用于警告其他程序员不要随便修改此处的代码，或者这里的代码会产生什么后果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SimpleDateFormat is not thread safe,</span></span><br><span class="line"><span class="comment">// so need to create each instance independently</span></span><br><span class="line">SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>TODO 列表注释，一般是由于某些原因暂时还没有做的留空，或者为了以后方便扩展留下的空门</p>
</li>
<li><p>Javadoc 文档注释，用于介绍代码整体结构，提供公共 API 方便别人调用的注释</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An object that maps keys to values.  A map cannot contain duplicate keys;</span></span><br><span class="line"><span class="comment"> * each key can map to at most one value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface takes the place of the &lt;tt&gt;Dictionary&lt;/tt&gt; class, which</span></span><br><span class="line"><span class="comment"> * was a totally abstract class rather than an interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &lt;tt&gt;Map&lt;/tt&gt; interface provides three &lt;i&gt;collection views&lt;/i&gt;, which</span></span><br><span class="line"><span class="comment"> * allow a map&#x27;s contents to be viewed as a set of keys, collection of values,</span></span><br><span class="line"><span class="comment"> * or set of key-value mappings.  The &lt;i&gt;order&lt;/i&gt; of a map is defined as</span></span><br><span class="line"><span class="comment"> * the order in which the iterators on the map&#x27;s collection views return their</span></span><br><span class="line"><span class="comment"> * elements.  Some map implementations, like the &lt;tt&gt;TreeMap&lt;/tt&gt; class, make</span></span><br><span class="line"><span class="comment"> * specific guarantees as to their order; others, like the &lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * class, do not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="4-坏注释"><a href="#4-坏注释" class="headerlink" title="4. 坏注释"></a>4. 坏注释</h2><ul>
<li>不明确的注释，这类注释介绍不清楚，说不清楚代码的含义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Calculate</span></span><br><span class="line"><span class="keyword">double</span> value = money * <span class="number">50</span> + <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>多余的注释，代码本身就很明确，不需要进行多余的注释说明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check null</span></span><br><span class="line"><span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// return if null</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>误导性的注释，有些注释表达不精确，什么具有误导性，注释的内容和代码存在差异</li>
<li>循规式注释，一成不变地遵循每个函数或每个变量都要有注释的规矩，会使得代码中充满注释，结构变得散乱</li>
<li>日志式注释，把注释当成日志在写，每次修改都在注释中添加修改日志。这是旧代码的写法，因为现在已经有代码版本控制系统，不再需要这种写法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Changes log</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2020-04-01: Fixed bug ...</span></span><br><span class="line"><span class="comment"> * 2020-05-01: Add a ...</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>废话注释，像讲故事一样，天马行空，不够简洁，大部分内容都和代码毫无关系</li>
<li>位置标记注释，就是用于特别标记某个代码位置的注释，没有特别价值尽量少用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **************** Start ************** //</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// **************** End   ************** //</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结束括号的标记注释，一般是为了识别每个括号的意义，实际上这类注释没有必要，除非是深层嵌套结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="comment">// if</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">&#125; <span class="comment">// if</span></span><br></pre></td></tr></table></figure>

<ul>
<li>归属或署名，由于当前已经有代码版本控制系统，已经不需要这种注释了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add by xxx at 2020/04/01</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注释的代码，其他程序员可能不敢随便删除注释的代码，因为它们可能还有用处。但是现在已经有了代码版本控制系统，代码可以找回，不需要留着被注释掉的代码</li>
</ul>
<h2 id="5-注释优化"><a href="#5-注释优化" class="headerlink" title="5. 注释优化"></a>5. 注释优化</h2><ul>
<li>尽量用函数或变量来替换注释</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check is validate</span></span><br><span class="line"><span class="keyword">if</span> (length &gt; <span class="number">0</span> &amp;&amp; str != <span class="keyword">null</span> &amp;&amp; str.indexOf(<span class="string">&quot;s&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用变量进行替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isValid = length &gt; <span class="number">0</span> &amp;&amp; str != <span class="keyword">null</span> &amp;&amp; str.indexOf(<span class="string">&quot;s&quot;</span>) &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>提炼废话较多的注释，将不相关的注释内容去掉</li>
<li>短函数不需要太多描述，选择一个好的函数名会比注释来的好</li>
</ul>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>格式</title>
    <url>/book/clean_code/formatter/</url>
    <content><![CDATA[<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="1-垂直格式"><a href="#1-垂直格式" class="headerlink" title="1. 垂直格式"></a>1. 垂直格式</h2><ul>
<li>短的源文件比长的源文件会更好，一般在200行~500行之间为好</li>
<li>源文件的结构应该是从上往下展开，顶部是高层次概念，底下是实现细节，可以简单理解为 public 放在前，private 放在后</li>
<li>每组代码应该是完整的一条思路，不同组代码之间应该用空白行隔开</li>
<li>相关代码应该靠近，避免把相关的概念放到不同文件中，即避免过度使用 protected</li>
<li>变量声明应该尽可能靠近其使用位置</li>
<li>实体变量应该在类的顶部声明</li>
<li>函数调用应该放在一起，也就是被调用者在调用者的下面，保持程序的顺序性</li>
<li>概念相关的代码应该放在一起，相关性越强，彼此之间的距离就应该越短</li>
</ul>
<h2 id="2-水平格式"><a href="#2-水平格式" class="headerlink" title="2. 水平格式"></a>2. 水平格式</h2><span id="more"></span>

<ul>
<li>代码行尽量短小，控制在120个字符以内最好</li>
<li>操作符左/右加上空格，例如 <code>=</code>、<code>+</code>、<code>-</code>、<code>？</code>等左右都应该加上空格，而 <code>,</code> 则是右边加空格</li>
<li>函数名和左括号不加空格</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明时不要加空格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时不要加空格</span></span><br><span class="line">print();</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数之间用逗号和空格隔开，可以明显区分参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数之间加上空格分隔</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(String prefix, String name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有时为了强调运算符之间的关系，使用空格或括号分隔</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 这种方式也可以，但是会被格式化工具清理掉</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span> <span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b*b - <span class="number">4</span>*a*c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 所以建议用括号分隔不同的计算，明确区分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span> <span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b * b) - (<span class="number">4</span> * a * c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不建议使用对齐的变量声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有人喜欢把变量名对齐，</span></span><br><span class="line">    <span class="comment">// 但是格式化工具会把排版清理掉，所以不建议这样写</span></span><br><span class="line">    <span class="keyword">private</span> String  firstName;</span><br><span class="line">    <span class="keyword">private</span> String  lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">private</span> String  address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>即使是单条语句，判断语句 <code>if</code>，<code>while</code>，以及函数都应该用大括号 <code>&#123;&#125;</code> 将代码包起来</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不建议这么写</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该用大括号</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使这样也应该用大括号</span></span><br><span class="line"><span class="keyword">while</span> (isTrue()) &#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不要违反缩进规则，特别是 <code>if</code>，<code>while</code> 和短函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有人会这么写</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123; reurn a &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议缩进</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>有意义的命名</title>
    <url>/book/clean_code/meaningful_naming/</url>
    <content><![CDATA[<h1 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h1><h2 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1. 名副其实"></a>1. 名副其实</h2><ul>
<li><p>变量、函数或类的名称应该能够准确地说明它的意义，比如它存在的意义，它做什么事，以及它应该怎么用。</p>
</li>
<li><p>一旦发现好的命名，就应该换掉旧的名称（当然要确定修改的难易程度）。</p>
</li>
</ul>
<h2 id="2-避免误导"><a href="#2-避免误导" class="headerlink" title="2. 避免误导"></a>2. 避免误导</h2><span id="more"></span>

<ul>
<li><p>避免使用与本意相悖的词语，例如变量名 <code>userList</code>，如果不是 <code>List</code> 类型的变量，就不应该用这种命名。</p>
</li>
<li><p>提防使用区别很小的名称，因为很容易拼写错误。</p>
</li>
<li><p>避免使用误导性比较大的字母，例如 <code>0</code>，<code>O</code>，<code>1</code>，<code>l</code>，因为变量之间的区别只是这些字母的话，看错的可能性比较高。</p>
</li>
</ul>
<h2 id="3-做有意义的区分"><a href="#3-做有意义的区分" class="headerlink" title="3. 做有意义的区分"></a>3. 做有意义的区分</h2><ul>
<li><p>名称不同，那么其意义应该也不同才对。</p>
</li>
<li><p>不要使用数字序列作为名称的区分，会让人搞不清楚用途，例如 <code>a1</code>，<code>a2</code>。</p>
</li>
<li><p>多余的废话是冗余的区分，例如 <code>getProduct</code> 和 <code>getProductData</code> 这种就让人比较疑惑，意思区别不大。</p>
</li>
</ul>
<h2 id="4-使用可读性好的名称"><a href="#4-使用可读性好的名称" class="headerlink" title="4. 使用可读性好的名称"></a>4. 使用可读性好的名称</h2><ul>
<li>名称中的单词应该是可读的词语，或者公认的常见缩写，不要自造词语，例如 <code>modymdhms</code> 和 <code>modifinationTimestamp</code>。</li>
</ul>
<h2 id="5-使用可搜索的名称"><a href="#5-使用可搜索的名称" class="headerlink" title="5. 使用可搜索的名称"></a>5. 使用可搜索的名称</h2><ul>
<li><p>名称长短应该与其作用域大小相对应，长名称要优于短名称。</p>
</li>
<li><p>单字母名字应仅用于短方法中的本地变量，例如 <code>i</code>，<code>j</code>。</p>
</li>
<li><p>对于在代码中多次使用的变量或者常量，应该为其定义便于搜索的名称。例如数字常量 7，可以在代码中定义为 <code>DAYS_PER_WEEK</code>，这会比 7 好找得多。</p>
</li>
</ul>
<h2 id="6-避免使用编码"><a href="#6-避免使用编码" class="headerlink" title="6. 避免使用编码"></a>6. 避免使用编码</h2><ul>
<li><p>不要添加成员前缀（或后缀），例如类成员 <code>m_name</code> 和 <code>name</code>，前后缀是以前旧代码所使用的，现在已经废弃了。</p>
</li>
<li><p>不要使用前导字母 <code>I</code> 来编码区分接口和实现，使用 <code>impl</code> 来标识实现类或许更好。</p>
</li>
</ul>
<h2 id="7-别用俗语"><a href="#7-别用俗语" class="headerlink" title="7. 别用俗语"></a>7. 别用俗语</h2><ul>
<li>不要使用俗语或典故作为名称，因为别人有可能不了解这方面的知识。</li>
</ul>
<h2 id="8-每个概念对应一个词"><a href="#8-每个概念对应一个词" class="headerlink" title="8. 每个概念对应一个词"></a>8. 每个概念对应一个词</h2><ul>
<li>给每个抽象概念都选定一个词，并且一以贯之。例如获取这个概念，<code>fetch</code>，<code>get</code>，<code>retrieve</code> 等都可以拿来使用，但是不要在代码中混杂着写，这里用 <code>fetch</code>，那边用 <code>get</code>，除非有明确说明，否则这很容易会让人受到误导。</li>
</ul>
<h2 id="9-别用双关语"><a href="#9-别用双关语" class="headerlink" title="9. 别用双关语"></a>9. 别用双关语</h2><ul>
<li>避免将同一单词用于不用的目的。例如 <code>add</code> 方法，在这个类中用来表示将两个数加起来，而在另一个类中则表示将对象放入集合中。因此可以修改第二个方法名称为 <code>append</code> 来作出区分。</li>
</ul>
<h2 id="10-添加有意义的语境"><a href="#10-添加有意义的语境" class="headerlink" title="10. 添加有意义的语境"></a>10. 添加有意义的语境</h2><ul>
<li><p>如果语境不够清晰，可以为变量加上前缀。假如成员变量 <code>state</code> 在当前上下文中不是很明确时，因为 <code>state</code> 有可能在多个类中都存在。因此可以为其加上前缀 <code>addrState</code>，这样就能表明 <code>state</code> 是属于 <code>Address</code> 类了。</p>
</li>
<li><p>不要添加没用的语境。例如为每个名称都加上 <code>app</code> 的前缀，如 <code>appUser</code>，<code>appAddress</code>，这根本就是毫无意义的冗余。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/book/clean_code/method/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-短小"><a href="#1-短小" class="headerlink" title="1. 短小"></a>1. 短小</h2><ul>
<li>函数在保证完整性的情况下，越短越好</li>
<li>每个函数都应该一目了然</li>
<li>长度为 20 行最佳</li>
</ul>
<h2 id="2-只做一件事"><a href="#2-只做一件事" class="headerlink" title="2. 只做一件事"></a>2. 只做一件事</h2><ul>
<li>每个函数应该保证只做一件事</li>
<li>要判断函数是否只做了一件事，可以看是否还能再拆出一个函数</li>
<li>一件事是指在同一抽象层次上完成的动作</li>
</ul>
<h2 id="3-每个函数一个抽象层级"><a href="#3-每个函数一个抽象层级" class="headerlink" title="3. 每个函数一个抽象层级"></a>3. 每个函数一个抽象层级</h2><span id="more"></span>

<ul>
<li>抽象层级类似于动作的抽象程度，例如 <code>getData</code> 和 <code>data.push(item)</code> 就属于不同的层次，<code>getData</code> 属于高层级别，而 <code>data.push(item)</code> 已经是属于比较低级别，因为它深入到了数据操作的底层</li>
<li>函数调用一般是高级别调用低级别，这样一层一层深入，是一种自顶向下的规则</li>
<li>如果出现同级别的函数调用，那可能是还有隐含的低层次还未抽象出来</li>
</ul>
<h2 id="4-switch-语句"><a href="#4-switch-语句" class="headerlink" title="4. switch 语句"></a>4. switch 语句</h2><ul>
<li>switch 天生是做多件事的，因此无法满足只做一件事的要求</li>
<li>switch 难以写出较为短小的语句</li>
<li>可以利用抽象工厂的方式，将 switch 抽象到父类中，利用多态来隐藏 switch 语句</li>
</ul>
<h2 id="5-使用描述性的名称"><a href="#5-使用描述性的名称" class="headerlink" title="5. 使用描述性的名称"></a>5. 使用描述性的名称</h2><ul>
<li>好的函数名称可以清晰地说明函数的作用</li>
<li>不要害怕长名称，长而具有描述性的名称，比短而令人费解的名称要好</li>
<li>长而具有描述性的名称，也比描述性的长注释要好</li>
<li>命名应该保持一致，使用与模块名一致的短语、名词或动词</li>
</ul>
<h2 id="6-函数参数"><a href="#6-函数参数" class="headerlink" title="6. 函数参数"></a>6. 函数参数</h2><ul>
<li>函数参数不要多，0个最好，1个比较好，2个还行，3个以上基本不考虑</li>
<li>不要使用输出参数（不是输出值），而应该使用返回值，输出参数已经是以前旧代码的写法了。例如有返回值 <code>StringBuffer transform(StringBuffer in)</code> 会比输出参数 <code>void transform(StringBuffer in)</code> 更好一些</li>
<li>不建议使用标识参数（即 bool 参数），因为违反了一个函数只做一件事的原则，解决方法是拆分成两个函数</li>
<li>3个及以上的参数，应该考虑将其封装成类，从而减少参数数量</li>
</ul>
<h2 id="7-分隔指令与查询"><a href="#7-分隔指令与查询" class="headerlink" title="7. 分隔指令与查询"></a>7. 分隔指令与查询</h2><ul>
<li>函数要么做修改对象的状态，要么返回对象的有关信息，二者不可兼得。例如 <code>boolean set(String attr, String value)</code> 就属于既修改来对象的状态，又返回了有关信息</li>
<li>正确的做法是将指令与查询分开，即利用 <code>set</code> 和 <code>get</code> 来实现</li>
</ul>
<h2 id="8-使用异常替代返回错误码"><a href="#8-使用异常替代返回错误码" class="headerlink" title="8. 使用异常替代返回错误码"></a>8. 使用异常替代返回错误码</h2><ul>
<li>返回错误码轻微违反了指令与查询分隔的规则</li>
<li>返回错误码容易导致多层次的嵌套，因为主流程代码需要根据不同的返回错误码进行不同的错误处理</li>
<li>使用异常替代返回错误码，可以将错误处理代码和主流程代码分离开来</li>
<li>将 try/catch 块抽取出来，单独作为一个函数，因为它容易导致函数结构混乱</li>
<li>使用异常替代错误码，可以使用新异常类从基本异常类中派生出来</li>
</ul>
<h2 id="9-消除重复代码"><a href="#9-消除重复代码" class="headerlink" title="9. 消除重复代码"></a>9. 消除重复代码</h2><ul>
<li>重复代码是影响代码整洁性的罪魁祸首之一</li>
<li>要尽量清除掉代码中的重复代码</li>
</ul>
<h2 id="10-反复调整"><a href="#10-反复调整" class="headerlink" title="10. 反复调整"></a>10. 反复调整</h2><ul>
<li>不要想着一开始就把函数写好，都是反复重构的</li>
<li>将函数的功能实现后，再根据基本原则对代码，对代码进行修改调整</li>
<li>最好给函数加上测试用例，调整完成后要保证函数都能通过测试</li>
</ul>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>对象变化侦测原理（一）</title>
    <url>/framework/vuejs/dection01/</url>
    <content><![CDATA[<h1 id="变化侦测原理"><a href="#变化侦测原理" class="headerlink" title="变化侦测原理"></a>变化侦测原理</h1><h2 id="一、对象属性"><a href="#一、对象属性" class="headerlink" title="一、对象属性"></a>一、对象属性</h2><p>对于 js 对象的属性，可以分为2种：数据属性和访问属性。</p>
<h3 id="1-1-数据属性"><a href="#1-1-数据属性" class="headerlink" title="1.1 数据属性"></a>1.1 数据属性</h3><p>数据属性就是普通的对象属性值，可以读入和写入值。</p>
<p>例如，下述的属性 <code>data</code> 就是数据属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.data = <span class="string">&#x27;data&#x27;</span>;</span><br><span class="line"></span><br><span class="line">alert(obj.data) <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于数据属性，它有4个特性：</p>
<span id="more"></span>

<ul>
<li>[[Configureable]]：表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问属性。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li>
<li>[[Writable]]：表示能否修改数据的值。</li>
<li>[[Value]]：这个属性的值。</li>
</ul>
<p>这些属性特性一般是不能通过一般的方式获取到，需要通过使用方法 <code>Object.getOwnPropertyDescriptor(obj, key)</code>来获取特性值。以上面的代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;data&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一般设置的对象属性，默认都是数据属性，而除了 <code>value</code> 特性以外，其他特性的值都是默认为 <code>true</code>。</p>
<p>如果需要修改特性的值，必须使用方法 <code>Object.defineProperty(obj, key, option)</code>来修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;data&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再查看属性的特性，此时 <code>writable</code> 特性的值就已经发生变化了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;data&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>writable=false</code> 表示属性不能修改，因此修改属性值是不生效的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(obj.data)  <span class="comment">// &quot;data&quot;</span></span><br><span class="line">obj.data = <span class="string">&quot;123&quot;</span> <span class="comment">// 此时修改的话也不生效</span></span><br><span class="line">alert(obj.data)  <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以多次调用 <code>Object.defineProperty</code> 来修改属性特性。</p>
<p>接下来看一下特性 <code>configurable</code> 的作用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>configurable=false</code> 表示属性无法通过 <code>delete</code> 删除，再重新定义属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(obj.data)  <span class="comment">// &quot;data&quot;</span></span><br><span class="line"><span class="keyword">delete</span> obj.data  <span class="comment">// 无法删除</span></span><br><span class="line">alert(obj.data)  <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure>

<p>而且，还有一个比较重要的点，那就是一旦把 <code>configurable</code> 设置为 <code>false</code> 之后，就不能再把它重新恢复为 <code>true</code> 了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置失败，抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-访问属性"><a href="#1-2-访问属性" class="headerlink" title="1.2 访问属性"></a>1.2 访问属性</h3><p>访问属性不包括数据，实际上是通过一对函数 <code>setter</code> 和 <code>getter</code> 进行属性的读取访问和设置。</p>
<p>访问属性不能通过一般的对象属性进行定义，必须使用 <code>Object.defineProperty(obj, key, option)</code> 进行定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.data = <span class="string">&#x27;data&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问属性</span></span><br><span class="line"><span class="keyword">var</span> objProxy = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    obj.data = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(obj.data)        <span class="comment">// &quot;data&quot;</span></span><br><span class="line">alert(objProxy.access) <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure>

<p>属性 <code>access</code> 就是所谓的访问属性，它和一般的数据属性 <code>data</code> 一样，它也有 4 个特性：</p>
<ul>
<li>[[Configureable]]：表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问属性。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li>
<li>[[Get]]：在读取属性时调用的函数。</li>
<li>[[Set]]：在设置属性时调用的函数。</li>
</ul>
<p>其中特性 <code>Configureable</code> 和 <code>Enumerable</code> 和数据属性中的是一样的。</p>
<p>获取属性特性的值也和数据属性的一样，通过方法 <code>Object.getOwnPropertyDescriptor(obj, key)</code> 来获取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(objProxy, <span class="string">&#x27;access&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: [<span class="function"><span class="keyword">function</span> (<span class="params"></span>)],</span></span><br><span class="line"><span class="function">    <span class="title">set</span>: [<span class="function"><span class="keyword">function</span> (<span class="params"></span>)]</span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>访问属性比较特别，可以通过在访问函数 <code>setter</code> 和 <code>getter</code><br>中做一些中间操作，获得其他的效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readTimes = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> writeTimes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    readTimes++;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    writeTimes++;</span><br><span class="line">    obj.data = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">objProxy.access</span><br><span class="line">objProxy.access</span><br><span class="line">alert(readTimes)  <span class="comment">// 2</span></span><br><span class="line">alert(writeTimes) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">objProxy.access = <span class="string">&#x27;111&#x27;</span></span><br><span class="line">alert(readTimes)  <span class="comment">// 2</span></span><br><span class="line">alert(writeTimes) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这种利用访问函数的方式，其实就是 <code>Vue</code> 定义响应式属性所用的方法，通过利用访问属性的 <code>setter</code> 和 <code>getter</code> 来收集和通知属性发生了变更，就可以实现响应式属性。</p>
<p>也许，访问属性叫访问方法更好，虽然操作上和数据属性类似，但是它本身并不算一个属性，只是通过方法 <code>setter</code> 和 <code>getter</code> 进行了定义，然后拿的还是其他数据属性的值。</p>
<p>定义 <code>setter</code> 和 <code>getter</code> 实际上就是在定义 <code>objProxy.access=</code> 和 <code>objProxy.access</code>。调用 <code>objProxy.access</code> 就是在调用 <code>getter</code> 函数，调用 <code>objProxy.access=</code> 就是在调用 <code>setter</code> 函数。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>对象变化侦测原理（二）</title>
    <url>/framework/vuejs/dection02/</url>
    <content><![CDATA[<h2 id="二、Object-变化侦测"><a href="#二、Object-变化侦测" class="headerlink" title="二、Object 变化侦测"></a>二、Object 变化侦测</h2><p>变化侦测指的是，当运行时的状态发生变化时，应用程序可以知道哪个状态发生了变化，并作出相应的动作。</p>
<p>变化侦测的方式可以分为2种：一种是“推（push）”，一种是“拉（pull）”。</p>
<p>Vue 的变化侦测就属于“推，当状态发生变化时，它就会通知相应的依赖对象进行更新。</p>
<h3 id="2-1-追踪变化"><a href="#2-1-追踪变化" class="headerlink" title="2.1 追踪变化"></a>2.1 追踪变化</h3><span id="more"></span>

<p>前面说过，Object 的属性可以分为2种：数据属性和访问属性。</p>
<p>Vue 就是通过利用访问属性的 <code>setter</code> 和 <code>getter</code> 函数来追踪对象的变化的。</p>
<p>每当对象属性被读取时，<code>getter</code> 函数就会被触发；每当对象属性更新时，<code>setter</code> 函数就会被触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isStateChange = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    obj.data = val;</span><br><span class="line">    isStateChange = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">objProxy.access</span><br><span class="line">alert(isStateChange)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">objProxy.access = <span class="string">&#x27;111&#x27;</span></span><br><span class="line">alert(isStateChange)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-收集依赖"><a href="#2-2-收集依赖" class="headerlink" title="2.2 收集依赖"></a>2.2 收集依赖</h3><p>知道了如何监听对象的变化，但是应该如何收集依赖呢？也就是说当状态发生变化后，该向谁通知状态变更呢？</p>
<p>收集依赖需要分为3步：要收集什么？什么时候收集？收集到哪里？</p>
<ul>
<li>1、要收集什么？</li>
</ul>
<p>哪些算是依赖？其实就是用到了对象属性的地方就是依赖。比如说：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; obj.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于上述模板，它调用了 <code>name</code> 属性，也就是对 <code>obj.name</code> 产生了依赖，当 <code>obj.name</code> 发生变化时，就需要通知模板进行重新渲染。</p>
<p>对于这种调用了对象属性的地方，都是需要收集起来的。</p>
<ul>
<li>2、什么时候收集？</li>
</ul>
<p>前面已经说过了，Vue 是通过利用访问属性的 <code>setter</code> 和 <code>getter</code> 函数来进行侦听变化的。</p>
<p>因此收集原理也很简单，在 <code>getter</code> 中收集依赖，在 <code>setter</code> 中触发依赖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isStateChange = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    obj.data = val;</span><br><span class="line">    isStateChange = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">objProxy.access</span><br><span class="line">alert(isStateChange)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">objProxy.access = <span class="string">&#x27;111&#x27;</span></span><br><span class="line">alert(isStateChange)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>3、收集到哪里？</li>
</ul>
<p>对于这个，可以简单地为每一个属性创建一个局部变量 <code>dep</code> 来保存。</p>
<p>假设依赖对象是一个函数，并且保存在 <code>window.target</code> 中，那么依赖的收集和通知实现可以如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = []; <span class="comment">// 保存依赖的地方</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="comment">// 假设依赖对象保存在 window.target 中</span></span><br><span class="line">      dep.push(<span class="built_in">window</span>.target);</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dep.length; i++) &#123;</span><br><span class="line">        dep[i](newVal, val)</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照这种实现方式，每个对象属性都拥有自己的依赖收集器 <code>dep</code>。</p>
<p>当然，实际的 <code>dep</code> 并不是那么简单的一个数组，为了减低代码的耦合性，Vue 中把它实现为一个类 <code>Dep</code>，下面是它的简单实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 依赖，订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="comment">// 假设依赖对象保存在 window.target 中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.target) &#123;</span><br><span class="line">      <span class="built_in">this</span>.addSub(<span class="built_in">window</span>.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subd.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 通知依赖（订阅者）更新</span></span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</span><br><span class="line">    <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据新的 <code>dep</code>，修改 <code>defineReactive</code> 实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep(); <span class="comment">// 修改1</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集依赖</span></span><br><span class="line">      dep.depend(); <span class="comment">// 修改2</span></span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify(); <span class="comment">// 修改3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，收集依赖的工作基本完成了。</p>
<p>等等，还有一件重要的事，究竟什么是依赖呢？它到底从哪来的？虽然在前面的代码里，假设依赖是一个函数，并且已经设置到了 <code>window.target</code> 中， 但是并没有具体说明它是从哪里来的，是什么时候设置到 <code>window.target</code> 的。下面详细说明一下它。</p>
<ul>
<li>依赖对象</li>
</ul>
<p>前面说过，依赖实际上是用到对象属性的地方，但是用到对象属性的地方太多了，而且类型可能不一样，环境也不一样。这个时候为了能够统一处理依赖对象，需要将其抽象成一个依赖对象，这个依赖对象就称为观察者 <code>Watcher</code>，它就像是一直在观察对象属性的变化一样，当对象属性发生变化后，它就可以通过“观察”发现，从而进行相应的动作。</p>
<p>在 Vue 中，<code>Watcher</code> 是一个中介对象，当数据发生变化时，会通知到观察者 <code>Watcher</code>，然后 <code>Watcher</code> 再通知其他地方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">vm, expOrFn, cb</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="comment">// 先把this设置到window.target中，然后再读取对象属性</span></span><br><span class="line">    <span class="built_in">window</span>.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 这时候被读到的对象属性就会把当前this收集到它的依赖集合里面</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.vm);</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="built_in">this</span>.cb(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.value, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收集依赖的过程实际上就在 <code>getter</code> 函数被调用的时候，那么 <code>getter</code> 函数具体是什么呢？也就是 <code>parsePath</code> 的实现是怎么样的呢？</p>
<p>其实 <code>parsePath</code> 的参数 <code>path</code> 是类似 <code>a.b.c</code> 这样的形式，如果用过 Vue 的话，就应该知道 Vue 中可以利用 <code>vm.$watch(&#39;a,b.c&#39;, function()&#123;&#125;)</code> 这种形式来监听对象属性的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际原理很简单，<code>parsePath</code> 只是按照分隔符 <code>.</code> 来逐层地访问对象属性。</p>
<p>而前面说过，当读取对象的访问属性时，会触发依赖收集。所以当 <code>getter</code> 函数执行时，它其实就是在读取对象的访问属性，这个时候就会触发依赖收集的逻辑。</p>
<h3 id="2-3-监测所有属性"><a href="#2-3-监测所有属性" class="headerlink" title="2.3 监测所有属性"></a>2.3 监测所有属性</h3><p>对于每个属性，如果需要监测它的变化，必须经过 <code>defineReactive</code> 来处理，这样它才能像访问属性那样收集依赖，实现响应式侦听。</p>
<p>为了提高代码的封装，Vue 中封装了一个监听类 <code>Observer</code> 类，用于监听对象的所有属性。</p>
<p>类 <code>Observer</code> 的作用就是将对象的所有属性都转换成访问属性，通过访问属性的 <code>setter</code> 和 <code>getter</code> 来实现变化追踪：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  walk (obj) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集依赖</span></span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 <code>Observer</code> 的实现原理很简单，就是把所有属性都遍历一遍，利用 <code>defineReactive</code> 将属性都转成可追踪的访问属性。</p>
<h3 id="2-4-存在问题"><a href="#2-4-存在问题" class="headerlink" title="2.4 存在问题"></a>2.4 存在问题</h3><p>Object 类型数据的变化侦听，其原理是通过访问属性 <code>setter/getter</code> 方法来实现的。</p>
<p>但是这种方式还存在一些问题，比如添加新属性、删除新属性时，<code>setter/getter</code> 是不会触发的，这些情况就没办法追踪属性的变化了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isStateChange = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    isStateChange = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    obj.data = val;</span><br><span class="line">    isStateChange = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除属性不会触发set/get</span></span><br><span class="line"><span class="keyword">delete</span> objProxy.access</span><br><span class="line">alert(isStateChange)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增属性也不会触发set/get</span></span><br><span class="line">objProxy.name = <span class="string">&#x27;newProp&#x27;</span></span><br><span class="line">alert(isStateChange)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>setter/getter</code> 只能跟踪属性值是否发生修改，但是没办法侦测到新增属性和删除属性。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>对象变化侦测原理（三）</title>
    <url>/framework/vuejs/dection03/</url>
    <content><![CDATA[<h2 id="三、Array-数组侦测"><a href="#三、Array-数组侦测" class="headerlink" title="三、Array 数组侦测"></a>三、Array 数组侦测</h2><p>数组 Array 虽然也是属于对象类型，但还是存在一些差别，它没办法像 Object 对象那样，通过 <code>setter/getter</code> 的方式来监听属性的变化，因此对于 Array 而言，需要用到另外一套变化侦测方案。</p>
<h3 id="3-1-如何追踪变化"><a href="#3-1-如何追踪变化" class="headerlink" title="3.1 如何追踪变化"></a>3.1 如何追踪变化</h3><p>我们知道，Array 数组有很多个内置方法可以改变数组的值，比如 <code>push</code>,<code>pop</code>,<code>shift</code>等，这些方法都可以改变数组的内容，所以可以尝试通过监听这些方法的调用，来达到监听数组变化的目的。</p>
<p>但是，这些方法都是内置方法，而且 js 中并没有提供接口给我们覆盖，因此要如何修改这些方法，以达到我们需要的效果呢？</p>
<span id="more"></span>

<p>答案是，原型方法覆盖。</p>
<p>方法覆盖的方式可以分为2种：自定义同名私有方法，数组对象原型覆盖。</p>
<ul>
<li>1、自定义同名私有方法</li>
</ul>
<p>比如说，我们通过给数组对象添加同名的私有方法，就可以覆盖数组的内置方法。</p>
<p>假设数组对象 <code>arr</code> 本身自带有内置方法 <code>push</code>，我们可以通过添加同名私有方法 <code>arr.push</code> 来覆盖它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.push = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 里面再调回数组的内置方法</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.push.apply(arr, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过利用私有方法调用优先级的方式，就可以实现内置方法的代理。</p>
<p>每当我们调用 <code>push</code> 方法时，效果依旧和原来的一样，只不过实际上调用的是被我们包装代理过后的方法。</p>
<ul>
<li>2、数组对象原型覆盖</li>
</ul>
<p>除了使用私有方法覆盖的方式以外，还可以通过覆盖数组对象原型 <code>Array.prototype</code> 来实现。</p>
<p>我们都知道，在调用方法时，会优先从当前对象中查找该方法，如果没有，则会继续往上查找对象的原型中有没有该方法，然后这样一直向上，直到找到对应的方法为止，因此我们可以通过覆盖原型对象来实现方法代理。</p>
<p>比如说，数组对象 <code>arr</code> 在调用方法 <code>push</code> 时，会先查找本身有没有这个方法，如果没有，它就会去找原型 <code>Array.prototype</code> 中有没有该方法，这个时候找到了，就可以顺利调用 <code>push</code> 方法了。</p>
<p>假设这个时候，我把 <code>arr</code> 的原型换掉，换成我们自己封装过的，那么在数组对象向上寻找方法时，就会去我们换过的原型中查找方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="comment">// 覆盖原型对象</span></span><br><span class="line">arr.__proto__ = &#123;</span><br><span class="line">  <span class="attr">push</span>: <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 里面再调回数组的内置方法</span></span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.apply(arr, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这种原型对象替换的方式，也可以实现内置方法的代理。</p>
<h3 id="3-2-方法拦截器"><a href="#3-2-方法拦截器" class="headerlink" title="3.2 方法拦截器"></a>3.2 方法拦截器</h3><p>方法拦截器就是前面介绍的2种代理方式，其实对于这2种代理方式，Vue 中都有相应的实现。</p>
<p>首先，需要代理的方法是能够修改数组对象的方法，包括7个方法：<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>。</p>
<p>其实，我们再构造拦截方法，具体看 Vue 的代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个和原始数组原型一样的对象</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要拦截的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现方法拦截</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 里面再调回原始的方法</span></span><br><span class="line">      <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      <span class="comment">// 后面还可以做其他事情</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过这种方法，我们就可以拦截数组对象的方法调用。</p>
<p>然后，将构造好的拦截方法设置到数组对象上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否支持 `__proto__` 属性</span></span><br><span class="line"><span class="keyword">const</span> hasProto = <span class="string">&#x27;__proto__&#x27;</span> <span class="keyword">in</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 需要拦截的方法名称集合</span></span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="built_in">Object</span>.getOwnPropertyNames(arrayMethods)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 数组的方法拦截处理</span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="comment">// 原型替换</span></span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义私有方法</span></span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换原型拦截代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src</span>) </span>&#123;</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义私有方法拦截代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target, src, keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">      <span class="attr">value</span>: src[key],</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要2种实现方式呢？只用自定义私有方法不就可以实现了吗？</p>
<p>其实是 Vue 优先使用原型替换来实现拦截，但是由于原型属性 <code>__proto__</code> 在 ES6 之前并不属于官方标准属性，也就是说，通过 <code>__proto__</code>  访问原型的方式并不是所有浏览器都支持！！！</p>
<p>所以，当浏览器不支持 <code>__proto__</code> 时，就使用自定义方法拦截的方式实现。</p>
<h3 id="3-3-收集依赖"><a href="#3-3-收集依赖" class="headerlink" title="3.3 收集依赖"></a>3.3 收集依赖</h3><p>既然方法拦截已经实现了，那么接下来就应该要实现依赖收集了。</p>
<p>依旧是按3步走：在哪里收集依赖、收集到哪里、什么时候触发依赖。</p>
<ul>
<li>在哪里收集依赖</li>
</ul>
<p>这个其实和 Objec 对象一样，数组对象的依赖也是在 <code>getter</code> 中收集的。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，访问数组对象实际上都是通过访问另外一个对象的属性来得到的，例如这里的 <code>obj.arr</code>。</p>
<p>也就是说，在收集 <code>obj.arr</code> 属性的依赖时，可以顺便收集数组的依赖，记住，是顺便收集~~。</p>
<p>因此，Array 数组对象的依赖收集，也是在 <code>defineReactive</code> 中收集的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集对象属性的依赖</span></span><br><span class="line">      dep.depend()</span><br><span class="line">      <span class="comment">// 如果val是数组，则顺便收集数组的依赖</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(val)) &#123;</span><br><span class="line">        <span class="comment">// 这里收集数组依赖</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在收集值为数组对象依赖时，实际上收集了2次依赖，一次是对象属性 <code>obj.arr</code> 的依赖），一次是属性对应的数组值 <code>[1, 2, 3]</code> 的依赖。</p>
<p>综上，Array 数组对象的依赖是在 <code>getter</code> 中收集，而依赖的触发则是在方法拦截器中。</p>
<ul>
<li>收集到哪里</li>
</ul>
<p>Array 数组对象依赖收集起来的地方，和 Object 对象的稍微有点不同。</p>
<p>原因在于，Object 对象的依赖收集和依赖触发，都是放在同一个作用域内的，也就是 <code>getter/setter</code> 方法，因此依赖只要保存在收集和触发的方法都能访问到的地方即可，在代码中也就是在 <code>defineReactive</code> 方法内。</p>
<p>而 Array 数组对象的话，依赖收集是在 <code>getter</code> 方法中，依赖触发则是在方法拦截器中，需要保证它们俩都能访问到依赖才行。</p>
<p>其实也很简单，只要找到它们的公共父作用域即可，而数组对象本身就可以满足这个条件。</p>
<p>为了能够让收集和触发访问到依赖对象，我们可以将依赖对象保存到数组对象中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="comment">// 把依赖对象保存在数组对象中，这样两边都可以访问</span></span><br><span class="line">    <span class="built_in">this</span>.value.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 数组的方法拦截处理</span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="comment">// 原型替换</span></span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义私有方法</span></span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="keyword">let</span> childOb</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    childOb = <span class="keyword">new</span> Observer(val) <span class="comment">// 修改</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集对象属性的依赖</span></span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="comment">// 如果有子对象/子数组</span></span><br><span class="line">      <span class="keyword">if</span> (childOb &amp;&amp; childOb.value.dep) &#123; <span class="comment">// 修改</span></span><br><span class="line">        childOb.value.dep.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法拦截</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 里面再调回原始的方法</span></span><br><span class="line">      <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      <span class="comment">// 前面已经把依赖保存到数组的属性中，可以直接调用</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.dep) &#123; <span class="comment">// 修改</span></span><br><span class="line">        <span class="built_in">this</span>.dep.notify() </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然这种方式也可以使得收集和触发都能访问到 <code>dep</code> 依赖对象，但是感觉不是很优雅，代码中直接在 <code>value</code> 上赋值了 <code>value.dep</code> 属性，这样很容易造成冲突。</p>
<p>所以 Vue 使用了另外一种方式，不是直接在 <code>value</code> 上添加属性 <code>value.dep</code>，而是在 <code>value</code> 上加了一个私有属性 <code>__ob__</code>，表示观察者 <code>Observer</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep() <span class="comment">// 修改，直接把依赖放在观察者下</span></span><br><span class="line">    <span class="built_in">this</span>.value.__ob__ = <span class="built_in">this</span> <span class="comment">// 修改，保存到 value.__ob__ 中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 数组的方法拦截处理</span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="comment">// 原型替换</span></span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义私有方法</span></span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="keyword">let</span> childOb</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    childOb = <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集对象属性的依赖</span></span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="comment">// 如果有子对象/子数组</span></span><br><span class="line">      <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">        childOb.dep.depend() <span class="comment">// 修改</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法拦截</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 里面再调回原始的方法</span></span><br><span class="line">      <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 先获取观察者，再得到依赖</span></span><br><span class="line">      <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__ <span class="comment">// 修改</span></span><br><span class="line">      <span class="keyword">if</span> (ob) &#123;</span><br><span class="line">        ob.dep.notify() </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-存在问题"><a href="#3-4-存在问题" class="headerlink" title="3.4 存在问题"></a>3.4 存在问题</h3><p>数组的变化侦测存在的问题，其实很明显。从上面的介绍可知，数组的变化侦测是通过代理数组的原型方法来实现的，所以只要是不经过代理方法调用的，都不会被侦测到。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">arr.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>类似这种直接修改数组的值，就不会被变化侦测检测到。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器中的BOM对象</title>
    <url>/lang/js/bom/</url>
    <content><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM 是指浏览器对象模型。</p>
<p>主要用于开发人员控制浏览器显示的界面以外的部分，例如浏览器窗口的位置、浏览器的地址信息、浏览历史界面的前进后退等。</p>
<h2 id="一、window"><a href="#一、window" class="headerlink" title="一、window"></a>一、window</h2><p>window 对象是 BOM 的核心对象，表示浏览器的一个实例。</p>
<span id="more"></span>

<h2 id="1-1-全局声明"><a href="#1-1-全局声明" class="headerlink" title="1.1 全局声明"></a>1.1 全局声明</h2><p>window 既是访问浏览器窗口的接口，也是 ECMAScript 的全局对象（Global）。</p>
<p>直接在全局作用域声明的变量、函数等都会变成 window 对象的属性和方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> name = <span class="string">&#x27;zhangsan&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  </span></span><br><span class="line"><span class="javascript">  alert(name)              <span class="comment">// zhangsan</span></span></span><br><span class="line"><span class="javascript">  alert(getName())         <span class="comment">// zhangsan</span></span></span><br><span class="line"><span class="javascript">  alert(<span class="built_in">window</span>.name)       <span class="comment">// zhangsan </span></span></span><br><span class="line"><span class="javascript">  alert(<span class="built_in">window</span>.getName())  <span class="comment">// zhangsan</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然定义全局变量会直接归到 window 中，但是还是和直接在 window 中定义的属性有点不同。</p>
<p>全局变量不能使用 <code>delete</code> 删除变量，但是在 window 中定义的属性是可以的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> name = <span class="string">&#x27;zhangsan&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.age = <span class="number">12</span></span></span><br><span class="line"><span class="javascript">  </span></span><br><span class="line"><span class="javascript">  alert(<span class="built_in">window</span>.name) <span class="comment">// zhangsan </span></span></span><br><span class="line"><span class="javascript">  alter(<span class="built_in">window</span>.age)  <span class="comment">// 12</span></span></span><br><span class="line"><span class="javascript">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 删除无用</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">delete</span> <span class="built_in">window</span>.name</span></span><br><span class="line"><span class="javascript">  alter(<span class="built_in">window</span>.name) <span class="comment">// zhangsan</span></span></span><br><span class="line"><span class="javascript">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 可以删除</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">delete</span> <span class="built_in">window</span>.age</span></span><br><span class="line"><span class="javascript">  alter(<span class="built_in">window</span>.age)  <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>产生这种情况的原因是，全局声明的变量，虽然被归到 window 中，但是它的一个特性值 <code>[[Configurable]]</code> 默认会被设为 <code>false</code>，导致全局声明的变量没有办法使用 <code>delete</code> 进行删除。</p>
<h2 id="1-2-窗口和框架"><a href="#1-2-窗口和框架" class="headerlink" title="1.2 窗口和框架"></a>1.2 窗口和框架</h2><p>框架，一般指的是 <code>HTML</code> 中的 <code>&lt;frame&gt;</code> 标签所表述的元素。</p>
<ul>
<li><p>每个框架都类似于一个浏览窗口，因此每个框架都有自己的 window 对象。</p>
</li>
<li><p>框架的 window 对象会保存在父框架或父窗口的 <code>window.frames</code> 中。</p>
</li>
<li><p>一般情况下框架的 window 对象都会有一个 name 属性。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;top.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;topFrame&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;bottom-left.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;bottomLeftFrame&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;bottom-right.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;bottomRightFrame&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于当前的 window 而言，<code>window.frames</code> 将会包含3个 window 对象，分别是框架 <code>topFrame</code>、<code>bottomLeftFrame</code> 和 <code>bottomRightFrame</code> 的 window 对象。</p>
<p>可以通过 <code>window.frames[1]</code> 或者 <code>window.frames[&#39;bottomLeftFrame&#39;]</code> 来访问指定的框架 window 对象。</p>
<h3 id="1-2-1-top"><a href="#1-2-1-top" class="headerlink" title="1.2.1 top"></a>1.2.1 top</h3><p>top（window.top）对象始终指向最高（最外）层的框架，也就是浏览器窗口。</p>
<h3 id="1-2-2-parent"><a href="#1-2-2-parent" class="headerlink" title="1.2.2 parent"></a>1.2.2 parent</h3><p>parent（window.parent）对象指的是当前框架的直接上层框架（父框架）。</p>
<p>在没有框架的情况下，<code>parent === top</code>。</p>
<p>加入上述代码中的 top.html 文件如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;topInnerLeft.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;topInnerLeftFrame&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;topInnerRight.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;topInnerRightFrame&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么对于框架 topInnerLeftFrame 的 window 对象而言，它的 <code>window.parent</code> 指的就是框架 topFrame 的 window 对象。</p>
<h3 id="1-2-3-self"><a href="#1-2-3-self" class="headerlink" title="1.2.3 self"></a>1.2.3 self</h3><p>self（window.self）指的是 window 对象本身。</p>
<p>引入 self 只是为了和 top、parent 对应，貌似没什么特别作用。</p>
<h2 id="1-3-窗口位置"><a href="#1-3-窗口位置" class="headerlink" title="1.3 窗口位置"></a>1.3 窗口位置</h2><p>窗口位置指的是浏览器窗口在屏幕上的位置信息。不同浏览器提供的位置属性不一样。</p>
<p>IE、Safari、Opera 和 Chrome 都提供 <code>screenLeft</code> 和 <code>screenRight</code>，分用于表示窗口相对于屏幕的左边和上边的位置。</p>
<p>FireFox、Safari、Chrome 提供 <code>screenX</code> 和 <code>screenY</code> ，对应相同的位置信息。</p>
<p>跨浏览器获取浏览器窗口的位置信息，可以用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">&#x27;number&#x27;</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">&#x27;number&#x27;</span>) ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure>

<p>移动窗口位置，可以使用 <code>moveTo</code> 和 <code>moveBy</code> 方法，<code>moveTo</code> 是移动到指定的位置， <code>moveBy</code> 是移动的方向距离。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将窗口移动到(100, 200)</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将窗口向右移动100，向下移动200</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>不过这两个方法有可能被浏览器禁用，因此最好不要使用。</p>
<h2 id="1-4-窗口大小"><a href="#1-4-窗口大小" class="headerlink" title="1.4 窗口大小"></a>1.4 窗口大小</h2><p>IE9+、Firefox、Safari、Opera 和 Chrome 提供了4个属性来获取窗口的大小：<code>innerWidth</code>、<code>innerHeight</code>、<code>outerWidth</code>、<code>outerHeight</code>，不过不同浏览器返回的值不太相同。有些是返回浏览器窗口本身的大小，有些是返回视口（viewport）的大小。</p>
<p>获取视口大小的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">window</span>.innerHeight</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">&#x27;CSS1Compat&#x27;</span>) &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.body.clientWidth</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>resizeTo</code> 和 <code>resizeBy</code> 可以改变浏览器窗口的大小。<code>resizeTo</code> 是指定改变后浏览器窗口的大小，<code>resizeBy</code> 是指定改变窗口的宽高差值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将窗口大小改变为(100, 200)</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将窗口宽度减少100，高度减少200</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>不过这两个方法也有可能被浏览器禁用，因此也是最好不要使用。</p>
<h2 id="1-5-导航和打开窗口"><a href="#1-5-导航和打开窗口" class="headerlink" title="1.5 导航和打开窗口"></a>1.5 导航和打开窗口</h2><p><code>window.open()</code> 方法可以导航到特定的 URL，也可以打开一个新的浏览器窗口。</p>
<p>接收的参数可以有4个：</p>
<ul>
<li>URL：要加载的URL</li>
<li>窗口目标：指定打开窗口的位置，是在当前窗口打开，还是新窗口打开</li>
<li>特性字符串：指定打开窗口的相关信息，例如窗口的高度、宽度等</li>
<li>标志位：用于标识新页面是否设置为浏览器历史记录中的当前加载页面</li>
</ul>
<p>第二个参数的可选值有：</p>
<ul>
<li>_self：当前框架或窗口打开</li>
<li>_parent：父框架或父窗口打开</li>
<li>_top：当前浏览器窗口打开</li>
<li>_blank：新的浏览器窗口打开</li>
<li>frameName：指定的框架打开，不存在该框架时，新窗口打开</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于&lt;a href=&quot;http://ww.baidu.com&quot;, target=&quot;topFrame&quot;&gt;</span></span><br><span class="line"><span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;topFrame&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码会在 topFrame 框架中加载新页面，如果框架不存在，则会新窗口打开。</p>
<h3 id="1-5-1-窗口引用"><a href="#1-5-1-窗口引用" class="headerlink" title="1.5.1 窗口引用"></a>1.5.1 窗口引用</h3><p><code>window.open()</code> 方法会返回一个指向新窗口的引用，该引用和 window 对象差不多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;topFrame&#x27;</span>)</span><br><span class="line">newWin.moveTo(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">newWin.resizeTo(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line">newWin.close()</span><br></pre></td></tr></table></figure>

<p>同时，新打开窗口也拥有一个属性 opener 指向创建它的原始窗口对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;topFrame&#x27;</span>)</span><br><span class="line">alert(newWin.opener == <span class="built_in">window</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-窗口屏蔽"><a href="#1-5-2-窗口屏蔽" class="headerlink" title="1.5.2 窗口屏蔽"></a>1.5.2 窗口屏蔽</h3><p>大多数浏览器有内置的弹出窗口屏蔽程序，因此 <code>window.open()</code> 有可能返回 null。因此使用 <code>window.open()</code> 时，最好封装在一个 <code>try-catch</code> 块中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (newWin == <span class="literal">null</span>) &#123;</span><br><span class="line">      blocked = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  blocked = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;open window was blocked&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-location"><a href="#1-6-location" class="headerlink" title="1.6 location"></a>1.6 location</h2><p>location（window.location）对象提供了当前窗口中加载的文档的有关信息，还有导航功能。</p>
<p>另外，在 window 和 document 中，有 <code>window.location == document.location</code>。</p>
<p>location 对象中包含的属性有：</p>
<ul>
<li>href：当前加载页面的完整 URL，如 <a href="http://www.baidu.com/">http://www.baidu.com</a></li>
<li>procotol：页面使用的协议，如 http:、https:</li>
<li>host：服务器名称以及端口，如 <a href="http://www.baidu.com/">www.baidu.com:80</a></li>
<li>hostname：服务器名称，不包括端口，如 <a href="http://www.baidu.com/">www.baidu.com</a></li>
<li>port：端口号，如 80</li>
<li>pathname：URL 路径，如 /uers/info</li>
<li>search：URL 查询字符串，如 ?age=12&amp;&amp;city=guangzhou</li>
<li>hash：URL 中的散列值，如 #content</li>
</ul>
<h2 id="1-6-1-位置操作"><a href="#1-6-1-位置操作" class="headerlink" title="1.6.1 位置操作"></a>1.6.1 位置操作</h2><p>直接改变 location 代表的值，就可以直接打开新的 URL：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这几种方式效果是一样的</span></span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">location.href = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">location.assign(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>也可以单独修改 location 里面的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://www.baidu.com:80/users/</span></span><br><span class="line"><span class="built_in">window</span>.location</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.baidu.com:80/users/#content</span></span><br><span class="line">location.hash = <span class="string">&#x27;#content&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.baidu.com:80/another/</span></span><br><span class="line">location.pathname = <span class="string">&#x27;another&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.baidu.com:8080/users/</span></span><br><span class="line">location.port = <span class="string">&#x27;8080&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用上述的修改方式，会在浏览器的历史记录中生成一条新的记录，因此用户通过单击“后退”按钮后可以返回到上一个页面。</p>
<h3 id="1-6-2-相关方法"><a href="#1-6-2-相关方法" class="headerlink" title="1.6.2 相关方法"></a>1.6.2 相关方法</h3><p>使用 <code>location.repalce()</code> 方法可以禁用这种行为，它会导航到一个新的页面，但是不会在浏览器历史记录中生成新的记录。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不会生成新的历史记录，因此跳转后无法回到前一个页面</span></span><br><span class="line">location.replace(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用 <code>location.reload()</code> 方法可以重新加载当前显示的页面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有可能从缓存中加载</span></span><br><span class="line">location.reload()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制从服务器加载</span></span><br><span class="line">location.reload(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="1-7-navigator"><a href="#1-7-navigator" class="headerlink" title="1.7 navigator"></a>1.7 navigator</h2><p>navigator（window.navigator） 对象用于识别客户端浏览器的类型等信息。</p>
<p>主要实现属性包括（还有很多属性没列出来）：</p>
<ul>
<li>appCodeName：浏览器名称</li>
<li>appName：完整的浏览器名称</li>
<li>appVersion：浏览器的版本</li>
<li>cookieEnabled：表示 cookie 是否启用</li>
<li>mimeTypes：在浏览器中注册的MIME类型数组</li>
<li>platform：浏览器所在的系统平台</li>
<li>plugins：浏览器安装的插件</li>
<li>userAgent：浏览器的用户代理字符串</li>
</ul>
<p>navigator 对象主要提供来比较多来`客户端浏览器的相关信息，不同的浏览器实现还不一样。</p>
<h2 id="1-8-screen"><a href="#1-8-screen" class="headerlink" title="1.8 screen"></a>1.8 screen</h2><p>screen（window.screen）对象用来表明客户端的一些属性，包括浏览器窗口外部的显示器的信息，例如像素宽度和高度。</p>
<p>其中包含的属性有：</p>
<ul>
<li>height：屏幕的像素高度</li>
<li>width：·屏幕的像素宽度</li>
<li>left：当前屏幕距左边的像素距离</li>
<li>top：当前屏幕距上边的像素距离</li>
<li>colorDepth：用于表示颜色的位数</li>
</ul>
<p>screen 对象不常用，而且在涉及移动设备时，使用前还需要进行相应的调整。</p>
<h2 id="1-9-history"><a href="#1-9-history" class="headerlink" title="1.9 history"></a>1.9 history</h2><p>history（window.history）对象用于保存用户上网的历史记录，从打开窗口的那一刻算起。</p>
<p>history 是 window 的属性，因此不同的浏览器窗口、标签页、框架等都有自己的 history 对象。</p>
<p>出于安全考虑，history 对象不能看到用户浏览过的 URL，只能指导历史记录条数等一些信息。</p>
<p>使用 <code>go()</code> 方法可以在历史记录中进行任意的跳转，可以向前或者向后。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.go(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进两页</span></span><br><span class="line">history.go(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><code>go()</code> 还可以使用字符串，表示跳转到包含该字符串的记录，因此有可能是前进，也可能是后退：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳到最近的 baidu.com 页面</span></span><br><span class="line">history.go(<span class="string">&#x27;baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用简写的 <code>forward()</code> 和 <code>back()</code> 可以用来替代 <code>go(1)</code> 和 <code>go(-1)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.back()</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js如何处理错误</title>
    <url>/lang/js/error/</url>
    <content><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>在 Javascript 中，处理异常的方式一般有两种：</p>
<ul>
<li>try-catch 语句捕获异常</li>
<li>onerror 事件捕获异常</li>
</ul>
<h2 id="一、try-catch-语句"><a href="#一、try-catch-语句" class="headerlink" title="一、try-catch 语句"></a>一、try-catch 语句</h2><span id="more"></span>

<p>try-catch 语句是 Javascript 中处理异常的一种标准方式，基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会导致错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 在错误发生时处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 catch 捕获的异常对象 error，在不同浏览器中它包含的信息可能不太一样。一般来说，error 中通用的属性仅包括 message，也就是说，在跨浏览器编写代码时，最好只使用 message 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会导致错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 跨浏览器的通用属性仅有 message</span></span><br><span class="line">    alert(error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，try-catch 语句还包括了 finally 块，用于表示 finally 块内的语句一定会执行。</p>
<p>无论代码怎么处理，下述代码最后返回的结果始终是 finally 块的 0：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 错误处理代码</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外需要注意的是，如果代码中包含了 finally 语句，那么 try 块和 catch 块内的 return 语句都将会被忽略，下述代码返回的既不是 1 也不是 -1,实际返回的是 finally 的代码结果，但是由于 finally 块内没有 return 语句，因此会默认返回 <code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 错误处理代码</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="comment">// 实际上这里会返回 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此在使用 finally 块时，需要注意它的返回值。</p>
<p>还有一点需要说的就是，IE7 以前的版本有一个 bug，如果没有 catch 语句，finally 也不会执行。因此在写 IE7 以前版本的代码时，使用 finally 语句时必须要先写 catch 语句。</p>
<h3 id="1-1-错误类型"><a href="#1-1-错误类型" class="headerlink" title="1.1 错误类型"></a>1.1 错误类型</h3><p>ECMA-262 定义了7种错误类型：</p>
<ul>
<li>Error</li>
<li>EvalError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<h4 id="1-1-1-Error"><a href="#1-1-1-Error" class="headerlink" title="1.1.1 Error"></a>1.1.1 Error</h4><p><code>Error</code> 是基类型，其他错误类型均继承自该类型。</p>
<h4 id="1-1-2-EvalError"><a href="#1-1-2-EvalError" class="headerlink" title="1.1.2 EvalError"></a>1.1.2 EvalError</h4><p><code>EvalError</code> 会在使用 <code>eval()</code> 函数时发生异常而被抛出，比如如果没有把 eval 当作函数来调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些会抛出异常</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">eval</span>();</span><br><span class="line"><span class="built_in">eval</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-RangeError"><a href="#1-1-3-RangeError" class="headerlink" title="1.1.3 RangeError"></a>1.1.3 RangeError</h4><p><code>RangeError</code> 会在数值超出相应范围时触发。比如数组的大小超出了范围：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非法范围会抛出异常</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(-<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Number</span>.MAX_VALUE);</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-ReferenceError"><a href="#1-1-4-ReferenceError" class="headerlink" title="1.1.4 ReferenceError"></a>1.1.4 ReferenceError</h4><p><code>ReferenceError</code> 会在访问不存在的变量时触发，比如把未声明的变量用来赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// firstname 未定义时会抛出异常</span></span><br><span class="line"><span class="keyword">var</span> name = firstname;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-5-SyntaxError"><a href="#1-1-5-SyntaxError" class="headerlink" title="1.1.5 SyntaxError"></a>1.1.5 SyntaxError</h4><p><code>SyntaxError</code> 一般是因为语法错误引起，比如将语法错误的字符串传进 eval 中执行时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法错误异常</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;a ++ b&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-1-6-TypeError"><a href="#1-1-6-TypeError" class="headerlink" title="1.1.6 TypeError"></a>1.1.6 TypeError</h4><p><code>TypeError</code> 会在变量中保存着意外的类型，或者在访问不存在的方法时触发。比如传给函数的参数类型与预期的类型不相符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-1-7-URIError"><a href="#1-1-7-URIError" class="headerlink" title="1.1.7 URIError"></a>1.1.7 URIError</h4><p><code>URIError</code> 一般会在使用 <code>encodeURI()</code> 或 <code>decodeURI()</code>，而 URI 格式不正确时触发。不过这两个方法的容错率比较高，不容易触发这个错误。</p>
<h3 id="1-2-throw-抛出异常"><a href="#1-2-throw-抛出异常" class="headerlink" title="1.2 throw 抛出异常"></a>1.2 throw 抛出异常</h3><p>与 try-catch 语句相配的还有一个 throw 操作符，用于抛出自定义错误。</p>
<p>使用 throw 抛出错误时，必须指定一个错误值，但是这个错误值的类型没有要求，可以是任意类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">123</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>但是一般来说，抛出 Error 错误类型会更好一些，因为这样会比较方便 catch 处理该异常信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">EvalError</span>(<span class="string">&quot;eval error!&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;type error!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>也可以自定义错误，利用原型链继承 Error 来创建自定义的错误类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomError</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;CustomError&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">&quot;custom error!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="二、onerror-事件"><a href="#二、onerror-事件" class="headerlink" title="二、onerror 事件"></a>二、onerror 事件</h2><p>任何没有通过 try-catch 语句处理的错误都会触发 window 对象的 error 事件（Opera、Safari 浏览器不支持 error 事件）。</p>
<p>在任何 Web 浏览器中，onerror 事件处理程序都不会创建 event 对象，只会接收3个参数：</p>
<ul>
<li>错误信息</li>
<li>错误所在的 URL</li>
<li>错误所在行号</li>
</ul>
<p>只要发生错误，无论是不是浏览器生成的，都会触发 error 事件。</p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON数据格式</title>
    <url>/lang/js/json_data/</url>
    <content><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON 是一种数据格式，不是一种编程语言。一般用于Web服务的前后端的数据交流格式。</p>
<h2 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h2><p>JSON 的语法可以有3种类型的值：</p>
<ul>
<li>简单值：包括字符串、数值、布尔值和 null（但是不支持 Javascript 中的 undefined）</li>
<li>对象：表示一组无序的键值对</li>
<li>数组：表示一组有序的值的列表</li>
</ul>
<h2 id="二、与-Jsvacript-的区别"><a href="#二、与-Jsvacript-的区别" class="headerlink" title="二、与 Jsvacript 的区别"></a>二、与 Jsvacript 的区别</h2><span id="more"></span>

<ul>
<li>Javascript 是一种编程语言，JSON只是一种数据格式</li>
<li>JSON 没有变量声明，也没有末尾的分号<code>;</code></li>
<li>JSON 字符串必须使用双引号（单引号会导致语法错误）</li>
</ul>
<p>Javascript 的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>，</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON 的语法：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Zhangsan&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、解析与序列化"><a href="#三、解析与序列化" class="headerlink" title="三、解析与序列化"></a>三、解析与序列化</h2><p>JSON 数据是 Web 服务中数据交换的格式，因此它可以与 Javascript 对象相互转换。</p>
<p>早期的浏览器，一般使用 <code>eval()</code> 函数来解析、解释 JSON 字符串并返回 Javascript 对象或数组。</p>
<p>ECMAScript 5 对解析 JSON 的行为进行来规范，定义了全局对象 JSON。</p>
<p>JSON 对象有两个方法：<code>stringify()</code> 和 <code>parse()</code>。其中 <code>stringify()</code> 用于将 Javascript 对象或数组序列化成 JSON 字符串，<code>parse()</code> 方法用于将 JSON 字符串解析成 avascript 对象或数组。</p>
<h3 id="3-1-序列化"><a href="#3-1-序列化" class="headerlink" title="3.1 序列化"></a>3.1 序列化</h3><p>JSON 序列化负责将 Javascript 对象或数组序列化成 JSON 字符串，实现这个功能的方法是 <code>JSON.stringify()</code>。</p>
<p><code>stringify</code> 方法的参数有3个：</p>
<ul>
<li>需要序列化的 Javascript 对象</li>
<li>过滤器，可以是数组，也可以是函数</li>
<li>JSON 字符串的缩进值，可以是数值，也可以是字符串</li>
</ul>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Zhangsan&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-1-过滤器"><a href="#3-1-1-过滤器" class="headerlink" title="3.1.1 过滤器"></a>3.1.1 过滤器</h4><p>使用 <code>stringify</code> 的第2个参数，可以自定义过滤序列化的结果。</p>
<p>过滤器参数可以有2种格式：数组和函数。</p>
<p>1）如果过滤器参数是数组，那么 <code>stringify</code> 序列化的结果只会返回包含在数组中的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器是数组</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj, [<span class="string">&#x27;name&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Zhangsan&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>2）如果过滤器参数是函数，该函数会接收2个参数：属性（键）名和属性值。</p>
<p>函数返回值就是对应属性（键）名的值，如果函数返回值是 <code>undefined</code>，那么相应的属性会被忽略：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器是函数</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Zhangsan&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-缩进"><a href="#3-1-2-缩进" class="headerlink" title="3.1.2 缩进"></a>3.1.2 缩进</h4><p>默认情况下，<code>JSON.stringify()</code> 输出的 JSON 字符串是不包含任何空格字符或缩进的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Zhangsan&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>stringify</code> 方法的第3个参数，可以控制序列化结果中的缩进和空白符。</p>
<p>缩进参数可以有2种格式：数值和字符串。</p>
<p>1）如果缩进参数是数值，表示的是每个缩进级别的空格数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj, <span class="literal">null</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为（缩进空格数为4）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Zhangsan&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要传入了有效的缩进参数值，结果字符串也会包含换行符（因为只缩进不换行意义不大）。</p>
<p>最大缩进格数为10，所有大于10的值都会自动转换为10。</p>
<p>2）如果缩进参数是字符串，则这个字符串将会被用作缩进字符（不再使用空格）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj, <span class="literal">null</span>, <span class="string">&#x27;----&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为（缩进字符不再是空格）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">----<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Zhangsan&quot;</span>,</span><br><span class="line">----<span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩进字符最大长度也不能超过10，如果字符长度超过了10，就会被截取成10个字符。</p>
<h4 id="3-1-3-toJSON"><a href="#3-1-3-toJSON" class="headerlink" title="3.1.3 toJSON"></a>3.1.3 toJSON</h4><p>有时候，<code>JSON.stringify()</code> 还不能满足自定义序列化的需求，因此可以给对象定义 <code>toJSON</code> 方法，返回自定义的 JSON 数据格式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">toJSON</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;sex&quot;</span>: <span class="string">&quot;female&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为（缩进字符不再是空格）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;sex&quot;</span>: <span class="string">&quot;female&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-4-序列化顺序"><a href="#3-1-4-序列化顺序" class="headerlink" title="3.1.4 序列化顺序"></a>3.1.4 序列化顺序</h4><ol>
<li>如果存在 <code>toJSON</code> 方法，返回该方法的返回值，否则，返回对象本身</li>
<li>如果提供了第2个参数，对第1步返回的值进行过滤</li>
<li>对第2步返回的每个值进行序列化</li>
<li>如果提供了第3个参数，执行相应的格式化</li>
</ol>
<h3 id="3-2-解析"><a href="#3-2-解析" class="headerlink" title="3.2 解析"></a>3.2 解析</h3><p>JSON 解析负责将 JSON 字符串解析成 Javascript 对象，实现这个功能的方法是 <code>JSON.parse()</code>。</p>
<p><code>parse</code> 方法的参数有2个：</p>
<ul>
<li>需要解析的 JSON 字符串</li>
<li>还原函数，和过滤器函数类似</li>
</ul>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;Zhangsan&quot;,&quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 数据解析</span></span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(jsonText);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonObj</code> 的值为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Zhangsan&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-还原函数"><a href="#3-2-1-还原函数" class="headerlink" title="3.2.1 还原函数"></a>3.2.1 还原函数</h4><p>还原函数和过滤器函数类似，也是接收2个参数：属性（键）名和属性值。</p>
<p>还原函数的返回值将作为属性（键）名的值，如果函数返回 <code>undefined</code>，表示从结果中删除相应的键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;Zhangsan&quot;,&quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 数据解析，增加还原函数</span></span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonObj</code> 的值为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Zhangsan&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML中的DOM对象</title>
    <url>/lang/js/dom/</url>
    <content><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM（文档对象模型）是针对 HTML 和 XML 文档的一个API。</p>
<ul>
<li>主流浏览器都完成了 DOM1 级的实现</li>
<li>IE 的 DOM 对象都是以 COM 对象的形式存在，和原始的 DOM 对象行为并不一致</li>
</ul>
<h2 id="一、节点层次"><a href="#一、节点层次" class="headerlink" title="一、节点层次"></a>一、节点层次</h2><p>DOM 可以将 HTML 或 XML 文档描绘成一个由多层节点构成的结构，简单点说，就是一个树结构。</p>
<span id="more"></span>

<h2 id="1-1-文档节点"><a href="#1-1-文档节点" class="headerlink" title="1.1 文档节点"></a>1.1 文档节点</h2><p>文档节点是每个文档的根节点。</p>
<p>文档节点不直接表现在文档定义中，是一个内置的节点。</p>
<h2 id="1-2-文档元素"><a href="#1-2-文档元素" class="headerlink" title="1.2 文档元素"></a>1.2 文档元素</h2><p>文档元素是文档的最外层元素，文档中的所有其他元素都包含在文档元素中。</p>
<p>每个文档只能有一个文档元素。</p>
<p>在 HTML 页面中，文档元素始终是 <code>&lt;html&gt;</code> 元素。</p>
<h2 id="1-3-节点结构"><a href="#1-3-节点结构" class="headerlink" title="1.3 节点结构"></a>1.3 节点结构</h2><p>以 HTML 文档为例，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- Document</span><br><span class="line">    |-- html</span><br><span class="line">        |-- head</span><br><span class="line">            |-- title</span><br><span class="line">        |-- body</span><br><span class="line">            |-- p</span><br><span class="line">            |-- div</span><br></pre></td></tr></table></figure>

<p>其中，<code>Document</code> 是文档节点，它在 HTML 文档中是没有定义的；<code>html</code> 是文档元素，所有其他的元素都在它里面。</p>
<h2 id="二、节点类型"><a href="#二、节点类型" class="headerlink" title="二、节点类型"></a>二、节点类型</h2><h3 id="2-1-Node-类型"><a href="#2-1-Node-类型" class="headerlink" title="2.1 Node 类型"></a>2.1 Node 类型</h3><p>Node 在 DOM1级定义中，是一个接口，由 DOM 中的所有节点类型实现。</p>
<p>在 JavaScript 中，Node 接口是作为 Node 类型实现的。</p>
<ul>
<li>JavaScript 中的所有节点类型都继承自 Node 类型</li>
<li>每个节点都有一个 nodeType 属性，用于表明节点的类型</li>
<li>除 IE 外，其他浏览器均可以访问 Node 类型（IE 没有公开它的 Node 类型的构造函数）</li>
</ul>
<h4 id="2-1-1-公共属性"><a href="#2-1-1-公共属性" class="headerlink" title="2.1.1 公共属性"></a>2.1.1 公共属性</h4><p><strong>(1) nodeType</strong></p>
<p>每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型总共有12种（括号内的是它的常量值）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Node.ELEMENT_NODE(1)</span><br><span class="line">- Node.ATTRIBUTE_NODE(2)</span><br><span class="line">- Node.TEXT_NODE(3)</span><br><span class="line">- Node.CDATA_SECTION_NODE(4)</span><br><span class="line">- Node.ENTITY_REFERENCE_NODE(5)</span><br><span class="line">- Node.ENTITY_NODE(6)</span><br><span class="line">- Node.PROCESSING_INSTRUCTION_NODE(7)</span><br><span class="line">- Node.COMMENT_NODE(8)</span><br><span class="line">- Node.DOCUMENT_NODE(9)</span><br><span class="line">- Node.DOCUMENT_TYPE_NODE(10)</span><br><span class="line">- Node.DOCUMENT_FRAGMENT_NODE(11)</span><br><span class="line">- Node.NOTATION_NODE(12)</span><br></pre></td></tr></table></figure>

<p>需要说明的是，并不是所有 Web 浏览器都支持全部的节点类型。</p>
<p>由于 IE 无法访问 Node 类型，因此在判断节点类型时，为了确保浏览器兼容性，最好将 nodeType 与数值作比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IE 下无效</span></span><br><span class="line"><span class="keyword">if</span> (node.nodeType === Node.ELEMENT_NODE) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于所有浏览器</span></span><br><span class="line"><span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2) nodeName 和 nodeValue</strong></p>
<p>这两个值取决于节点的类型，有可能取值为 null。</p>
<p>在 <code>Node.ELEMENT_NODE</code> 元素类型中，nodeName 始终保存的是元素的标签名，而 nodeValue 的值则始终是 null。</p>
<p><strong>(3) childNodes</strong></p>
<p>每个节点都有一个 childNodes 属性，用于保存它的子节点。</p>
<p>childNodes 是一个 NodeList 对象，是一种类数组对象（不是数组），其中保存着一组有序的节点。</p>
<p>NodeList 对象是一个动态查询的结果，也就是说，当 DOM 结构发生变化时，它能够实时更新数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 NodeList 对象的长度</span></span><br><span class="line"><span class="keyword">var</span> length = node.childNodes.length</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类似数组的[]下标访问</span></span><br><span class="line"><span class="keyword">var</span> firstChild = node.childNodes[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 item() 方法访问</span></span><br><span class="line"><span class="keyword">var</span> lastChild = node.childNodes.item(length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>需要说明的是，虽然所有节点都继承自 Node 类型，但并不是每种节点都有子节点。</p>
<p><strong>(4) 其他属性</strong></p>
<ul>
<li>parentNode：父节点</li>
<li>previousSibling：同级节点的前一个节点</li>
<li>nextSibling：同级节点的下一个节点</li>
<li>firstChild：第一个子节点</li>
<li>lastChild：最后一个子节点</li>
<li>ownerDocument：节点所在的文档</li>
</ul>
<h4 id="2-1-2-公共方法"><a href="#2-1-2-公共方法" class="headerlink" title="2.1.2 公共方法"></a>2.1.2 公共方法</h4><p><strong>(1) appendChild</strong></p>
<p><code>appendChild()</code> 方法用于向 childNodes 列表末尾追加一个节点。</p>
<p>如果追加的节点已经在 childNodes 中，则会将该节点移动到 childNodes 列表的末尾。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 追加到末尾</span></span><br><span class="line"><span class="keyword">var</span> newNode = parentNode.appendChild(newChildNode)</span><br><span class="line">alert(newNode === parentNode.lastChild)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动到末尾</span></span><br><span class="line"><span class="keyword">var</span> firstChild = parentNode.firstChild</span><br><span class="line"><span class="keyword">var</span> moveNode = parentNode.appendChild(firstChild)</span><br><span class="line">alert(moveNode === parentNode.lastChild)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>(2) insertBefore</strong></p>
<p><code>insertBefore()</code> 方法用于在 childNodes 列表的某个位置中插入一个节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入到末尾</span></span><br><span class="line"><span class="keyword">var</span> newNode = parentNode.insertBefore(newChildNode, <span class="literal">null</span>)</span><br><span class="line">alert(newNode === parentNode.lastChild)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入后成为第一个节点</span></span><br><span class="line"><span class="keyword">var</span> insertNode = parentNode.insertBefore(newChildNode, parentNode.firstChild)</span><br><span class="line">alert(insertNode === parentNode.firstChild)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>(3) replaceChild</strong></p>
<p><code>replaceChild()</code> 方法用于将旧节点替换成新节点，实际上是做了一个删除节点操作和插入节点操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换指定的子节点</span></span><br><span class="line"><span class="keyword">var</span> replaceNode = parentNode.replaceChild(newChildNode, parentNode.firstChild)</span><br><span class="line">alert(replaceNode === parentNode.firstChild)</span><br></pre></td></tr></table></figure>

<p><strong>(4) removeChild</strong></p>
<p><code>removeChild()</code> 方法用于移除子节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> removeNode = parentNode.removeChild(parentNode.firstChild)</span><br></pre></td></tr></table></figure>

<p><strong>(5) 其他方法</strong></p>
<ul>
<li>cloneNode：用于创建调用节点的副本，<code>cloneNode(true)</code> 为深复制，<code>cloneNode(false)</code> 为浅复制。</li>
<li>normalize：用于处理后代的文本节点，后代中如果存在空的文本节点，则删除它；如果出现相邻的文本节点，则合并它们。</li>
</ul>
<h3 id="2-2-Document-类型"><a href="#2-2-Document-类型" class="headerlink" title="2.2 Document 类型"></a>2.2 Document 类型</h3><p>Document 类型用于表示文档，可以是 HTML 页面或者基于 XML 的文档。</p>
<ul>
<li>在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面</li>
<li>document 对象是 window 对象的一个属性，可作全局对象访问</li>
</ul>
<p>具有的特征包括：</p>
<ul>
<li>nodeName 的值为 <code>#document</code></li>
<li>nodeValue 的值为 <code>null</code></li>
<li>parentNode 的值为 <code>null</code></li>
<li>ownerDocument 的值为 <code>null</code></li>
</ul>
<p><strong>(1) 文档子节点</strong></p>
<p>DOM 标准规定 Documnet 节点的子节点可以是：</p>
<ul>
<li>DocumentType（最多一个）</li>
<li>Element（最多一个）</li>
<li>ProcessingInstruction</li>
<li>Comment</li>
</ul>
<p>document 对象拥有两个内置的访问其子节点的快捷方式，一个是 <code>documentElement</code>，另一个是 <code>body</code>。</p>
<ul>
<li><code>document.documentElement</code> 可以直接访问文档的 <code>&lt;html&gt;</code> 元素（因为文档最多只会有一个 Element 元素）</li>
<li>作为 HTMLDocument 的实例，<code>document.body</code> 还可以直接访问文档的 <code>&lt;body&gt;</code> 元素</li>
</ul>
<p>其他子节点属性：</p>
<ul>
<li>DocumentType：<code>document.doctype</code> 用来表示文档类型子节点，但是由于浏览器对 <code>document.doctype</code> 的支持不一致，因此这个属性的用处不大</li>
<li>Comment：理论上出现在 <code>&lt;html&gt;</code> 外面的注释，都属于 document 的子节点，但是不同浏览器对于这种注释的处理也存在差异，因此文档注释的意义也不大</li>
</ul>
<p><strong>(2) 文档信息</strong></p>
<ul>
<li>title：<code>document.title</code> 表示文档标题元素 <code>&lt;title&gt;</code> ，修改 <code>document.title</code> 的值会直接改变 <code>&lt;title&gt;</code> 元素。</li>
<li>URL：<code>document.URL</code> 表示当前页面的完整 URL（即地址栏显示的 URL）</li>
<li>domain：<code>document.domain</code> 表示页面的域名，与 URL 相关联</li>
<li>referer：<code>document.refreer</code> 表示来源页面的 URL（即跳转到当前页面的上一个页面 URL）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改页面标题</span></span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">&#x27;新标题&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.baidu.com/</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL</span><br><span class="line"></span><br><span class="line"><span class="comment">// www.baidu.com</span></span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">document</span>.domain</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.google.com/</span></span><br><span class="line"><span class="keyword">var</span> referer = <span class="built_in">document</span>.refreer</span><br></pre></td></tr></table></figure>

<p>在 URL、domain、referer 中，只有 domain 可以修改，其他两个都是只读属性。</p>
<ul>
<li>domain 只能设置成 URL 的子域名，不能修改为 URL 中不包含的域</li>
<li>修改为子域名之后，不能再修改回原域名（即修改只能收缩，不能扩张）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://www.baidu.com/</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL</span><br><span class="line"></span><br><span class="line"><span class="comment">// www.baidu.com</span></span><br><span class="line"><span class="keyword">var</span> domain  = <span class="built_in">document</span>.domain</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以从父域名修改为子域名</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;baidu.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以修改为 URL 不包含的域名</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;google.com&#x27;</span> <span class="comment">// 出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改为子域名以后，不可以再修改回原域名</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;www.baidu.com&#x27;</span> <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>

<p>domain 的限制来源于跨域安全：<strong>来自不同子域的页面不能通过 Javascript 通信</strong>。也就是说，如果一个页面包含了一个内嵌框架，而且内嵌框架的域名和页面的域名不同，那它们之间就不能互相访问对方的 Javascript 对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 假设当前页面来自 http://wwww.baidu.com/outer.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;http://www.google.com/inner.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;innerFrame&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 由于页面和内置框架不同域名，因此会受到跨域安全的限制</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 导致在这里无法正常访问内嵌框架的 Javascript 对象</span></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要通过 Javascript 实现跨域访问，可以使用 <code>window.postMessage() </code> 方法。</p>
<p><strong>(3) 特征检测</strong></p>
<p>由于 DOM 分为多个级别，也包含多个部分，因此在使用某些特征功能之前，需要检测一下浏览器是否实现来该功能。</p>
<p><code>document.implemetation</code> 属性提供了浏览器实现的相应信息和功能，其中 DOM1 级规定了一个方法 <code>hasFeature()</code> 用于检测 DOM 功能以及版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasXmlDom = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">&#x27;XML&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>hasFeature()</code> 方法判断可能存在错误，因为功能是由浏览器负责实现的，但它未必完全按照 DOM 规范来实现，因此即使是在 <code>hasFeature()</code> 返回 true情况下，也未必能正确使用该功能，所以除了使用 <code>hasFeature()</code> 以外，应该还要加上能力检测。</p>
<p><strong>(4) 查找元素</strong></p>
<p>Document 类型查找元素的方法有，搜索的范围是整个文档：</p>
<ul>
<li>getElementById：通过元素的 ID 获取，区分大小写。如果文档中有多个相同 ID 的元素，则返回第一次出现的元素</li>
<li>getElementsByTagName：通过元素的标签名获取，返回的是包含0个或多个元素的 NodeList</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照 ID 获取</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;divId&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照标签获取</span></span><br><span class="line"><span class="keyword">var</span> images = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有元素</span></span><br><span class="line"><span class="keyword">var</span> allElements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>另外，<strong>对于 HTMLDocument 类型而言</strong>，还有另外的方法：</p>
<ul>
<li>getElementsByName：通过元素的name特性获取，返回的是包含0个或多个元素的 NodeList</li>
</ul>
<p><code>getElementsByName()</code> 方法常用在获取同一组单选按钮的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照name属性获取</span></span><br><span class="line"><span class="keyword">var</span> radios = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;radioName&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>另外，文档为常用的元素提供了快捷方式，可以免去我们自己查找：</p>
<ul>
<li><code>document.anchors</code>：文档中所有带有 name 特性的 <code>&lt;a&gt;</code> 元素</li>
<li><code>document.links</code>：文档中所有带有 href 特性的 <code>&lt;a&gt;</code> 元素</li>
<li><code>document.applets</code>：文档中所有的 <code>&lt;applet&gt;</code> 元素（不建议使用）</li>
<li><code>document.forms</code>：文档中所有的 <code>&lt;form&gt;</code> 元素</li>
<li><code>document.images</code>：文档中所有的 <code>&lt;img&gt;</code> 元素</li>
</ul>
<p><strong>(5) 文档写入</strong></p>
<p>document 对象可以直接将输出流写入网页中，主要的方法有几个：</p>
<ul>
<li>write：写入字符串</li>
<li>writeln：写入字符串，并在末尾添加一个换行符（<code>\n</code>）</li>
<li>open：打开输出流</li>
<li>close：关闭输出流</li>
</ul>
<p>需要注意的是，在<strong>文档加载期间</strong>使用 <code>write()</code> 和 <code>writeln()</code> 是不需要使用 <code>open()</code> 和 <code>close()</code> 方法的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 处于文档加载期间，不需要使用 open() 和 close() 方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">&#x27;Hello world!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;btnClick()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">btnClick</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 文档加载完毕，需要使用 open() 和 close() 方法</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.open();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">&#x27;Hello world!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.close();</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-Element-类型"><a href="#2-3-Element-类型" class="headerlink" title="2.3 Element 类型"></a>2.3 Element 类型</h3><p>元素 Element 类型用于表示 XML 或 HTML 元素，具有的特征包括：</p>
<ul>
<li>nodeType 的值为 1</li>
<li>nodeName 的值为元素的标签名</li>
<li>nodeValue 的值为 null</li>
<li>parentNode 可能是 Document 或 Element</li>
</ul>
<p>访问元素的标签名可以使用 nodeName 或 tagName，在 Element 类型中这两个是相等的。</p>
<ul>
<li>在 HTMl 中，标签名始终是全部大写表示</li>
<li>在 XML 中，标签名则始终和源代码中保持一致</li>
</ul>
<p>因此在判断标签名时，最好转换一下大小写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.tagName.toUpperCase() === <span class="string">&#x27;DIV&#x27;</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(1) HTML 元素</strong></p>
<p>所有 HTML 元素都由 HTMLElement 类型表示，而 HTMLElement 继承自 Element，并添加了一些属性：</p>
<ul>
<li>id：元素的唯一标识符</li>
<li>title：元素的附加说明信息，一般用于工具提示条显示</li>
<li>lang：元素内容的语言代码，少用</li>
<li>dir：语言的方向，少用</li>
<li>className：元素的 class 特征，即元素的 CSS 类（class 是 ECMAScript 保留字，所以用 className 表示）</li>
</ul>
<p><strong>(2) 元素特性</strong></p>
<p>特性是用于给出元素及其内容的附加信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id、class、title、align、data-custom-attr 等称为元素特性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my-cls&quot;</span> <span class="attr">title</span>=<span class="string">&quot;my-title&quot;</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span> <span class="attr">data-custom-attr</span>=<span class="string">&quot;custom attribution&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>操作特性的 DOM 方法有几个：</p>
<ul>
<li>getAttribute：获取特性</li>
<li>setAttribute：设置特性</li>
<li>removeAttribute：删除特性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置特性</span></span><br><span class="line">myDiv.setAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;new_id&#x27;</span>)</span><br><span class="line">myDiv.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;new-my-cls&#x27;</span>)</span><br><span class="line">myDiv.setAttribute(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;New title&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取特性</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;id&#x27;</span>))    <span class="comment">// &quot;new_id&quot;</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;class&#x27;</span>)) <span class="comment">// &quot;new-my-cls&quot;</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;title&#x27;</span>)) <span class="comment">// &quot;New title&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除特性</span></span><br><span class="line">myDiv.removeAttribute(<span class="string">&#x27;class&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>(3) 元素属性</strong></p>
<p>通过元素属性还可以访问元素特性，元素特性与元素属性的关系如下：</p>
<ul>
<li>元素的特性可以通过 DOM 元素对象的属性访问</li>
<li>只有公认的（非自定义的）特性才会以属性的形式添加到 DOM 对象中（如 id、title 等）</li>
<li>通过属性获取得到的特性是经过解析的，是一个对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// element.id、element.className、element.title 等称为元素属性</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line">alert(myDiv.id)                  <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line">alert(myDiv.className)           <span class="comment">// &quot;my-cls&quot;（class 是保留字的原因）</span></span><br><span class="line">alert(myDiv.title)               <span class="comment">// &quot;my-title&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义特性不会以属性的形式直接显示</span></span><br><span class="line">alert(myDiv[<span class="string">&#x27;data-custom-attr&#x27;</span>])              <span class="comment">// undefined（IE除外）</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;data-custom-attr&#x27;</span>)) <span class="comment">// &quot;custom attribution&quot;</span></span><br></pre></td></tr></table></figure>

<p>有两类特性，它们虽然有对应属性名，但是属性值和通过 <code>getAttribute()</code> 拿到的特性值不同，<strong>属性值是经过解析的对象，而特性值是未经解析的字符串</strong>。这两类特性分别是样式 style，事件处理程序（onclick 等）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:100px;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会直接得到原始的字符串</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;style&#x27;</span>))   <span class="comment">// &quot;height:100px;&quot;</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;onclick&#x27;</span>)) <span class="comment">// &quot;btnClick&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会得到解析过的对象/方法</span></span><br><span class="line">alert(myDiv.style)   <span class="comment">// object</span></span><br><span class="line">alert(myDiv.onclick) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>另外，Element 类型还有一个属性 <code>attributes</code> 用于保存元素所有的元素特性。<code>element.attributes</code> 属性包含一个 NamedNodeMap，是一个“动态”的集合，能够动态实时获取元素的所有特征。</p>
<p><strong>(4) 创建元素</strong></p>
<p>使用 <code>document.createElement()</code> 可以创建新元素，创建的同时，也为新元素设置了 <code>ownerDocument</code> 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var newDiv = document.createElement(&#x27;div&#x27;)</span><br><span class="line"></span><br><span class="line">// 新元素需要添加到文档树中，才会在页面上显示</span><br><span class="line">document.body.appendChild(newDiv)</span><br></pre></td></tr></table></figure>

<p><strong>(5) 查找元素</strong></p>
<p>元素支持 <code>getElementsByTagName()</code> 方法，搜索起点为当前元素，范围是当前元素的子元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找指定元素下面的图片</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> images = myDiv.getElementsByTagName(<span class="string">&#x27;img&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Text-类型"><a href="#2-4-Text-类型" class="headerlink" title="2.4 Text 类型"></a>2.4 Text 类型</h3><p>文本节点由 Text 类型表示，包含的是纯文本内容，不能包含 HTML 代码，具有的特征：</p>
<ul>
<li>nodeType 的值为 3</li>
<li>nodeName 的值为 “#text”</li>
<li>nodeValue 的值为节点所包含的文本</li>
<li>parentNode 是一个 Element</li>
<li>不支持（没有）子节点</li>
</ul>
<p>文本节点的文本可以通过 nodeValue 或 data 属性获取，它们是相同的。</p>
<ul>
<li>默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在</li>
<li>修改文本时，字符串会经过 HTML （或 XML）编码（例如大于号、小于号等被转义成其他字符串）</li>
<li>如果两个文本节点是相邻的同胞节点，那它们的文本就会连起来显示，并且不会存在任何空格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示结果是 &quot;&amp;lt;p&amp;gt;New text content&amp;lt;/p&amp;gt;&quot;</span></span><br><span class="line">textNode.nodeValue = <span class="string">&quot;&lt;p&gt;New text content&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>(1) 创建文本节点</strong></p>
<p>创建文本节点使用 <code>document.createTextNode()</code> 方法，方法接收文本作为参数，创建节点的同时，也会设置节点的 <code>ownerDocument</code> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，和设值一样，创建时的参数文本也会经过 HTML （或 XML）编码。</p>
<p>默认情况下，元素只有一个文本节点，但是通过 Javascript 可以为元素创建多个文本子节点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newTextNode1 = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> newTextNode2 = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27; world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">myDiv.appendChild(newTextNode1)</span><br><span class="line">myDiv.appendChild(newTextNode2)</span><br></pre></td></tr></table></figure>

<p><strong>(2) 规范化文本</strong></p>
<p>前面说过，如果两个节点是相邻的同胞节点，它们的文本会连起来显示，但是这样会导致分不清哪个字符串是哪个文本节点的，因此为了合并相邻的同胞文本节点，DOM 提供了一个方法 <code>normalize()</code>，用于合并相邻的文本节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newTextNode1 = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> newTextNode2 = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27; world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">myDiv.appendChild(newTextNode1)</span><br><span class="line">myDiv.appendChild(newTextNode2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并同胞文本节点</span></span><br><span class="line">myDiv.normalize()</span><br></pre></td></tr></table></figure>

<p><strong>(3) 分割文本</strong></p>
<p>Text类型除了可以合并以外，还可以进行分割：<code>splitText()</code>。这个方法会将1个文本节点分割成2个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello world!&#x27;</span>)</span><br><span class="line">myDiv.appendChild(newTextNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> splitNode = myDiv.firstChild.splitText(<span class="number">5</span>)</span><br><span class="line">alert(myDiv.firstChild.nodeValue) <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">alert(splitNode.nodeValue)        <span class="comment">// &quot; world!&quot;</span></span><br><span class="line">alert(myDiv.childNodes.length)    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-Comment-类型"><a href="#2-5-Comment-类型" class="headerlink" title="2.5 Comment 类型"></a>2.5 Comment 类型</h3><p>Comment 类型用于表示注释，与 Text 类型类似，具有特征如下：</p>
<ul>
<li>nodeType 的值为 8</li>
<li>nodeName 的值为 “#comment”</li>
<li>nodeValue 的值是注释的内容</li>
<li>不支持（没有）子节点</li>
</ul>
<p>Comment 类型和 Text 类型继承自相同的基类，因此拥有除了 <code>splitText()</code> 方法以外的所有字符串操作方法。</p>
<p>创建注释节点可以通过使用 <code>document.createComment()</code>，参数是注释内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">&#x27;new comment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-6-CDATASection-类型"><a href="#2-6-CDATASection-类型" class="headerlink" title="2.6 CDATASection 类型"></a>2.6 CDATASection 类型</h3><p>CDATASection 类型只针对基于 XML 的文档，表示的是 CDATA 区域。具有的特征如下：</p>
<ul>
<li>nodeType 的值为4</li>
<li>nodeName 的值为 “#cdata-section”</li>
<li>nodeValue 的值是 CDATA 区域的内容</li>
<li>不支持（没有）子节点</li>
</ul>
<p>与 Comment 类型类似，CDATASection 类型继承自 Text 类型，因此拥有除了 <code>splitText()</code> 方法以外的所有字符串操作方法。</p>
<p>CDATA 区域只会出现在 XML 文档中，因此浏览器一般会把 CDATA 区域错误解析为 Comment 或 Element。</p>
<p>在 XML 文档中创建 CDATA 区域，可以使用 <code>document.createCDATASection()</code> 方法，参数是区域的内容。</p>
<h3 id="2-7-DocumentType-类型"><a href="#2-7-DocumentType-类型" class="headerlink" title="2.7 DocumentType 类型"></a>2.7 DocumentType 类型</h3><p>DocumentType 类型包含着与文档的 doctype 有关的所有信息。具有的特征包括：</p>
<ul>
<li>nodeType 的值为 10</li>
<li>nodeName 的值为 doctype 的名称</li>
<li>nodeValue 的值为 null</li>
<li>parentNode 为 Document</li>
<li>不支持（没有）子节点</li>
</ul>
<p>在 DOM1 级中，DocumentType 对象不能动态创建，只能通过文档解析的方式创建。支持 DocumentType 的浏览器会将生成的 DoocumentType 对象保存在 <code>document.doctype</code> 中。</p>
<h3 id="2-8-DocumentFragment-类型"><a href="#2-8-DocumentFragment-类型" class="headerlink" title="2.8 DocumentFragment 类型"></a>2.8 DocumentFragment 类型</h3><p>DocumentFragment 类型表示文档片段，是一种“轻量级”的文档，可以包含和控制部分节点，但是不像完整文档那样占用额外的资源。在所有的节点类型中，只有 DocumentFragment 类型在文档中没有对应的标记。具有的特征包括：</p>
<ul>
<li>nodeType 的值为 11</li>
<li>nodeName 的值为 “#document-fragment”</li>
<li>nodeValue 的值为 null</li>
<li>parentNode 的值为 null</li>
</ul>
<p>文档片段不能直接添加到文档中，但是可以把文档片段中的节点添加到文档中。因此文档片段相当于一个节点临时仓库，可以将临时生成的节点保存在文档片段中，最后再将生成的节点都添加到文档中。</p>
<p>创建文档片段可以使用 <code>document.createDocumentFragment()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br></pre></td></tr></table></figure>

<ul>
<li>如果将文档中的节点添加到文档片段中，该节点就会从文档树中移除（也就是浏览器看不到了）</li>
<li>将文档片段的子节点添加到文档中，节点会从文档片段中移除，但是文档片段不会添加到文档树上</li>
<li>文档片段有类似于缓存的作用，可以用于避免浏览器反复渲染新信息</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul <span class="built_in">document</span>.createElement(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以暂时保存到文档片段中，避免浏览器多次渲染新节点</span></span><br><span class="line"><span class="keyword">var</span> li = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">  fragment.appendChild(li)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul.appendChild(fragment)</span><br></pre></td></tr></table></figure>

<h3 id="2-9-Attr-类型"><a href="#2-9-Attr-类型" class="headerlink" title="2.9 Attr 类型"></a>2.9 Attr 类型</h3><p>元素的特性在 DOM 中以 Attr 类型来表示。在所有浏览器中，都可以访问 Attr 类型的构造器和原型。从技术角度讲，特性就是存在于元素的 <code>attributes</code> 属性中的节点。具有的特征包括：</p>
<ul>
<li>ndoeType 的值为 2</li>
<li>nodeName 的值就是特性的名称</li>
<li>nodeValue 的值是特性的值</li>
<li>parentNode 的值为 null</li>
<li>在 HTML 中不支持（没有）子节点</li>
<li>在 XML 中可以有 Text 或者 EntityReference 子节点</li>
</ul>
<p>创建 Attr 节点可以使用 <code>document.createAttribute()</code> 方法，Attr 节点创建完成后，还需要使用 <code>setAttribute()</code> 方法来将属性值设到元素中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">&#x27;align&#x27;</span>)</span><br><span class="line">attr.value = <span class="string">&#x27;left&#x27;</span></span><br><span class="line"></span><br><span class="line">myDiv.setAttribute(attr)</span><br></pre></td></tr></table></figure>

<p>但是在开发中，直接使用 <code>setAttribute()</code> 方法会更加直接一些：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line">myDiv.setAttribute(<span class="string">&#x27;align&#x27;</span>, <span class="string">&#x27;left&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>事件的监听以及处理</title>
    <url>/lang/js/events/</url>
    <content><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件，是文档或浏览器窗口中发生的一些特定的交互瞬间。</p>
<p>下面分别介绍事件中的几个重要特性：</p>
<ul>
<li>事件流</li>
<li>事件处理程序</li>
<li>事件对象</li>
</ul>
<h2 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h2><p>事件流是用于描述页面接收事件的顺序。</p>
<span id="more"></span>

<p>根据事件的捕获顺序不同，事件流分为2种：</p>
<ul>
<li>事件冒泡流</li>
<li>事件捕获流</li>
</ul>
<h3 id="1-1-事件冒泡"><a href="#1-1-事件冒泡" class="headerlink" title="1.1 事件冒泡"></a>1.1 事件冒泡</h3><p>事件冒泡，是指事件由最具体的元素（即最底层的节点）接收，然后逐级向上传播到较为不具体的节点（即最顶层的节点，文档），属于由下向上传播事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果点击了页面中的 div 元素，那么这个 click 事件会按照以下顺序传播：</p>
<ol>
<li><code>&lt;div&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>document</code></li>
</ol>
<p>所有浏览器都支持事件冒泡。</p>
<h3 id="1-2-事件捕获"><a href="#1-2-事件捕获" class="headerlink" title="1.2 事件捕获"></a>1.2 事件捕获</h3><p>事件冒泡，是指事件由较不具体的元素（即最顶层的节点，文档）接收，然后逐级向下传播到最不具体的节点（即最底层的节点），属于由上到下传播事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果点击了页面中的 div 元素，那么这个 click 事件会按照以下顺序传播：</p>
<ol>
<li><code>document</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;div&gt;</code></li>
</ol>
<p>老版本的浏览器不支持事件捕获。</p>
<h3 id="1-3-DOM-事件流"><a href="#1-3-DOM-事件流" class="headerlink" title="1.3 DOM 事件流"></a>1.3 DOM 事件流</h3><p>“DOM2级事件”规定的事件流包括3个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以 div 的点击事件为例，事件流的顺序是：</p>
<ol>
<li><code>document</code>（捕获）</li>
<li><code>&lt;html&gt;</code>（捕获）</li>
<li><code>&lt;body&gt;</code>（捕获）</li>
<li><code>&lt;div&gt;</code>（目标、冒泡）</li>
<li><code>&lt;body&gt;</code>（冒泡）</li>
<li><code>&lt;html&gt;</code>（冒泡）</li>
<li><code>document</code>（冒泡）</li>
</ol>
<p>另外，在 DOM 事件流中，实际目标接收事件的时候不是处于捕获阶段，而是属于冒泡阶段。</p>
<p>也就是说，实际上只分为2个阶段：事件捕获阶段、事件冒泡阶段（包括处于目标阶段）。</p>
<h2 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h2><p>事件是用户或浏览器自身执行的某种动作，而事件处理程序就是响应某个事件的函数。</p>
<p>一般情况下，事件处理程序的名字以<code>on</code>开头，具体形式为<code>“on” + 事件名</code>。</p>
<p>例如 <code>click</code> 事件的事件处理程序就是 <code>onclick</code>，<code>load</code> 事件的事件处理程序就是<code>onload</code>。</p>
<p>为事件指定事件处理程序的方式有几种：</p>
<ul>
<li>HTML事件处理程序</li>
<li>DOM0级事件处理程序</li>
<li>DOM2级事件处理程序</li>
<li>IE事件处理程序</li>
</ul>
<h3 id="2-1-HTML事件处理程序"><a href="#2-1-HTML事件处理程序" class="headerlink" title="2.1 HTML事件处理程序"></a>2.1 HTML事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来执行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;click&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如 div 的<code>click</code>事件就可以用<code>onclick</code>来指定事件处理程序。</p>
<p>以这种方式来指定事件处理程序，有一些特别的性质：</p>
<ul>
<li>会创建一个封装着元素属性值的函数；</li>
<li>事件处理程序的<code>this</code>值等于当前事件的目标元素；</li>
<li>事件处理函数中有一个局部变量事件对象<code>event</code>，不需要自己定义，也不需要从函数的参数列表获取。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(event.type) <span class="comment">// </span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">value</span>=<span class="string">&quot;Click&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(this.value)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- event 属性不需要定义，也不需要从参数列表中拿 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;handleClick(event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样指定事件处理程序实际上会创建一个函数来执行指定的事件代码，差不多类似于以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  handleClick(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种指定的方式也有一些缺点：</p>
<ul>
<li>存在时差问题。由于事件处理程序是直接绑定在HTML元素上面的，因此有可能在HTML元素渲染时就触发了事件处理程序，但是当时的事件处理程序有可能还不具备执行条件，从而导致执行出现异常；</li>
<li>在不同的浏览器中，事件处理程序的作用域链有可能存在一些差异，从而导致不同的结果；</li>
<li>HTML与Javascript代码紧密耦合，不方便后续的维护。</li>
</ul>
<h3 id="2-2-DOM0-级事件处理程序"><a href="#2-2-DOM0-级事件处理程序" class="headerlink" title="2.2 DOM0 级事件处理程序"></a>2.2 DOM0 级事件处理程序</h3><p>由于用 HTML 来指定事件处理程序，会使得 HTML 代码和 Javascript 代码耦合，并且不好维护。</p>
<p>因此为了处理这种情况，可以只使用 Javascript 来指定事件处理程序，这样不仅简单，在跨浏览器上兼容也比较容易。</p>
<p>每个 DOM 元素（包括 window 和 document）都有自己的事件处理程序属性，通常都是全部小写，例如 <code>onclick</code>。把事件处理程序属性设置为一个函数，就可以指定事件处理程序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式称为 DOM0 级方法指定事件处理程序。</p>
<p>这种方式有几个特点：</p>
<ul>
<li>事件处理程序中的 <code>this</code> 表示当前元素；</li>
<li>事件处理程序会在事件流的冒泡阶段被处理。</li>
</ul>
<p>删除 DOM0 级方法指定的事件处理程序也很简单，直接赋值为 <code>null</code> 就可以了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除事件处理程序</span></span><br><span class="line">btn.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-DOM2-级事件处理程序"><a href="#2-3-DOM2-级事件处理程序" class="headerlink" title="2.3 DOM2 级事件处理程序"></a>2.3 DOM2 级事件处理程序</h3><p>DOM0 级方式指定事件处理程序时，只能指定一个事件处理程序，当需要多个处理程序对同一个对象的同一个事件进行处理时，没有办法做到。</p>
<p>因此在 DOM2 级中，添加了2个方法，用于处理指定和删除事件处理程序的操作：</p>
<ul>
<li>addEventListener()</li>
<li>removeEventListener()</li>
</ul>
<p>所有 DOM 节点都包含这2个方法，这2个方法都接收3个参数：</p>
<ul>
<li>要处理的事件名，比如 <code>onclick</code></li>
<li>指定的事件处理函数</li>
<li>一个布尔值，true 表示在捕获阶段调用事件处理函数，false 表示在冒泡阶段调用事件处理函数。</li>
</ul>
<p>以这种方式来指定事件处理程序，有几个特点：</p>
<ul>
<li>可以添加多个事件处理程序；</li>
<li>事件处理函数中的 <code>this</code> 表示当前元素；</li>
<li>移除事件处理程序时，必现传入和添加处理程序时使用的参数相同。也就是说，如果添加的事件处理程序是匿名函数，将无法对它进行移除。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加匿名函数，意味着无法移除</span></span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以添加多个事件处理程序，按添加顺序执行</span></span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件处理时，传入的参数必须和添加时相同</span></span><br><span class="line">btn.removeEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-IE-事件处理程序"><a href="#2-4-IE-事件处理程序" class="headerlink" title="2.4 IE 事件处理程序"></a>2.4 IE 事件处理程序</h3><p>和 DOM 中不同的是，IE 并没有实现 <code>addEventListener</code> 和 <code>removeEventListener</code>，而是另外实现了和这2个方法功能相近的方法：</p>
<ul>
<li>attachEvent()</li>
<li>detachEvent()</li>
</ul>
<p>IE 的事件处理和 DOM2 的事件处理有几点区别：</p>
<ul>
<li>IE8 以前只支持事件冒泡，所以 <code>attachEvent</code> 添加的事件处理只能在冒泡阶段被执行；</li>
<li><code>attachEvent</code> 的事件参数是 <code>onclick</code>，而 <code>addEventListener</code> 的事件参数是 <code>click</code>，没有加上 <code>on</code>；</li>
<li><code>attachEvent</code> 的事件处理函数的作用域是全局作用域，而 <code>addEventListener</code> 的则是所属元素的作用域；</li>
<li><code>attachEvent</code> 添加的事件处理程序是按添加顺序反序执行的，而 <code>addEventListener</code> 是按添加顺序执行的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里是 onclick，而不是 DOM 的 click</span></span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在全局作用域下运行</span></span><br><span class="line">  alert(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">&#125;); <span class="comment">// 没有第3个参数，事件处理只会在冒泡阶段执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以添加多个事件处理程序，按添加顺序反序执行</span></span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件处理时，传入的参数必须和添加时相同</span></span><br><span class="line">btn.detachEvent(<span class="string">&quot;onclick&quot;</span>, handler);</span><br></pre></td></tr></table></figure>

<p>ps：需要特别注意的就是，使用<code>attachEvent</code>绑定的事件处理程序的作用域比较特殊，它的<code>this</code>并不是代表当前所属元素。</p>
<h3 id="2-5-跨浏览器事件处理程序"><a href="#2-5-跨浏览器事件处理程序" class="headerlink" title="2.5 跨浏览器事件处理程序"></a>2.5 跨浏览器事件处理程序</h3><p>针对不同的浏览器，可以写出跨浏览器的方式处理事件。</p>
<p>跨浏览器事件处理只需要处理冒泡阶段，因为有些浏览器版本是不支持捕获事件的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="attr">addHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">removeHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h2><p>在触发 DOM 上的某个事件时，都会产生一个事件对象 event，这个对象包含着所有与事件有关的信息。</p>
<p>事件对象包括导致事件的元素、事件类型以及其他相关信息。</p>
<p>所有浏览器都支持事件对象，但是不同浏览器有不同的实现。</p>
<p>针对不同的浏览器，事件对象 event 也有不同的实现：</p>
<ul>
<li>DOM 中的事件对象</li>
<li>IE 中的事件对象</li>
</ul>
<h3 id="3-1-DOM-中的事件对象"><a href="#3-1-DOM-中的事件对象" class="headerlink" title="3.1 DOM 中的事件对象"></a>3.1 DOM 中的事件对象</h3><p>对于不同的绑定事件处理程序的方式，获取事件对象的方式也不一样。</p>
<p>1）HTML 事件处理程序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(event.type)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 HTML 指定事件程序这种方法中，事件对象 event 是保存在变量 event 中的，可以直接拿到。 </p>
<p>2）DOM0/DOM2 级事件处理程序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准 DOM0 级</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准 DOM2 级</span></span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>对于 DOM2/DOM2 级指定事件处理程序的方式，event 对象可以直接在事件处理程序的参数中获取。</p>
<p>DOM 中的事件对象有一些特殊的属性和方法：</p>
<table>
<thead>
<tr>
<th align="left">属性/方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bubbles</td>
<td align="left">表明事件是否可以冒泡</td>
</tr>
<tr>
<td align="left">cancelable</td>
<td align="left">表明是否可以取消事件的默认行为</td>
</tr>
<tr>
<td align="left">currentTarget</td>
<td align="left">当前事件处理程序绑定的元素</td>
</tr>
<tr>
<td align="left">defaultPrevented</td>
<td align="left">为 true 表示已经调用过 preventDefault() 了</td>
</tr>
<tr>
<td align="left">eventPhase</td>
<td align="left">当前事件流阶段。1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段</td>
</tr>
<tr>
<td align="left">target</td>
<td align="left">触发事件的元素</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">事件类型</td>
</tr>
<tr>
<td align="left">preventDefault()</td>
<td align="left">取消默认的事件行为。只有 cancelable=true 时才能生效</td>
</tr>
<tr>
<td align="left">stopPropagation()</td>
<td align="left">取消事件的进一步捕获或冒泡。只有 bubbles=true 时才能生效</td>
</tr>
<tr>
<td align="left">stopImmediatePropagation()</td>
<td align="left">取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用</td>
</tr>
</tbody></table>
<h4 id="3-1-1-target"><a href="#3-1-1-target" class="headerlink" title="3.1.1 target"></a>3.1.1 target</h4><p>在事件处理程序内部，<code>this</code> 始终等于 <code>currentTarget</code>，而 <code>target</code> 则只是事件的目标对象（即触发事件的元素）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的元素的事件处理</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.currentTarget === <span class="built_in">this</span>); <span class="comment">// true</span></span><br><span class="line">  alert(event.target === <span class="built_in">this</span>);        <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获/冒泡阶段的事件处理</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// currentTarget 执行的是当前事件处理程序的绑定元素</span></span><br><span class="line">  alert(event.currentTarget === <span class="built_in">this</span>);          <span class="comment">// true</span></span><br><span class="line">  alert(event.currentTarget === <span class="built_in">document</span>.body); <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// target 始终指向的是触发事件的元素</span></span><br><span class="line">  alert(event.target === <span class="built_in">this</span>);                 <span class="comment">// false</span></span><br><span class="line">  alert(event.target === btn);                  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-preventDefault"><a href="#3-1-2-preventDefault" class="headerlink" title="3.1.2 preventDefault()"></a>3.1.2 preventDefault()</h4><p>为了阻止事件的默认行为，可以使用 <code>preventDefault()</code> 方法，但是要使用这个方法，必须确保 <code>cancelable=true</code> 才行，否则方法不会生效。</p>
<p>默认行为指的是 dom 元素的默认动作，比如 <code>&lt;a hrtf=&quot;&quot;&gt;</code> 元素的默认行为就是在 <code>click</code> 触发时导航到 href 指定的 URL。使用 <code>preventDefault()</code> 可以阻止其跳转。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myLink&quot;</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-stopPropagation"><a href="#3-1-3-stopPropagation" class="headerlink" title="3.1.3 stopPropagation()"></a>3.1.3 stopPropagation()</h4><p>为了阻止事件继续在事件流里传播，可以使用 <code>stopPropagation()</code> 方法，但是使用这个方法前，要确保 <code>bubbles=true</code> 才行，否则方法不会生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的元素的事件处理</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;btn click&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获/冒泡阶段的事件处理</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;doc click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，由于事件的冒泡，当点击按钮时，会弹出2个警告框。</p>
<p>因此为了避免这种情况，可以使用 <code>stopPropagation()</code> 方法来阻止事件进一步传播：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的元素的事件处理</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;btn click&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 阻止事件继续传播</span></span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获/冒泡阶段的事件处理</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;doc click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，点击按钮时，只会弹出1个警告框。</p>
<p>但是 <code>stopPropagation()</code> 还存在一个问题，它只能阻止事件的冒泡，但是不能阻止同级事件处理程序的执行。前面说过，一个事件可以绑定多个事件处理程序，<code>stopPropagation()</code> 是没有阻止当前目标元素的其他事件处理程序的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;handler1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻止事件继续传播</span></span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> handler2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;handler2&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以添加多个事件处理程序，按添加顺序执行</span></span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler1, <span class="literal">false</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler2, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>这个时候点击按钮，依旧会弹出2个警告框，因为<code>stopPropagation()</code>只是阻止了事件冒泡，但是同级事件处理程序还是会执行的。</p>
<p>所以在 DOM3 中，添加了一个新的方法<code>stopImmediatePropagation()</code>，它可以阻止后续的所有事件处理程序执行，包括同级别的事件处理程序。</p>
<h3 id="3-2-IE-中的事件对象"><a href="#3-2-IE-中的事件对象" class="headerlink" title="3.2 IE 中的事件对象"></a>3.2 IE 中的事件对象</h3><p>IE 中的事件对象获取方式有些不同，它取决于在IE中指定事件处理程序的方法。例如：</p>
<p>在IE中使用DOM0级方法添加事件处理程序时，event 事件对象是作为 window 对象的一个属性存在的；</p>
<p>但是在 IE 中使用 <code>attachEvent()</code> 添加事件处理程序时，event 对象是作为事件处理函数的参数存在的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE 下的 DOM0 级</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE 下的 DOM2 级</span></span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>IE 中的事件对象有一些特殊的属性和方法：</p>
<table>
<thead>
<tr>
<th align="left">属性/方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cancelBubble</td>
<td align="left">用于是否取消事件冒泡，与stopPropagation()作用相同</td>
</tr>
<tr>
<td align="left">returnValue</td>
<td align="left">用于是否取消事件的默认行为，与preventDefault()作用相同</td>
</tr>
<tr>
<td align="left">srcElement</td>
<td align="left">当前事件处理程序绑定的元素，与target属性相同</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">事件类型</td>
</tr>
</tbody></table>
<h4 id="3-2-1-srcElement"><a href="#3-2-1-srcElement" class="headerlink" title="3.2.1 srcElement"></a>3.2.1 srcElement</h4><p>事件处理程序的作用域是由指定它的方式来确定的，因此在写代码时需要特别注意，最好还是使用<code>event.srcElement</code>来替代``this`来作为当前目标对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE 下的 DOM0 级</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  alert(event.srcElement === <span class="built_in">this</span>); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE 下的 DOM2 级</span></span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.srcElement === <span class="built_in">this</span>); <span class="comment">// false</span></span><br><span class="line">  alert(<span class="built_in">window</span> === <span class="built_in">this</span>);           <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-retrunValue"><a href="#3-3-2-retrunValue" class="headerlink" title="3.3.2 retrunValue"></a>3.3.2 retrunValue</h4><p>IE 中取消事件默认行为的方法是使用<code>returnValue=false</code>，与<code>preventDefault()</code>作用相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myLink&quot;</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  event.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和标准 DOM 不同的是，IE 中没有方法确定事件是否可以被取消。</p>
<h4 id="3-2-3-cancelBubble"><a href="#3-2-3-cancelBubble" class="headerlink" title="3.2.3 cancelBubble"></a>3.2.3 cancelBubble</h4><p>IE 中阻止事件冒泡的方法是使用<code>cancelBubble=true</code>，与<code>stopPropagation()</code>作用相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的元素的事件处理</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  alert(<span class="string">&quot;btn click&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 阻止事件继续传播</span></span><br><span class="line">  event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获/冒泡阶段的事件处理</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;doc click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击按钮，只会弹出一个警告框。</p>
<h3 id="3-3-跨浏览器的事件对象"><a href="#3-3-跨浏览器的事件对象" class="headerlink" title="3.3 跨浏览器的事件对象"></a>3.3 跨浏览器的事件对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="attr">addHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">removeHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getEvent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getTarget</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">preventDefault</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">stopPropagation</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>跳表</title>
    <url>/algorithm/skiplist/</url>
    <content><![CDATA[<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><h2 id="一、什么是跳表？"><a href="#一、什么是跳表？" class="headerlink" title="一、什么是跳表？"></a>一、什么是跳表？</h2><p>跳表，又叫做跳跃表、跳跃列表。</p>
<ul>
<li>是一种对有序链式线性表的优化</li>
<li>在原始链表的基础上添加了多级索引链表</li>
<li>分为多层，从下往上分别是原始链表、一级索引、二级索引…</li>
<li>搜索时从上往下，实现了类似“二分查找”的功能</li>
</ul>
<span id="more"></span>

<p>它的结构大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___                                 ___</span><br><span class="line">| 1 | ----------------------------&gt; | 5 |                -- 二级索引</span><br><span class="line">  |                                   |</span><br><span class="line"> ___               ___               ___</span><br><span class="line">| 1 | ----------&gt; | 3 | ----------&gt; | 5 |                -- 一级索引</span><br><span class="line">  |                 |                 |</span><br><span class="line"> ___      ___      ___      ___      ___      ___</span><br><span class="line">| 1 | -&gt; | 2 | -&gt; | 3 | -&gt; | 4 | -&gt; | 5 | -&gt; | 6 |       -- 原始链表</span><br></pre></td></tr></table></figure>

<p>跳表实际上就是对普通有序链表的一种优化，通过添加多级索引来提升性能。</p>
<p>跳表本质上是一种利用空间来换时间的做法。</p>
<h2 id="二、为什么要用跳表？"><a href="#二、为什么要用跳表？" class="headerlink" title="二、为什么要用跳表？"></a>二、为什么要用跳表？</h2><h3 id="2-1-引入背景"><a href="#2-1-引入背景" class="headerlink" title="2.1 引入背景"></a>2.1 引入背景</h3><p>对于链表来说，查找某个值，只能通过遍历的方式实现，时间复杂度是 <code>O(n)</code>。</p>
<p>即使链表是有序的，依旧也只能是从头到尾遍历，完全没有用到数据的有序性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___      ___      ___      ___      ___      ___</span><br><span class="line">| 1 | -&gt; | 2 | -&gt; | 3 | -&gt; | 4 | -&gt; | 5 | -&gt; | 6 |</span><br></pre></td></tr></table></figure>

<p>在这种情况下，有没有办法用到链表的有序性？</p>
<ul>
<li>给链表建立索引，方便快速定位数据的区间范围</li>
</ul>
<p>比如说，链表的每2个节点就提取出一个索引节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___               ___               ___</span><br><span class="line">| 1 | ----------&gt; | 3 | ----------&gt; | 5 |                -- 索引</span><br><span class="line">  |                 |                 |</span><br><span class="line"> ___      ___      ___      ___      ___      ___</span><br><span class="line">| 1 | -&gt; | 2 | -&gt; | 3 | -&gt; | 4 | -&gt; | 5 | -&gt; | 6 |       -- 原始链表</span><br></pre></td></tr></table></figure>

<p>通过索引先快速定位到区间 <code>[1, 3]</code>、<code>[3, 5]</code> 以及 <code>[5, +]</code>，缩小范围，再小范围遍历搜索。</p>
<p>比如说，查找数值 4：</p>
<ol>
<li>首先在索引层遍历判断，发现 4 是在区间 <code>[3, 5]</code> 内的</li>
<li>然后找到了原始链表的 3，再从 3 开始往右遍历，直到找到 4</li>
</ol>
<p>4 的搜索链路就是：<code>1 -&gt; 3 -&gt; 4</code>，这定位速度就比遍历快多了。</p>
<p>有时候建第一层索引后，遍历范围还是很大（第一层索引的节点数量是 n/2）。</p>
<p>这个时候还可以再往上多建几层索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___                                 ___</span><br><span class="line">| 1 | ----------------------------&gt; | 5 |                -- 二级索引</span><br><span class="line">  |                                   |</span><br><span class="line"> ___               ___               ___</span><br><span class="line">| 1 | ----------&gt; | 3 | ----------&gt; | 5 |                -- 一级索引</span><br><span class="line">  |                 |                 |</span><br><span class="line"> ___      ___      ___      ___      ___      ___</span><br><span class="line">| 1 | -&gt; | 2 | -&gt; | 3 | -&gt; | 4 | -&gt; | 5 | -&gt; | 6 |       -- 原始链表</span><br></pre></td></tr></table></figure>

<p>这种在原始链表上建多层索引，实现快速查找的数据结构，就是跳表。</p>
<h3 id="2-2-算法分析"><a href="#2-2-算法分析" class="headerlink" title="2.2 算法分析"></a>2.2 算法分析</h3><p>原始有序链表的算法复杂度是：</p>
<ul>
<li>搜索：时间 <code>O(n)</code>，空间 <code>O(1)</code></li>
<li>删除：时间 <code>O(n)</code>，空间 <code>O(1)</code></li>
<li>插入：时间 <code>O(n)</code>，空间 <code>O(1)</code></li>
</ul>
<p>跳表的算法复杂度如何呢？以 2 个节点 1 个索引的跳表为例。</p>
<p>1）空间复杂度</p>
<p>跳表的多层索引，从下往上数的话，节点数量分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n/2, n/4, n/8, ..., 2</span><br></pre></td></tr></table></figure>

<p>总共是 <code>n/2 + n/4 + ... + 2 = n - 2</code>，也就是说：</p>
<ul>
<li>跳表结构本身的空间复杂度是 <code>O(n)</code></li>
</ul>
<p>2）时间复杂度</p>
<p>根据上面的结构，跳表的层级数量很容易知道：</p>
<ul>
<li>跳表的索引层级数量是 <code>logn</code></li>
</ul>
<p>链表的插入和删除，实际上是依赖于搜索，所以只要分析搜索的时间复杂度即可。</p>
<p>因为每 2 个节点对应 1 个索引节点，所以每一层的搜索节点数量不会超过 3。</p>
<p>比如上一层索引确定了区间 <code>[3, 5]</code>，那么往下一层搜索，搜索只能是 <code>3,4,5</code>。</p>
<p>因此跳表的时间复杂度，依赖于每层遍历的节点数量：</p>
<ul>
<li>搜索：时间 <code>O(m * logn)</code></li>
<li>删除：时间 <code>O(m * logn)</code></li>
<li>插入：时间 <code>O(m * logn)</code></li>
</ul>
<p>其中 m 是每层最多遍历的节点数量。</p>
<p>跳表将原始链表的时间复杂度从 <code>O(n)</code> 提升到了 <code>O(logn)</code> 级别。</p>
<p>当然，这是利用空间换时间才得到的，空间消耗变多了。</p>
<h2 id="三、跳表如何实现？"><a href="#三、跳表如何实现？" class="headerlink" title="三、跳表如何实现？"></a>三、跳表如何实现？</h2><p>跳表的实现方式可以分为2种：</p>
<ul>
<li>数组实现：由一个数组实现，数组内部包含多层索引指针</li>
<li>链表实现：有多条链表实现，每条链表一层索引</li>
</ul>
<p>它们的区别只在于底层存储不同，对外是一致的。</p>
<p>下面以链表实现为例，说明跳表的实现。</p>
<h3 id="3-1-跳表的定义"><a href="#3-1-跳表的定义" class="headerlink" title="3.1 跳表的定义"></a>3.1 跳表的定义</h3><h4 id="3-1-1-结构定义"><a href="#3-1-1-结构定义" class="headerlink" title="3.1.1 结构定义"></a>3.1.1 结构定义</h4><p>为了减少代码中的判空，采用了一个哨兵头节点，所以实际的跳表结构是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 | ----------------------------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___               ___               ___</span><br><span class="line">|   | -&gt; | 1 | ----------&gt; | 3 | ----------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                 |                 |</span><br><span class="line"> ___      ___      ___      ___      ___      ___      ___</span><br><span class="line">|   | -&gt; | 1 | -&gt; | 2 | -&gt; | 3 | -&gt; | 4 | -&gt; | 5 | -&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>

<p>顶层的 <code>head</code> 节点单独一层，并且这一层只有它一个非空节点。</p>
<h4 id="3-1-2-接口定义"><a href="#3-1-2-接口定义" class="headerlink" title="3.1.2 接口定义"></a>3.1.2 接口定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SkipList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索指定值是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true存在/false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">search</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加新值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 新值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true删除成功/false删除失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">erase</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-链式跳表的定义"><a href="#3-1-3-链式跳表的定义" class="headerlink" title="3.1.3 链式跳表的定义"></a>3.1.3 链式跳表的定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedSkipList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">SkipList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 节点值</span></span><br><span class="line">        T value;</span><br><span class="line">        <span class="comment">// 同一层的右侧节点指针</span></span><br><span class="line">        Node right;</span><br><span class="line">        <span class="comment">// 下一层的同值节点指针</span></span><br><span class="line">        Node down;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T value, Node right, Node down)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.down = down;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-跳表的搜索"><a href="#3-2-跳表的搜索" class="headerlink" title="3.2 跳表的搜索"></a>3.2 跳表的搜索</h3><h4 id="3-2-1-代码实现"><a href="#3-2-1-代码实现" class="headerlink" title="3.2.1 代码实现"></a>3.2.1 代码实现</h4><p>跳表的搜索，就是从顶层的索引开始，一层一层往下找，直到找对对应的节点为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Node p = head, q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从上往下一直找，直到最底层的原始链表为止</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p) &#123;</span><br><span class="line">        <span class="comment">// 在当前层遍历搜索，直到找到 value 所在区间</span></span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span> &amp;&amp; value.compareTo(p.right.value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索下一层</span></span><br><span class="line">        q = p;</span><br><span class="line">        p = p.down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证节点值是否相等</span></span><br><span class="line">    <span class="keyword">return</span> q != <span class="keyword">null</span> &amp;&amp; q.right != <span class="keyword">null</span> &amp;&amp; q.right.value.equals(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-结构示意"><a href="#3-2-2-结构示意" class="headerlink" title="3.2.2 结构示意"></a>3.2.2 结构示意</h4><p>搜索过程就类似下面这样（暂时忽略其他线）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   |</span><br><span class="line">  |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 |                               | 5 |</span><br><span class="line">           |                                    </span><br><span class="line"> ___      ___               ___               ___</span><br><span class="line">|   |    | 1 | ----------&gt; | 3 |             | 5 |</span><br><span class="line">                             |                  </span><br><span class="line"> ___      ___      ___      ___      ___      ___      ___</span><br><span class="line">|   |    | 1 |    | 2 |    | 3 | -&gt; | 4 |    | 5 |    | 6 |</span><br></pre></td></tr></table></figure>

<p>很简单，就是一层一层找符合范围的区间，直到最底层的原始链表。</p>
<h3 id="3-3-跳表的插入"><a href="#3-3-跳表的插入" class="headerlink" title="3.3 跳表的插入"></a>3.3 跳表的插入</h3><h4 id="3-3-1-代码实现"><a href="#3-3-1-代码实现" class="headerlink" title="3.3.1 代码实现"></a>3.3.1 代码实现</h4><p>插入节点，除了要知道插入点的位置，还要知道上一层跳到下一层的转折节点。</p>
<p>因为插入节点，不仅仅是插入最底层，上面的索引层也需要一起更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找指定值的前置路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 前置路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Node&gt; <span class="title">findProcessors</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Node p = head;</span><br><span class="line">    <span class="comment">// 从上往下一直找，直到最底层的原始链表为止</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在当前层遍历搜索，直到找到 value 所在区间</span></span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span> &amp;&amp; value.compareTo(p.right.value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录上一层节点</span></span><br><span class="line">        stack.push(p);</span><br><span class="line">        <span class="comment">// 搜索下一层</span></span><br><span class="line">        p = p.down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径是倒序摆放的，最接近值 value 的在索引 0 的位置</span></span><br><span class="line">    List&lt;Node&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;(stack.size());</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        path.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找返回的是目标节点的前置路径：</p>
<ul>
<li>前置路径是搜索过程中上一层跳到下一层的那个转折节点列表</li>
</ul>
<p>比如上面搜索 4 时，搜索路径是 <code>1-&gt;3-&gt;4</code>，那么得到的前置路径就是 <code>[3, 1]</code>。</p>
<p>为什么前置路径是倒序的？</p>
<ul>
<li>因为插入节点是从下往上插入的，为了方便就倒序返回了</li>
</ul>
<p>找到前置路径后，就可以准备插入节点了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    List&lt;Node&gt; processors = findProcessors(value);</span><br><span class="line">    <span class="keyword">int</span> levels = processors.size();</span><br><span class="line"></span><br><span class="line">    Node newNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> insertUp = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levels &amp;&amp; insertUp; i++) &#123;</span><br><span class="line">        Node processor = processors.get(i);</span><br><span class="line">        <span class="comment">// 新节点指向下一层的同值节点</span></span><br><span class="line">        newNode = <span class="keyword">new</span> Node(value, processor.right, newNode);</span><br><span class="line">        <span class="comment">// 在当前层插入新节点</span></span><br><span class="line">        processor.right = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否要继续往上一层插入节点</span></span><br><span class="line">        insertUp = random.nextDouble() &lt; FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新层级</span></span><br><span class="line">    <span class="keyword">if</span> (insertUp) &#123;</span><br><span class="line">        levelUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-结构示意"><a href="#3-3-2-结构示意" class="headerlink" title="3.3.2 结构示意"></a>3.3.2 结构示意</h4><p>比如插入前跳表的结构是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 | ----------------------------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 | ----------------------------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___      ___               ___      ___      ___</span><br><span class="line">|   | -&gt; | 1 | -&gt; | 2 | ----------&gt; | 4 | -&gt; | 5 | -&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>

<p>此时插入一个 3，插入过程是从下往上的：</p>
<p>1）第一次插入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 | ----------------------------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 | ----------------------------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___      ___      ___      ___      ___      ___</span><br><span class="line">|   | -&gt; | 1 | -&gt; | 2 | -&gt; | 3 | -&gt; | 4 | -&gt; | 5 | -&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>

<p>2）第二次插入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 | ----------------------------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___               ___               ___</span><br><span class="line">|   | -&gt; | 1 | ----------&gt; | 3 | ----------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                 |                 |</span><br><span class="line"> ___      ___      ___      ___      ___      ___      ___</span><br><span class="line">|   | -&gt; | 1 | -&gt; | 2 | -&gt; | 3 | -&gt; | 4 | -&gt; | 5 | -&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>

<p>至于需要插入多少层，这个是通过随机数控制的。</p>
<p>采用了随机数 <code>random.nextDouble() &lt; FACTOR</code>，来判断要不要往上一层插入节点。</p>
<p>为什么采用随机数？</p>
<ul>
<li>为了减少算法代码的复杂度</li>
<li>同时又尽量确保跳表的结构平衡</li>
</ul>
<p>跳表本身代码就比较简单，如果为了维持结构而引入其他复杂算法，显得得不偿失。</p>
<p>随机数就很合适，使用不复杂，而且能大概率保证跳表结构不会严重退化。</p>
<h4 id="3-3-3-提升层级"><a href="#3-3-3-提升层级" class="headerlink" title="3.3.3 提升层级"></a>3.3.3 提升层级</h4><p>如果节点被插入到了顶层，这个时候需要提升整个跳表的层级。</p>
<p>比如 3 节点被插入到顶层后，跳表结构变成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___                        ___</span><br><span class="line">|   | -------------------&gt; | 3 | ------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___      ___               ___               ___</span><br><span class="line">|   | -&gt; | 1 | ----------&gt; | 3 | ----------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                 |                 |</span><br><span class="line"> ___      ___               ___               ___</span><br><span class="line">|   | -&gt; | 1 | ----------&gt; | 3 | ----------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                 |                 |</span><br><span class="line"> ___      ___      ___      ___      ___      ___      ___</span><br><span class="line">|   | -&gt; | 1 | -&gt; | 2 | -&gt; | 3 | -&gt; | 4 | -&gt; | 5 | -&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>

<p>为了维持跳表头节点在单独一层的结构，就需要提升层级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提升层级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最上层只有一个头节点</span></span><br><span class="line">    head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提升层级后，跳表的结构就恢复正常了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___                        ___</span><br><span class="line">|   | -------------------&gt; | 3 | ------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___      ___               ___               ___</span><br><span class="line">|   | -&gt; | 1 | ----------&gt; | 3 | ----------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                 |                 |</span><br><span class="line"> ___      ___               ___               ___</span><br><span class="line">|   | -&gt; | 1 | ----------&gt; | 3 | ----------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                 |                 |</span><br><span class="line"> ___      ___      ___      ___      ___      ___      ___</span><br><span class="line">|   | -&gt; | 1 | -&gt; | 2 | -&gt; | 3 | -&gt; | 4 | -&gt; | 5 | -&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>


<h3 id="3-4-跳表的删除"><a href="#3-4-跳表的删除" class="headerlink" title="3.4 跳表的删除"></a>3.4 跳表的删除</h3><h4 id="3-4-1-代码实现"><a href="#3-4-1-代码实现" class="headerlink" title="3.4.1 代码实现"></a>3.4.1 代码实现</h4><p>删除和插入过程是一样的，都是先找到前置路径后，再处理节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">erase</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    List&lt;Node&gt; processors = findProcessors(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证删除节点是否存在，没有找到则直接返回</span></span><br><span class="line">    Node target = processors.get(<span class="number">0</span>).right;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span> || !value.equals(target.value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下往上，逐层删除指定节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node processor : processors) &#123;</span><br><span class="line">        <span class="comment">// 指定 value 值的节点在每一层都删完了，就跳出循环</span></span><br><span class="line">        Node delNode = processor.right;</span><br><span class="line">        <span class="keyword">if</span> (delNode == <span class="keyword">null</span> || !delNode.value.equals(value)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        processor.right = delNode.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新层级</span></span><br><span class="line">    levelDown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-结构示意"><a href="#3-4-2-结构示意" class="headerlink" title="3.4.2 结构示意"></a>3.4.2 结构示意</h4><p>删除也和插入一样，是从下往上的。比如删除 3：</p>
<p>1）第一次删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 | ----------------------------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___               ___               ___</span><br><span class="line">|   | -&gt; | 1 | ----------&gt; | 3 | ----------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___      ___               ___      ___      ___</span><br><span class="line">|   | -&gt; | 1 | -&gt; | 2 | ----------&gt; | 4 | -&gt; | 5 | -&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>

<p>2）第二次删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 | ----------------------------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___                                 ___</span><br><span class="line">|   | -&gt; | 1 | ----------------------------&gt; | 5 | ------------&gt; null</span><br><span class="line">  |        |                                   |</span><br><span class="line"> ___      ___      ___               ___      ___      ___</span><br><span class="line">|   | -&gt; | 1 | -&gt; | 2 | ----------&gt; | 4 | -&gt; | 5 | -&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>

<h4 id="3-4-3-降低层级"><a href="#3-4-3-降低层级" class="headerlink" title="3.4.3 降低层级"></a>3.4.3 降低层级</h4><p>删除节点后，有可能导致跳表的上层节点变得比较少，此时需要降低层级。</p>
<p>比如把 1 和 5 都删掉后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |</span><br><span class="line"> ___                                          </span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |                                             </span><br><span class="line"> ___                                      </span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |                                             </span><br><span class="line"> ___               ___               ___               ___</span><br><span class="line">|   | ----------&gt; | 2 | ----------&gt; | 4 | ----------&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>

<p>上面几层链表都空了，浪费空间，这个时候需要将这些节点很少的层级删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 降低层级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head.down != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 连续 2 层为空时，才降低层级，因为最上层只有 1 个头节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.right != <span class="keyword">null</span> || head.down.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node p = head;</span><br><span class="line">        head = head.down;</span><br><span class="line">        p.down = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除后，跳表又恢复成正常的结构了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line"> ___</span><br><span class="line">|   | ---------------------------------------------------------&gt; null</span><br><span class="line">  |                                             </span><br><span class="line"> ___               ___               ___               ___</span><br><span class="line">|   | ----------&gt; | 2 | ----------&gt; | 4 | ----------&gt; | 6 | ---&gt; null</span><br></pre></td></tr></table></figure>


<h2 id="四、跳表的应用场景"><a href="#四、跳表的应用场景" class="headerlink" title="四、跳表的应用场景"></a>四、跳表的应用场景</h2><p>跳表的设计目的，为了快速查找。</p>
<p>所以它比较适合以下的场景：</p>
<ul>
<li>是有序链表，无序链表用不了</li>
<li>多次查询链表，注意是多次，只查一次的话不如直接遍历</li>
<li>较少的插入和删除，虽然跳表的插入删除性能不差，但是其目的不在于此</li>
</ul>
<p>本质上，跳表就是二分查找的链表实现版本，目的就是加快查询。</p>
<p>所以，有序数组二分查找适用的场景，就适用于有序链表的跳表。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/algorithm/segment_tree/</url>
    <content><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="一、线段树是什么？"><a href="#一、线段树是什么？" class="headerlink" title="一、线段树是什么？"></a>一、线段树是什么？</h2><ul>
<li>线段树本质上是一种缓存，它缓存的是区间值</li>
<li>线段树一棵平衡二叉树</li>
<li>线段树的节点表示的是一个区间，节点值表示区间值</li>
</ul>
<span id="more"></span>

<h2 id="二、为什么要用线段树？"><a href="#二、为什么要用线段树？" class="headerlink" title="二、为什么要用线段树？"></a>二、为什么要用线段树？</h2><p>线段树的常见用途有：</p>
<ul>
<li>缓存区间值，提高多次查询区间值的性能</li>
<li>懒更新区间，减少修改的次数，提高多次修改区间的性能</li>
</ul>
<p>简单点说就是：</p>
<ul>
<li>通过缓存，提高多次区间查询和区间修改的性能</li>
<li>重点在于多次，多次，多次！！！</li>
</ul>
<p>下面说明线段树如何通过缓存提高性能。</p>
<p>一般情况下，当需要修改一个区间内的所有值时，只能通过遍历的方式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包括获取查询某个区间内的最大值、最小值、区间和时，也只能遍历整个区间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    sum += nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像这种区间查询和区间修改，没有其他办法，也只能通过遍历来实现了。</p>
<p>但是，如果说会多次执行区间查询，每次都要遍历一遍的话，性能会比较差。</p>
<ul>
<li>能不能把区间查询的结果缓存下来，下次查询时直接返回缓存？</li>
</ul>
<p>比如，在区间之上缓存一个区间和结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             ____</span><br><span class="line">            | 28 |               -- 缓存区间值</span><br><span class="line">              |        </span><br><span class="line">   _______________________</span><br><span class="line">  |                       |</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___</span><br><span class="line">| 1 | 6 | 7 | 2 | 5 | 4 | 3 |    -- 原始数组（已排除索引 0，从 1 开始）</span><br></pre></td></tr></table></figure>

<p>下次查询 <code>[1, 7]</code> 的区间和时，就可以直接从缓存节点返回结果 28。</p>
<p>这样貌似可行，但是只缓存一个够了吗？不够，如果要查询区间 <code>[2 ,4]</code>，还是要遍历。</p>
<p>所以需要把各个区间的结果都缓存了，最终缓存结构就变成了一棵二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                  ____</span><br><span class="line">                                 | 28 | ([1, 7])</span><br><span class="line">                                   |</span><br><span class="line">                  ____________________________________</span><br><span class="line">                 |                                    |</span><br><span class="line">                ____                                 ____</span><br><span class="line">               | 16 | ([1, 4])                      | 12 | ([5, 7])</span><br><span class="line">                 |                                    |</span><br><span class="line">        ___________________                     ______________</span><br><span class="line">       |                   |                   |              |</span><br><span class="line">      ___                 ___                 ___             |</span><br><span class="line">     | 7 | ([1, 2])      | 9 | ([3, 4])      | 9 | ([5, 6])   |</span><br><span class="line">       |                   |                   |              |</span><br><span class="line">   _________           _________           _________          |</span><br><span class="line">  |         |         |         |         |         |         |</span><br><span class="line"> ___       ___       ___       ___       ___       ___       ___</span><br><span class="line">| 1 |     | 6 |     | 7 |     | 2 |     | 5 |     | 4 |     | 3 |</span><br></pre></td></tr></table></figure>

<p>这个二叉树结构就是线段树，每个节点表示一个区间，节点值就是区间值。</p>
<p>线段树实际就是一个二叉树缓存结构，上一层缓存着下一层节点的区间值。</p>
<p>有了线段树，区间的查询就变简单了，比如查询区间 <code>[3, 7]</code>：</p>
<ol>
<li>从根节点出发，利用二分法逐层往下寻找查询区间</li>
<li>最后找到了满足要求的区间节点 <code>[3, 4]</code> 和 <code>[5, 7]</code></li>
<li>区间节点 <code>[3, 4]</code> 的值是 9，区间节点 <code>[5, 7]</code> 的值是 12</li>
<li>所以 <code>[3, 7]</code> 的区间和等于 <code>9 + 12 = 21</code></li>
</ol>
<p>有了线段树以后，无需再遍历所有节点，而是通过上层的缓存节点就能拿到结果。</p>
<ul>
<li>区间查询的复杂度从 <code>O(n)</code> 降为了 <code>O(logn)</code></li>
</ul>
<p>线段树就是利用空间换时间，通过缓存来提高区间查询的性能。</p>
<ul>
<li>线段树本质就是缓存，父节点就是子节点的缓存</li>
</ul>
<p>至于父节点缓存的是什么数据，视情况而定。比如说：</p>
<ul>
<li>区间最大值</li>
<li>区间最小值</li>
<li>区间和</li>
<li>…</li>
</ul>
<p>使用线段树前，应该想清楚，缓存的数据究竟是什么？</p>
<h2 id="三、线段树如何实现？"><a href="#三、线段树如何实现？" class="headerlink" title="三、线段树如何实现？"></a>三、线段树如何实现？</h2><p>线段树的实现方式主要分为 2 种类型：</p>
<ul>
<li>静态线段树：所有节点一开始就构建好了，和区间范围有关</li>
<li>动态线段树：节点是动态创建的，随数据变化而变化</li>
</ul>
<p>静态线段树包括：</p>
<ul>
<li>简单线段树：基于数组实现的满二叉树结构</li>
</ul>
<p>动态线段树包括：</p>
<ul>
<li>动态估点线段树：基于数组实现的动态二叉树</li>
<li>动态开点线段树：基于指针实现的动态二叉树</li>
</ul>
<p>下面分别介绍这几种线段树。</p>
<h3 id="3-1-简单线段树"><a href="#3-1-简单线段树" class="headerlink" title="3.1 简单线段树"></a>3.1 简单线段树</h3><h4 id="3-1-1-基本思路"><a href="#3-1-1-基本思路" class="headerlink" title="3.1.1 基本思路"></a>3.1.1 基本思路</h4><ul>
<li>采用数组存储线段树节点</li>
<li>数组存储的是一棵满二叉树，其中有些节点是多余的</li>
<li>根节点的数组索引是 <code>1</code></li>
<li>左子节点索引 <code>2 * i</code>；右子节点索引 <code>2 * i + 1</code></li>
<li>总节点数量，一般取区间 <code>[1, n]</code> 的 4 倍，即 <code>4n</code></li>
</ul>
<h4 id="3-1-2-存储结构"><a href="#3-1-2-存储结构" class="headerlink" title="3.1.2 存储结构"></a>3.1.2 存储结构</h4><p>线段树是一棵平衡二叉树，也就是左右子树节点数量相差不超过 1。</p>
<p>但是平衡二叉树在数组上的存储、构造和取数都不方便，所以数组存储的是满二叉树结构。</p>
<p>满二叉树在数组中的父子节点索引关系刚好是：</p>
<ul>
<li>根节点索引是 <code>1</code></li>
<li>左子节点索引 <code>2 * i</code></li>
<li>右子节点索引 <code>2 * i + 1</code></li>
</ul>
<p>利用满二叉树的性质，很容易在数组上实现线段树。</p>
<h4 id="3-1-3-节点数量"><a href="#3-1-3-节点数量" class="headerlink" title="3.1.3 节点数量"></a>3.1.3 节点数量</h4><p>二叉树的节点数量，从上往下统计的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 ^ 0           -- 第1层</span><br><span class="line">2 ^ 1           -- 第2层</span><br><span class="line">2 ^ 2           -- 第3层</span><br><span class="line">2 ^ 3           -- 第4层</span><br><span class="line">...</span><br><span class="line">2 ^ (h - 1)     -- 第h层</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果区间范围 <code>n = 2 ^ k</code> 的话，那么刚好是满二叉树，节点总数就是 <code>S = 2n - 1</code>。</p>
<p>但如果区间范围是 <code>n = 2 ^ k + c</code> 的话，多出了几个，二叉树的最后一层就没有满。</p>
<ul>
<li>满二叉树有一个特点，下一层的节点数量等于前面所有层级的节点数量总和</li>
</ul>
<p>所以，如果填满了最后一层构成满二叉树的话，总节点数量就满足：</p>
<ul>
<li><code>2n - 1 &lt;= S &lt; 2 * (2n - 1) = 4n - 2</code></li>
</ul>
<p>所以，在初始化线段树时：</p>
<ul>
<li>总节点数量一般取区间范围的 4 倍</li>
</ul>
<p>但里面不是所有节点都会用到，有些多余的节点。</p>
<h4 id="3-1-4-构建过程"><a href="#3-1-4-构建过程" class="headerlink" title="3.1.4 构建过程"></a>3.1.4 构建过程</h4><p>简单线段树的构建步骤如下：</p>
<ol>
<li>计算出区间 <code>[1, n]</code> 的总节点数量 <code>4n</code></li>
<li>初始化所有树节点</li>
<li>递归构建二叉树结构</li>
</ol>
<p>比如构建“区间和”线段树的过程，类似这样：</p>
<p>(1) 初始化区间节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 总节点数量 4n</span></span><br><span class="line">    tree = <span class="keyword">new</span> Node[<span class="number">4</span> * n];</span><br><span class="line">    <span class="comment">// 初始化所有节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">        tree[i] = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 递归构建二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        tree[root].val = arr[start];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * root;</span><br><span class="line">    <span class="comment">// 右子节点索引</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建树</span></span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    buildTree(left, start, mid);</span><br><span class="line">    buildTree(right, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上更新父节点缓存</span></span><br><span class="line">    pushUp(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * root;</span><br><span class="line">    <span class="comment">// 右子节点索引</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 更新父节点的区间值</span></span><br><span class="line">    tree[root].val = tree[left].val + tree[right].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，数组 <code>arr = [, 1, 8, 2, 7, 4]</code>（注意数组 0 的位置不用）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   ____</span><br><span class="line">                                  | 18 | ([1, 5])</span><br><span class="line">                                    |</span><br><span class="line">                  _______________________________________</span><br><span class="line">                 |                                       |</span><br><span class="line">                ____                                    ___</span><br><span class="line">               | 11 | ([1, 3])                         | 7 | ([4, 5])</span><br><span class="line">                 |                                       |</span><br><span class="line">        ___________________                     ___________________</span><br><span class="line">       |                   |                   |                   |</span><br><span class="line">      ___                 ___                 ___                 ___</span><br><span class="line">     | 9 | ([1, 2])      | 2 |               | 3 |               | 4 |</span><br><span class="line">       |</span><br><span class="line">   _________       </span><br><span class="line">  |         |     </span><br><span class="line"> ___       ___</span><br><span class="line">| 1 |     | 8 |</span><br></pre></td></tr></table></figure>

<p>假设区间范围就是 <code>[1, 5]</code>，也就是 <code>n = 5</code>，所以需申请 <code>4 * 5 = 20</code> 个节点空间。</p>
<p>但是实际上只用了 <code>9</code> 个空间，不过为了按照满二叉树结构存储数据，也需要 <code>15</code> 个节点了。</p>
<p>至于其他还多出来的节点，是由于 <code>4n</code> 的误差引起的，毕竟 <code>4n</code> 并不是精确的节点数量值。</p>
<h3 id="3-2-动态估点线段树"><a href="#3-2-动态估点线段树" class="headerlink" title="3.2 动态估点线段树"></a>3.2 动态估点线段树</h3><h4 id="3-2-1-基本思路"><a href="#3-2-1-基本思路" class="headerlink" title="3.2.1 基本思路"></a>3.2.1 基本思路</h4><ul>
<li>根据数据情况，预估可能会访问到的区间范围，从而估计节点数量</li>
<li>根节点的数组索引是 1</li>
<li>子节点索引不确定，父节点内维护有左右子节点的索引 l 和 r</li>
<li>维护有一个 size 大小，表示当前节点数量，也可用于计算下一个节点的索引</li>
<li>动态开点时，新节点的索引就等于 <code>size + 1</code>，比如  <code>node.lp = ++size</code></li>
<li>不算是完全动态，数组一开始就已经申请好空间了，动态的只有创建 <code>Node</code> 节点而已</li>
</ul>
<h4 id="3-2-2-区间估点"><a href="#3-2-2-区间估点" class="headerlink" title="3.2.2 区间估点"></a>3.2.2 区间估点</h4><p>静态线段树的数组长度是按照满二叉树的节点数量来设置的。</p>
<p>但是在实际上未必会用到这么多节点，所以可能会采用一种估点的方式来简化。</p>
<ul>
<li>估点：就是估计线段树会用到实际区间范围，来替代理论上的区间范围</li>
</ul>
<p>比如说，线段树的区间范围定义是 <code>[1, 1000]</code>，但是实际查询数据范围只用到了 <code>[1, 200]</code>。</p>
<p>在这种情况下，完全没必要为线段树创建 <code>4 * 1000</code> 个节点，因为很多节点实际上根本访问不到。</p>
<ul>
<li>可以根据实际数据的查询范围，估计一个合理的节点数量</li>
<li>在线段树初始化数组时，就采用估点值来初始化数组长度</li>
</ul>
<p>网上提供了一些公式，比如 <code>6 * m * logn</code>，其中，m 是查询次数，n 是区间值域大小。</p>
<h4 id="3-2-3-动态建点"><a href="#3-2-3-动态建点" class="headerlink" title="3.2.3 动态建点"></a>3.2.3 动态建点</h4><p>动态线段树的节点是动态创建的，所以不再维护满二叉树的结构了。</p>
<ul>
<li>新创建的节点都放在数组末尾</li>
<li>父节点内保存指向左右子节点的索引</li>
</ul>
<p>节点的结构定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;   <span class="comment">// 区间值</span></span><br><span class="line">    <span class="keyword">int</span> left;  <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="keyword">int</span> right; <span class="comment">// 右子节点索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新节点的创建就类似这样，添加到数组末尾：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新父节点中的左子节点索引</span></span><br><span class="line">node.left = ++size;</span><br><span class="line"><span class="comment">// 创建左子节点</span></span><br><span class="line">tree[node.left] = <span class="keyword">new</span> Node();</span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-构建过程"><a href="#3-2-4-构建过程" class="headerlink" title="3.2.4 构建过程"></a>3.2.4 构建过程</h4><p>动态估点线段树的构建步骤如下：</p>
<ol>
<li>估计区间节点范围</li>
<li>根据估点值初始化数组长度</li>
<li>初始化根节点</li>
<li>访问时动态创建其他节点</li>
</ol>
<p>比如构建“区间和”线段树的过程，类似这样：</p>
<p>(1) 区间估点 + 初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 理论上的区间范围</span></span><br><span class="line">    <span class="keyword">this</span>.low = low;</span><br><span class="line">    <span class="keyword">this</span>.high = high;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 估点区间范围 6 * m * logn</span></span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>) (<span class="number">6</span> * <span class="number">10000</span> * Math.log(high));</span><br><span class="line">    <span class="comment">// 按照估点创建数组</span></span><br><span class="line">    tree = <span class="keyword">new</span> Node[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化根节点</span></span><br><span class="line">    tree[<span class="number">1</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 访问节点时动态建点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问节点前，先向下推送更新</span></span><br><span class="line">    pushDown(node, start, end);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问节点前，先向下推送更新</span></span><br><span class="line">    pushDown(node, start, end);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态开点，新节点总是添加到数组末尾</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = ++size;</span><br><span class="line">        tree[node.left] = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = ++size;</span><br><span class="line">        tree[node.right] = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-3-动态开点线段树"><a href="#3-3-动态开点线段树" class="headerlink" title="3.3 动态开点线段树"></a>3.3 动态开点线段树</h3><h4 id="3-3-1-基本思路"><a href="#3-3-1-基本思路" class="headerlink" title="3.3.1 基本思路"></a>3.3.1 基本思路</h4><ul>
<li>父子节点间采用指针进行链接</li>
<li>维护有一个根节点</li>
<li>每个节点维护有左右子节点的指针 <code>left</code> 和 <code>right</code></li>
<li>动态开点时，直接创建新节点，比如 <code>node.left = new Node()</code></li>
</ul>
<h4 id="3-3-2-动态建点"><a href="#3-3-2-动态建点" class="headerlink" title="3.3.2 动态建点"></a>3.3.2 动态建点</h4><p>基于指针的动态建点再简单不过了，就是平常的树结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;     <span class="comment">// 区间值</span></span><br><span class="line">    Node left;   <span class="comment">// 左子节点</span></span><br><span class="line">    Node right;  <span class="comment">// 右子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在访问到节点前，动态创建节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建左子节点</span></span><br><span class="line">node.left = <span class="keyword">new</span> Node();</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-构建过程"><a href="#3-3-3-构建过程" class="headerlink" title="3.3.3 构建过程"></a>3.3.3 构建过程</h4><p>动态开点线段树的构建步骤如下：</p>
<ol>
<li>初始化根节点</li>
<li>访问时动态创建其他节点</li>
</ol>
<p>比如构建“区间和”线段树的过程，类似这样：</p>
<p>(1) 初始化根节点 + 初始化区间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">this</span>.low = low;</span><br><span class="line">    <span class="keyword">this</span>.high = high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 访问时动态创建其他节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态向下更新</span></span><br><span class="line">    pushDown(node, start, end);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态向下更新</span></span><br><span class="line">    pushDown(node, start, end);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.left = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.right = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><p>静态线段树的特点：</p>
<ul>
<li>一开始就要申请全部空间，以及构建好线段树结构</li>
<li>占用空间比较大，初始化会比较慢</li>
<li>有些节点未必会访问到，空间利用率低</li>
</ul>
<p>所以又引申出了动态线段树：</p>
<ul>
<li>用到这个节点时，再申请节点空间以及初始化</li>
</ul>
<p>动态线段树的实现方式有 2 种：</p>
<ul>
<li>动态估点：基于数组</li>
<li>动态开点：基于指针</li>
</ul>
<p>视不同的情况可以选择不同的线段树。</p>
<h2 id="四、线段树的优化"><a href="#四、线段树的优化" class="headerlink" title="四、线段树的优化"></a>四、线段树的优化</h2><h3 id="4-1-懒标记更新"><a href="#4-1-懒标记更新" class="headerlink" title="4.1 懒标记更新"></a>4.1 懒标记更新</h3><h4 id="4-1-1-懒更新引入"><a href="#4-1-1-懒更新引入" class="headerlink" title="4.1.1 懒更新引入"></a>4.1.1 懒更新引入</h4><p>线段树本质是一棵缓存树，在数据没有修改的情况下，查询性能确实高。</p>
<p>但是如果频繁对区间数据进行修改，就可能会对性能造成影响。</p>
<p>比如说，要把区间 <code>[1, 5]</code> 内的值都更新为 1，且此时在线段树中找到了 <code>[1, 3]</code> 和 <code>[4, 5]</code> 这 2 个区间。</p>
<p>按正常逻辑，需要把以 <code>[1, 3]</code> 和 <code>[4, 5]</code> 为根节点的 2 棵子树的所有节点值都更新为 1。</p>
<p>但是子树里面包括了很多节点，比如 <code>[1, 1]</code>、<code>[2, 2]</code>、<code>[1, 2]</code> … <code>[5, 5]</code> 等等。</p>
<ul>
<li>这些节点不一定都会被访问到，也许永远没人访问，白更新了</li>
<li>每次更新区间都把所有相关子节点都更新一遍的话，势必会影响性能</li>
</ul>
<p>为此，提出了一种懒更新的方式：</p>
<ul>
<li>更新区间时，先标记根节点被更新了，但是暂时不要同步到子节点里面</li>
<li>下次访问子节点前，先从父节点上把上次的数据同步到子节点里面</li>
</ul>
<p>使用懒更新后，只需要更新 <code>[1, 3]</code> 和 <code>[4, 5]</code> 这 2 个节点就够了，速度就很快。</p>
<p>等到下次查询区间 <code>[1, 2]</code> 时，才会从 <code>[1, 3]</code> 区间上同步之前的更新下来。</p>
<h4 id="4-1-2-懒标记实现"><a href="#4-1-2-懒标记实现" class="headerlink" title="4.1.2 懒标记实现"></a>4.1.2 懒标记实现</h4><p>在节点中引入懒标记，同时用于保存更新值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;     <span class="comment">// 区间值</span></span><br><span class="line">    Node left;   <span class="comment">// 左子节点</span></span><br><span class="line">    Node right;  <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">int</span> add;     <span class="comment">// 懒标记，0 时表示无更新，其他表示有更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在更新区间时，只需要更新父节点就行了。</p>
<p>等下次访问子节点前，再从父节点同步数据到子节点中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">        <span class="comment">// 更新区间节点值</span></span><br><span class="line">        node.val = val;</span><br><span class="line">        <span class="comment">// 更新懒标记</span></span><br><span class="line">        node.add = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态向下更新</span></span><br><span class="line">    pushDown(node, start, end);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父节点没有更新</span></span><br><span class="line">    <span class="keyword">if</span> (node.add == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步到子节点</span></span><br><span class="line">    node.left.val = node.add;</span><br><span class="line">    node.left.add = node.add;</span><br><span class="line">    node.right.val = node.add;</span><br><span class="line">    node.right.add = node.add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置父节点的懒标记</span></span><br><span class="line">    node.add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理很简单，就是尽量不往下面更新，减少更新时间。</p>
<h2 id="五、线段树模板"><a href="#五、线段树模板" class="headerlink" title="五、线段树模板"></a>五、线段树模板</h2><p>线段树有 2 个主要操作：</p>
<ul>
<li>区间查询</li>
<li>区间更新</li>
</ul>
<p>因此接口只定义了这 2 个。</p>
<h3 id="5-1-接口定义"><a href="#5-1-接口定义" class="headerlink" title="5.1 接口定义"></a>5.1 接口定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询指定区间的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l 目标区间[l, r]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 目标区间[l, r]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 区间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新指定区间的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l   目标区间[l, r]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r   目标区间[l, r]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 更新的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-动态估点（数组）"><a href="#5-1-动态估点（数组）" class="headerlink" title="5.1 动态估点（数组）"></a>5.1 动态估点（数组）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraySegmentTree</span> <span class="keyword">implements</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 懒惰标记</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> add;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左右节点数组下标</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> left, right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树节点数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Node[] tree;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 区间最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> low;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 区间最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArraySegmentTree</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.low = low;</span><br><span class="line">        <span class="keyword">this</span>.high = high;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区间估点 4n</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span> * high;</span><br><span class="line">        tree = <span class="keyword">new</span> Node[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化根节点</span></span><br><span class="line">        tree[<span class="number">1</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(tree[<span class="number">1</span>], low, high, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询指定区间的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l     目标区间[l, r]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r     目标区间[l, r]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 区间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问节点前，先向下推送更新</span></span><br><span class="line">        pushDown(node, start, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别取左右子区间的值</span></span><br><span class="line">        Integer lResult = <span class="keyword">null</span>, rResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = middle(start, end);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">            lResult = query(tree[node.left], start, mid, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">            rResult = query(tree[node.right], mid + <span class="number">1</span>, end, l, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并子区间的查询结果</span></span><br><span class="line">        <span class="keyword">return</span> mergeQuery(node, start, end, lResult, rResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(tree[<span class="number">1</span>], low, high, l, r, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新指定区间的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l     目标区间[l, r]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r     目标区间[l, r]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val   更新的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            <span class="comment">// 更新符合区间要求的节点值</span></span><br><span class="line">            writeDown(node, start, end, val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问节点前，先向下推送更新</span></span><br><span class="line">        pushDown(node, start, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归更新左右子区间</span></span><br><span class="line">        <span class="keyword">int</span> mid = middle(start, end);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">            update(tree[node.left], start, mid, l, r, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">            update(tree[node.right], mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子节点更新后，向上推送更新</span></span><br><span class="line">        pushUp(node, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子节点的值上推到父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        writeUp(node, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父节点的值下推到子节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态开点，新节点总是添加到数组末尾</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = ++size;</span><br><span class="line">            tree[node.left] = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = ++size;</span><br><span class="line">            tree[node.right] = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有懒标记，无需再往下推</span></span><br><span class="line">        <span class="keyword">if</span> (node.add == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把懒标记下推给子节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = middle(start, end);</span><br><span class="line">        writeDown(tree[node.left], start, mid, node.add);</span><br><span class="line">        writeDown(tree[node.right], mid + <span class="number">1</span>, end, node.add);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 懒标记已处理</span></span><br><span class="line">        node.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并指定区间的查询结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lVal  左区间的查询结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rVal  右区间的查询结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 区间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">mergeQuery</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Integer lVal, Integer rVal)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向上更新节点的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeUp</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向下更新节点的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val   更新的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 划分左右区间的中点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 左边界[start, end]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   右边界[start, end]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 中点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">middle</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-动态开点（指针）"><a href="#5-3-动态开点（指针）" class="headerlink" title="5.3 动态开点（指针）"></a>5.3 动态开点（指针）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkSegmentTree</span> <span class="keyword">implements</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 懒惰标记</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> add;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左右节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Node root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 区间最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> low;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 区间最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkSegmentTree</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.low = low;</span><br><span class="line">        <span class="keyword">this</span>.high = high;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询指定区间的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l 目标区间[l, r]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 目标区间[l, r]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 区间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(root, low, high, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询指定区间的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l     目标区间[l, r]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r     目标区间[l, r]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 区间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问节点前，先向下推送更新</span></span><br><span class="line">        pushDown(node, start, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别取左右子区间的值</span></span><br><span class="line">        Integer lResult = <span class="keyword">null</span>, rResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = middle(start, end);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">            lResult = query(node.left, start, mid, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">            rResult = query(node.right, mid + <span class="number">1</span>, end, l, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并子区间的查询结果</span></span><br><span class="line">        <span class="keyword">return</span> mergeQuery(node, start, end, lResult, rResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新指定区间的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l   目标区间[l, r]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r   目标区间[l, r]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 更新的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(root, low, high, l, r, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新指定区间的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l     目标区间[l, r]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r     目标区间[l, r]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val   更新的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            <span class="comment">// 更新符合区间要求的节点值</span></span><br><span class="line">            writeDown(node, start, end, val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问节点前，先向下推送更新</span></span><br><span class="line">        pushDown(node, start, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归更新左右子区间</span></span><br><span class="line">        <span class="keyword">int</span> mid = middle(start, end);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">            update(node.left, start, mid, l, r, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">            update(node.right, mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子节点更新后，向上推送更新</span></span><br><span class="line">        pushUp(node, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子节点的值上推到父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        writeUp(node, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父节点的值下推到子节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态开点，指向动态创建的对象</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有懒标记，无需再往下推</span></span><br><span class="line">        <span class="keyword">if</span> (node.add == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把懒标记下推给子节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = middle(start, end);</span><br><span class="line">        writeDown(node.left, start, mid, node.add);</span><br><span class="line">        writeDown(node.right, mid + <span class="number">1</span>, end, node.add);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 懒标记已处理</span></span><br><span class="line">        node.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并指定区间的查询结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lVal  左区间的查询结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rVal  右区间的查询结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 区间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">mergeQuery</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Integer lVal, Integer rVal)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向上更新节点的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeUp</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向下更新节点的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 当前区间[start, end]的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   当前区间[start, end]的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val   更新的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 划分左右区间的中点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 左边界[start, end]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   右边界[start, end]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 中点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">middle</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、实际案例"><a href="#六、实际案例" class="headerlink" title="六、实际案例"></a>六、实际案例</h2><h3 id="6-1-LC-307-区域和检索"><a href="#6-1-LC-307-区域和检索" class="headerlink" title="6.1 LC 307. 区域和检索"></a>6.1 LC 307. 区域和检索</h3><blockquote>
<p>题目描述</p>
</blockquote>
<p>给你一个数组 nums ，请你完成两类查询。 </p>
<p>其中一类查询要求 更新 数组 nums 下标对应的值</p>
<p>另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left &lt;= right</p>
<p>实现 NumArray 类：</p>
<p>NumArray(int[] nums) 用整数数组 nums 初始化对象</p>
<p>void update(int index, int val) 将 nums[index] 的值 更新 为 val</p>
<p>int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的&gt; nums元素的 和 （即，nums[left] + nums[left + 1], …, nums[right]</p>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 3 * 104</li>
<li>-100 &lt;= nums[i] &lt;= 100</li>
<li>0 &lt;= index &lt; nums.length</li>
<li>-100 &lt;= val &lt;= 100</li>
<li>0 &lt;= left &lt;= right &lt; nums.length</li>
<li>调用 update 和 sumRange 方法次数不大于 3 * 104 </li>
</ul>
<hr>
<blockquote>
<p>问题分析</p>
</blockquote>
<p>问题中涉及了 2 个操作：</p>
<ul>
<li>单点更新</li>
<li>区间求和</li>
</ul>
<p>单点更新，可以当成是长度为 1 区间更新，所以这 2 种操作都可认为是区间操作。</p>
<p>线段树正好可以用来解决这 2 个问题。</p>
<p>首先分析一下：</p>
<ul>
<li>区间节点需要缓存什么数据？</li>
</ul>
<p>从题目可知，区间查询的结果是区间和，所以：</p>
<ul>
<li>父节点缓存的应该是子节点的区间和</li>
</ul>
<p>确定节点缓存的数据之后，套用模板修改代码即可。</p>
<hr>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>这可能用简单线段树会好一些，因为区间范围只有 <code>3 * 10^4</code>，不是很大，直接构建线段树也很快。</p>
<p>不过这里是采用了动态开点线段树来作为例子演示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区间和线段树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 父节点缓存的是子树所有节点的和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumLinkSegmentTree</span> <span class="keyword">extends</span> <span class="title">LinkSegmentTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumLinkSegmentTree</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(low, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">mergeQuery</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Integer lVal, Integer rVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 合并子树节点的区间和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += lVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += rVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeUp</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子树的区间和发生变化后，父节点也要更新</span></span><br><span class="line">        node.val = node.left.val + node.right.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// end - start + 1 表示子树中叶子节点的数量</span></span><br><span class="line">        <span class="comment">// 区间内所有叶子节点都设为 val 的话</span></span><br><span class="line">        <span class="comment">// 那么父节点应该等于所有叶子节点的 val 总和</span></span><br><span class="line">        node.val = (end - start + <span class="number">1</span>) * val;</span><br><span class="line">        node.add = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间和线段树实现好了，下面直接按题目要求调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SumSegmentTree segmentTree;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = (<span class="keyword">int</span>) <span class="number">3e4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        segmentTree = <span class="keyword">new</span> SumSegmentTree(low, high);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.update(i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        segmentTree.update(index, index, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> segmentTree.query(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题的解决方案还有其他方法，线段树的性能并不是最优的。</p>
<p>这里只是举例子说明一下线段树的用途。</p>
<h3 id="6-2-LC-699-掉落的方块"><a href="#6-2-LC-699-掉落的方块" class="headerlink" title="6.2 LC 699. 掉落的方块"></a>6.2 LC 699. 掉落的方块</h3><blockquote>
<p>题目描述</p>
</blockquote>
<p>在二维平面上的 x 轴上，放置着一些方块。</p>
<p>给你一个二维整数数组 positions ，其中 positions[i] = [lefti, sideLengthi] 表示：第 i 个方块边长为 sideLengthi ，其左侧边与 x 轴上坐标点 lefti 对齐。</p>
<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 另一个正方形的顶边 或者是 x 轴上 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>
<p>在每个方块掉落后，你必须记录目前所有已经落稳的 方块堆叠的最高高度 。</p>
<p>返回一个整数数组 ans ，其中 ans[i] 表示在第 i 块方块掉落后堆叠的最高高度。</p>
<p>提示：</p>
<ul>
<li>1 &lt;= positions.length &lt;= 1000</li>
<li>1 &lt;= lefti &lt;= 108</li>
<li>1 &lt;= sideLengthi &lt;= 106</li>
</ul>
<hr>
<blockquote>
<p>问题分析</p>
</blockquote>
<p>问题中出现的 2 个行为：</p>
<ul>
<li>方块掉落在坐标轴上，占用了一个区间，这实际上就是区间更新</li>
<li>查询所有方块堆叠的最高高度，实际就是在查找区间内的最大值</li>
</ul>
<p>所以也可以用线段树来实现区间更新和区间求最大值。</p>
<p>首先分析一下：</p>
<ul>
<li>区间节点需要缓存什么数据？</li>
</ul>
<p>从题目可知，查询的是区间最大值，所以：</p>
<ul>
<li>父节点缓存的应该是子节点的区间最大值</li>
</ul>
<p>确定节点缓存的数据之后，开始套用模板修改代码。</p>
<hr>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>这里的区间范围有 <code>10^8</code>，比较大，不适合用简单线段树，采用动态开点会更好一些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区间最大值线段树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 父节点缓存的是子树的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxLinkSegmentTree</span> <span class="keyword">extends</span> <span class="title">LinkSegmentTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxLinkSegmentTree</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(low, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">mergeQuery</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Integer lVal, Integer rVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取左右子树中的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (lVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            max = lVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            max = Math.max(rVal, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeUp</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子节点更新后，父节点也要更新最大值</span></span><br><span class="line">        node.val = Math.max(node.left.val, node.right.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子节点都更新为 val 的话，那么所有值都会相等</span></span><br><span class="line">        <span class="comment">// 此时区间最大值就是 val</span></span><br><span class="line">        node.val = val;</span><br><span class="line">        node.add = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着按题目要求实现调用代码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">fallingSquares</span><span class="params">(<span class="keyword">int</span>[][] positions)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(positions.length);</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = (<span class="keyword">int</span>) <span class="number">1e8</span>;</span><br><span class="line">    MaxLinkSegmentTree segmentTree = <span class="keyword">new</span> MaxLinkSegmentTree(low, high);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] position : positions) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = position[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> w = position[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到区间内的最大值</span></span><br><span class="line">        <span class="keyword">int</span> maxH = segmentTree.query(x, x + w - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 堆叠新落下的方块高度</span></span><br><span class="line">        segmentTree.update(x, x + w - <span class="number">1</span>, maxH + w);</span><br><span class="line"></span><br><span class="line">        ans.add(segmentTree.query(low, high));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-LC-715-Range-模块"><a href="#6-3-LC-715-Range-模块" class="headerlink" title="6.3 LC 715. Range 模块"></a>6.3 LC 715. Range 模块</h3><blockquote>
<p>题目描述</p>
</blockquote>
<p>Range模块是跟踪数字范围的模块。</p>
<p>设计一个数据结构来跟踪表示为 半开区间 的范围并查询它们。</p>
<p>半开区间 [left, right) 表示所有 left &lt;= x &lt; right 的实数 x 。</p>
<p>实现 RangeModule 类:</p>
<p>RangeModule() 初始化数据结构的对象。</p>
<p>void addRange(int left, int right) 添加 半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。</p>
<p>boolean queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true ，否则返回 false 。</p>
<p>void removeRange(int left, int right) 停止跟踪 半开区间 [left, right) 中当前正在跟踪的每个实数。</p>
<p>提示：</p>
<ul>
<li>1 &lt;= left &lt; right &lt;= 10^9</li>
<li>在单个测试用例中，对 addRange 、queryRange 和 removeRange 的调用总数不超过 104 次</li>
</ul>
<hr>
<blockquote>
<p>问题分析</p>
</blockquote>
<p>问题已经说的很清楚了，就是区间查询和区间更新。</p>
<p>现在还需要确认一下：</p>
<ul>
<li>区间节点需要缓存什么样的数据？</li>
</ul>
<p>跟踪区间，可以理解为区间被标记了。那么可以这样来标记：</p>
<ul>
<li>区间值为 1 时：表示被跟踪了</li>
<li>区间值小于 1 时：表示未跟踪</li>
</ul>
<p>这个时候，只要查出区间内的最小值，就能知道区间是否被跟踪了。所以，</p>
<ul>
<li>父节点缓存的应该是子节点的区间最小值</li>
</ul>
<p>确定节点缓存的数据之后，开始套用模板修改。</p>
<hr>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>这里的区间范围有 <code>10^9</code>，比较大，不适合用简单线段树，采用动态开点会更好一些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区间最小值线段树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 父节点缓存的是子树的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxLinkSegmentTree</span> <span class="keyword">extends</span> <span class="title">LinkSegmentTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxLinkSegmentTree</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(low, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">mergeQuery</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Integer lVal, Integer rVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取左右子树中的最小值</span></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (lVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min = lVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min = Math.min(rVal, min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeUp</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子节点更新后，父节点也要更新最小值</span></span><br><span class="line">        node.val = Math.min(node.left.val, node.right.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeDown</span><span class="params">(Node node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子节点都更新为 val 的话，那么所有值都会相等</span></span><br><span class="line">        <span class="comment">// 此时区间最小值就是 val</span></span><br><span class="line">        node.val = val;</span><br><span class="line">        node.add = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着按照题目要求，实现其他的调用代码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> high = (<span class="keyword">int</span>) <span class="number">1e9</span>;</span><br><span class="line">    MaxLinkSegmentTree segmentTree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RangeModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        segmentTree = <span class="keyword">new</span> MinLinkSegmentTree(low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        segmentTree.update(left, right - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queryRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = segmentTree.query(left, right - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 区间最小值大于 0 表示被跟踪了</span></span><br><span class="line">        <span class="keyword">return</span> ret &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里更新的值必须使用小于 0 的整数</span></span><br><span class="line">        <span class="comment">// 不能用 0，因为懒标志用 0 表示无更新了</span></span><br><span class="line">        <span class="comment">// 设成 0 的话会导致线段树不更新数据</span></span><br><span class="line">        <span class="comment">// 相当于 0 已经被懒标志占用了，使用 0 会造成冲突</span></span><br><span class="line">        segmentTree.update(left, right - <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h3><p>上面列举了几种线段树的几种常见使用场景：</p>
<ul>
<li>区间和</li>
<li>区间最大值</li>
<li>区间最小值</li>
</ul>
<p>线段树本质就是区间缓存，所以对于：</p>
<ul>
<li>多次区间查询</li>
<li>多次区间更新</li>
</ul>
<p>就比较适用，不过具体用哪种，视情况而定。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>什么是线段树？</p>
<ul>
<li>线段树本质上是一种缓存，它缓存的是区间值</li>
<li>父节点就是子节点的缓存</li>
</ul>
<p>为什么要用线段树？</p>
<ul>
<li>通过缓存，提高多次区间查询和区间修改的性能</li>
<li>重点在于多次，多次，多次！！！</li>
</ul>
<p>线段树的实现方式？</p>
<ul>
<li>静态线段树：一开始就创建好所有节点和构建树结构</li>
<li>动态线段树：区间访问过程中动态创建节点和初始化</li>
</ul>
<p>静态线段树：</p>
<ul>
<li>简单线段树（基于数组）</li>
</ul>
<p>动态线段树：</p>
<ul>
<li>动态估点（基于数组）</li>
<li>动态开点（基于指针）</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/">https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/</a></p>
<p><a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/</a></p>
<p><a href="https://leetcode.cn/problems/falling-squares/solution/by-ac_oier-zpf0/">https://leetcode.cn/problems/falling-squares/solution/by-ac_oier-zpf0/</a></p>
<p><a href="https://www.cnblogs.com/chengmf/p/16451615.html">https://www.cnblogs.com/chengmf/p/16451615.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/algorithm/binary_search/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="一、二分查找模板"><a href="#一、二分查找模板" class="headerlink" title="一、二分查找模板"></a>一、二分查找模板</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">left = low, right = high;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (满足条件) &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在二分法中，有几个需要注意的地方：</p>
<ul>
<li>循环判定条件（<code>while</code>）</li>
<li>二分中值的计算（<code>mid</code>）</li>
<li>区间范围的收缩（<code>left</code>、<code>right</code>）</li>
</ul>
<p>这几个地方经常出问题，写错了就容易导致结果不对。</p>
<span id="more"></span>

<h2 id="二、循环判定条件"><a href="#二、循环判定条件" class="headerlink" title="二、循环判定条件"></a>二、循环判定条件</h2><p>循环判定条件可以分为 2 种：</p>
<ul>
<li><code>while (left &lt; right)</code></li>
<li><code>while (left &lt;= right)</code></li>
</ul>
<p>什么时候使用 <code>&lt;</code>？什么时候使用 <code>&lt;=</code> 呢？</p>
<h3 id="2-1-while-left-lt-right"><a href="#2-1-while-left-lt-right" class="headerlink" title="2.1 while (left &lt; right)"></a>2.1 <code>while (left &lt; right)</code></h3><p>循环结束时，满足以下情况：</p>
<ul>
<li>终止条件 <code>left == right</code></li>
<li>结果范围 <code>[low, high]</code></li>
<li>left 阈值范围 <code>[low, high]</code></li>
<li>right 阈值范围 <code>[low, high]</code></li>
</ul>
<p>当 <code>left == right</code> 时就终止循环，也就是说最后的元素是没有进入循环体内的。</p>
<p>所以，要使用这种方式</p>
<ul>
<li>最后的元素（<code>arr[left/right]</code>）就不能对返回结果造成影响</li>
</ul>
<p>满足这种要求的情况有2种：</p>
<ul>
<li>返回元素值：认定最后的元素 <code>arr[left/right]</code> 就是默认的返回结果</li>
<li>返回元素索引：默认返回的就是 <code>left</code> 或 <code>right</code> 这种边界索引</li>
</ul>
<p>满足其中之一，才能够使用 <code>while (left &lt; right)</code> 这种判定条件。</p>
<h3 id="2-2-while-left-lt-right"><a href="#2-2-while-left-lt-right" class="headerlink" title="2.2 while (left &lt;= right)"></a>2.2 <code>while (left &lt;= right)</code></h3><p>循环结束时，满足以下情况：</p>
<ul>
<li>终止条件 <code>left &gt; right</code></li>
<li>结果范围 <code>[low - 1, high + 1]</code></li>
<li>left 阈值范围 <code>[low, high + 1]</code></li>
<li>right 阈值范围 <code>[low - 1, high]</code></li>
</ul>
<p>当 <code>left &gt; right</code> 时才终止循环，就意味着所有元素都会进入循环体内。</p>
<p>所以，要使用这种方式：</p>
<ul>
<li>判断数组所有元素后，才能得到最后的返回结果</li>
</ul>
<p>满足这种要求的情况有：</p>
<ul>
<li>返回元素值：查找元素不一定在数组内，即最后的元素 <code>arr[left/right]</code> 不一定是返回结果</li>
<li>返回元素索引：返回可能是数组范围外的索引，比如 <code>low - 1</code> 或 <code>high + 1</code></li>
</ul>
<p>满足其中之一，就能使用 <code>while (left &lt;= right)</code> 这种判定条件。</p>
<h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>返回是元素值时：</p>
<ul>
<li><code>while (left &lt; right)</code>：查找元素已经明确在数组内，最后的 <code>arr[left/right]</code> 是默认结果</li>
<li><code>while (left &lt;= right)</code>：查找元素不一定在数组内，需要遍历所有数组元素</li>
</ul>
<p>返回是元素索引时：</p>
<ul>
<li><code>while (left &lt; right)</code>：查找索引明确在 <code>[low, high]</code> 内，最后的 <code>left/right</code> 是默认结果</li>
<li><code>while (left &lt;= right)</code>：可能是数组范围外的索引，比如 <code>low - 1</code> 或 <code>high + 1</code></li>
</ul>
<p>综上所述：</p>
<ul>
<li>不确定 <code>[low, high]</code> 内有满足条件的结果时，循环条件就加上 <code>=</code> 号</li>
</ul>
<h2 id="三、二分中值的计算"><a href="#三、二分中值的计算" class="headerlink" title="三、二分中值的计算"></a>三、二分中值的计算</h2><p>一般来说，二分中值的计算方式有以下几种：</p>
<ul>
<li><code>mid = (left + right) / 2</code></li>
<li><code>mid = left + (right - left) / 2</code></li>
<li><code>mid = left + ((right - left) &gt;&gt; 1)</code></li>
</ul>
<p>哪种方式比较好呢？推荐第 2 种。</p>
<p>第 1 种存在整数溢出问题，所以用的比较少。</p>
<p>第 3 种其实和第 2 种一样，从理论上说移位 <code>&gt;&gt;</code> 还比除法 <code>/</code> 快。但是由于 <code>&gt;&gt;</code> 操作符的优先级比 <code>+</code> 号低，所以需要加多一层括号。不过括号比较容易遗漏，没有第 2 种方法直观。</p>
<p>上面的计算方式是向下取整，还有一种向上取整的计算方式：</p>
<ul>
<li><code>mid = right - (right - left) / 2</code></li>
</ul>
<p>向上取整和向下取整用法是一样的，只不过是在不同场景下使用。</p>
<h2 id="四、区间范围的收缩"><a href="#四、区间范围的收缩" class="headerlink" title="四、区间范围的收缩"></a>四、区间范围的收缩</h2><p>二分法实际上就是收缩左右边界，直到找到满足条件的值为止。</p>
<p>不过区间收缩的方式有好几种，包括：</p>
<ul>
<li><code>left = mid + 1</code></li>
<li><code>right = mid - 1</code></li>
<li><code>left = mid</code></li>
<li><code>right = mid</code></li>
</ul>
<p>这几种方式可以组合成各种情况，但是用不好的话，就很容易造成死循环。</p>
<p>比如说，使用 <code>left = mid</code> 和 <code>right = mid - 1</code> 组合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt;= x) &#123;</span><br><span class="line">        left = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设此时 <code>left = 0, right = 1, arr = &#123;1, 2&#125;, x = 1</code>，那么代码就会陷入死循环。</p>
<p>死循环的原因就是左右边界没有收缩，导致一直无法达到循环结束条件。</p>
<ul>
<li>死循环都是出现在 <code>left = mid</code> 和 <code>right = mid</code> 上</li>
</ul>
<p>因为 <code>left = mid</code> 和 <code>right = mid</code> 在某些情况下可能会出现一直没有收缩区间的情况。</p>
<p>如果非要用 <code>left = mid</code> 或者 <code>right = mid</code> 的话，一定要注意边界收缩的情况，避免死循环。</p>
<p>比如说，寻找第一个等于给定值 x 的位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; x) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意满足条件和区间收缩一定不能写错，别写成上面的死循环代码。</p>
<p>这种组合方式换成 <code>left = mid + 1</code> 和 <code>right = mid - 1</code> 组合的话，可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mid == <span class="number">0</span> || arr[mid - <span class="number">1</span>] != x) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; x) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>left = mid + 1</code> 和 <code>right = mid - 1</code> 组合的话，就不会出现区间没收缩的情况。</p>
<p>从代码简洁性上看，确实是 <code>right = mid</code> 更优雅，但是写起来容易有坑。</p>
<ul>
<li>推荐全部使用 <code>left = mid + 1</code> 和 <code>right = mid - 1</code> 作为区间收缩的方式，避免死循环</li>
</ul>
<p>虽然代码没那么简洁，但是至少它问题少、逻辑清晰、容易看懂。</p>
<h2 id="五、适用场景"><a href="#五、适用场景" class="headerlink" title="五、适用场景"></a>五、适用场景</h2><ul>
<li>依赖于顺序表结构和随机访问，基本上都是数组</li>
<li>数据必须是有序的</li>
<li>不适合数据量太小，不如直接遍历来的快</li>
<li>数据量过大也不行，内存空间可能放不下整个数组，不过可以用局部二分查找</li>
</ul>
<h2 id="六、二分查找案例"><a href="#六、二分查找案例" class="headerlink" title="六、二分查找案例"></a>六、二分查找案例</h2><h3 id="6-1-第一个等于给定值的位置"><a href="#6-1-第一个等于给定值的位置" class="headerlink" title="6.1 第一个等于给定值的位置"></a>6.1 第一个等于给定值的位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || arr[mid - <span class="number">1</span>] != x) &#123;</span><br><span class="line">              <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; x) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-最后一个等于给定值的位置"><a href="#6-2-最后一个等于给定值的位置" class="headerlink" title="6.2 最后一个等于给定值的位置"></a>6.2 最后一个等于给定值的位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLastEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == n - <span class="number">1</span> || arr[mid + <span class="number">1</span>] != x) &#123;</span><br><span class="line">              <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; x) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-第一个大于等于给定值的位置"><a href="#6-3-第一个大于等于给定值的位置" class="headerlink" title="6.3 第一个大于等于给定值的位置"></a>6.3 第一个大于等于给定值的位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFirstNotLessThan</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || arr[mid - <span class="number">1</span>] &lt; x) &#123;</span><br><span class="line">              <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-最后一个小于等于给定值的位置"><a href="#6-4-最后一个小于等于给定值的位置" class="headerlink" title="6.4 最后一个小于等于给定值的位置"></a>6.4 最后一个小于等于给定值的位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLastNotGreatThan</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == n - <span class="number">1</span> || arr[mid + <span class="number">1</span>] &gt; x) &#123;</span><br><span class="line">              <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>循环判定条件，推荐使用 <code>while (left &lt;= right)</code></li>
<li>中值计算，推荐使用 <code>mid = left + (right - left) / 2</code></li>
<li>区间收缩方式，推荐全部使用 <code>left = mid + 1</code> 和 <code>right = mid - 1</code></li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>16_03_Happen-Before原则的借助</title>
    <url>/lang/java/core/concurrency/16_03_Happen-Before%E5%8E%9F%E5%88%99%E7%9A%84%E5%80%9F%E5%8A%A9/</url>
    <content><![CDATA[<h1 id="Happen-Before原则的借助"><a href="#Happen-Before原则的借助" class="headerlink" title="Happen-Before原则的借助"></a>Happen-Before原则的借助</h1><p>Happen-Before 原则可以保证变量的可见性，因此可以通过 “借助” 的方式，来间接地实现对无锁保护变量的安全性保护。</p>
<p>“借助” 技术，一般将程序次序规则和其他某个规则（比如监视器锁规则或者 volatile 变量规则）结合起来实现的。</p>
<p>这种 “借助” 技术，对于代码语句的顺序非常敏感，因此很容易出错，属于一种高级技术。</p>
<span id="more"></span>

<p>举个例子来说明一下这个技术。</p>
<h2 id="一、有并发问题的例子"><a href="#一、有并发问题的例子" class="headerlink" title="一、有并发问题的例子"></a>一、有并发问题的例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程A，先执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程B，后执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ready == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// x的值是什么，0？1？</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程 B 读到的值可能是什么呢？</p>
<p>(1) 首先，编译出来的指令可能会重排序优化</p>
<p>那么，线程 A 执行的指令代码可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，线程 A 可能先执行 ready = true，然后再执行 x = 1。</p>
<p>(2) 其次，线程 B 对于线程 A 的“影响”存在可见性问题</p>
<p>那么，线程 B 看到的情况可能有几种：</p>
<ol>
<li>没看到 ready = true（可见性问题）</li>
<li>看到了 ready = true，但是没有看到 x = 1（有序性问题）</li>
<li>看到了 ready = true，也看到了 x = 1</li>
</ol>
<p>理论上来说，只有第三种情况，才是正确的，但结果未必是这样的。</p>
<p>所以，由于存在有序性问题和可见性问题，线程 B 读到的 x 值是未知的。</p>
<h2 id="二、“借助”技术的可见性保证"><a href="#二、“借助”技术的可见性保证" class="headerlink" title="二、“借助”技术的可见性保证"></a>二、“借助”技术的可见性保证</h2><p>这里，只对上面例子中的 ready 加了 volatile 修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程A，先执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程B，后执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ready == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// x的值是什么，0？1？</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么线程 B 看到的值都是什么？</p>
<p>(1) 程序次序规则</p>
<p>首先，volatile 变量具有禁止指令重排序的语义，可以保持有序性。</p>
<p>那么在线程 A 中，操作 x = 1 就只能在操作 ready = true 之前执行。</p>
<p>依据程序顺序规则，操作 <code>x = 1</code> 先于操作 <code>ready = true</code>。</p>
<p>(2) volatile 变量规则</p>
<p>其次，对于 volatile 变量 ready，线程 A 写操作在线程 B 的读操作之前执行</p>
<p>依据 volatile 变量规则，操作 <code>ready = true</code> 也先于操作 <code>ready == true</code>。</p>
<p>(3) 传递性规则</p>
<p>最后，依据传递性规则，操作 <code>x = 1</code> 必然先于操作 <code>ready == true</code>。</p>
<p>所以，线程 B 执行到 <code>ready == true</code> 时，必然可以看到 <code>x = 1</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过间接地利用 Happen-Before 原则，可以实现无锁保护变量的可见性。</p>
<p>不过这种技术，需要很精确地控制操作的执行顺序，一不小心就很容易写错。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>16_02_Java内存模型</title>
    <url>/lang/java/core/concurrency/16_02_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="一、什么是内存模型？"><a href="#一、什么是内存模型？" class="headerlink" title="一、什么是内存模型？"></a>一、什么是内存模型？</h2><p>缓存一致性问题：</p>
<ul>
<li>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory）</li>
<li>当多处理器对同一块主内存区域进行操作时，可能会导致各自的缓存数据不一致，这就是缓存一致性问题</li>
</ul>
<span id="more"></span>

<p>内存模型：</p>
<ul>
<li>内存模型，是指在特定的操作协议下，对特定的内存或缓存进行读写访问的抽象过程</li>
<li>内存模型，定义了如何以一种安全可靠的方式去读写访问内存或缓存</li>
<li>简答来讲，内存模型规定了什么时候读入数据、什么时候写入数据、读写的顺序的等内存访问的问题</li>
</ul>
<p>缓存一致性协议: </p>
<ul>
<li>为了解决缓存一致性问题，内存模型就需要引入一些缓存一致性协议，比如 MSI、MESI、MOSI 等</li>
<li>缓存一致性协议，并不是针对某种内存模型，而是一种通用的缓存同步规范</li>
<li>Java 内存模型，是 JVM 定义的一个内存模型，使用的缓存一致性协议是 MESI 协议</li>
</ul>
<h2 id="二、为什么要有内存模型？"><a href="#二、为什么要有内存模型？" class="headerlink" title="二、为什么要有内存模型？"></a>二、为什么要有内存模型？</h2><p>定义 Java 内存模型的目的：</p>
<ul>
<li>屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果</li>
</ul>
<p>定义Java内存模型的好处：</p>
<ul>
<li>Java 内存模型统一了底层不同架构平台上内存模型的接口</li>
<li>程序无需关注运行平台的差异，只需要关注 Java 内存模型提供了怎么样的内存保证</li>
<li>程序不用去考虑底层访问的性能问题，由 JVM 负责去优化，JVM 会根据硬件的特性去优化执行速度</li>
</ul>
<p>比如说，Java 内存模型保证了 volatile 变量的写入是对所有线程可见的。</p>
<p>程序员只需知道 volatile 变量是所有线程可见的即可，至于内存模型底层是怎么实现的，用的时候无需了解。</p>
<h2 id="三、Java-内存模型的设计"><a href="#三、Java-内存模型的设计" class="headerlink" title="三、Java 内存模型的设计"></a>三、Java 内存模型的设计</h2><h3 id="3-1-内存层次划分"><a href="#3-1-内存层次划分" class="headerlink" title="3.1 内存层次划分"></a>3.1 内存层次划分</h3><p>内存层次：</p>
<ul>
<li>主内存（Main Memory）：主内存只有一个，所有变量数据都存储在主内存中</li>
<li>工作内存（Working Memory）：每条线程都有自己的工作内存，使用的变量都是主内存变量的一份拷贝</li>
</ul>
<p>内存操作：</p>
<ul>
<li>线程对变量的所有操作（读取、赋值等）都是在自己的工作内存中进行</li>
<li>不同线程之间不能直接访问对方工作内存中的变量</li>
<li>线程之间的变量值共享，只能通过主内存来完成</li>
</ul>
<h3 id="3-2-内存间的交互操作"><a href="#3-2-内存间的交互操作" class="headerlink" title="3.2 内存间的交互操作"></a>3.2 内存间的交互操作</h3><p>内存交互问题：</p>
<ul>
<li>变量如何从主内存拷贝到工作内存？</li>
<li>变量如何从工作内存同步回主内存？</li>
</ul>
<p>原子操作：</p>
<ul>
<li>lock（锁定）：作用于主内存变量，锁定主内存中的变量，防止其他线程访问</li>
<li>read（读取）：作用于主内存变量，读取主内存中的变量</li>
<li>load（加载）：作用于工作内存变量，将 read 拿到的变量，拷贝到工作内存中</li>
<li>use（使用）：作用于工作内存变量，使用工作内存中的变量</li>
<li>assign（赋值）：作用于工作内存变量，对工作内存的变量进行赋值</li>
<li>store（存储）：作用于工作内存变量，将工作内存的变量传送到主内存</li>
<li>write（写入）：作用于主内存变量，将 store 传送出来的变量写入主内存变量</li>
<li>unlock（解锁）：作用于主内存变量，将主内存中变量的锁定状态解除</li>
</ul>
<p>执行规则：</p>
<ul>
<li>一个新的变量，只能在主内存中“诞生”</li>
<li>不允许 read 和 load、store 和 write 操作之一单独出现</li>
<li>一个变量在同一时刻只允许一条线程对其进行 lock 操作</li>
<li>对一个变量执行 lock 操作，那将会清空工作内存中此变量的值</li>
<li>对变量执行 unlock 操作前，必须先把此变量同步回主内存中</li>
</ul>
<h3 id="3-3-内存模型的并发设计"><a href="#3-3-内存模型的并发设计" class="headerlink" title="3.3 内存模型的并发设计"></a>3.3 内存模型的并发设计</h3><p>针对并发中出现的原子性、可见性、有序性问题，内存模型给了多种并发保证方式，来确保它们的安全性。</p>
<h4 id="3-3-1-内存指令的并发保证"><a href="#3-3-1-内存指令的并发保证" class="headerlink" title="3.3.1 内存指令的并发保证"></a>3.3.1 内存指令的并发保证</h4><p>(1) 原子性：</p>
<ul>
<li>由 Java 内存模型直接保证的原子性操作包括 read、load、use、assign、store、write</li>
<li>更大范围的原子性操作，Java 内存模型还提供了 lock 和 unlock 来满足</li>
</ul>
<p>(2) 可见性：</p>
<ul>
<li>Java 内存模型依赖于主内存作为传递媒介，来实现可见性：<ul>
<li>写入变量后，将值同步刷新回主内存，比如通过 unlock 操作实现</li>
<li>读取变量前，从主内存中获取最新值，比如通过 lock 操作实现</li>
</ul>
</li>
<li>一个线程的操作结果对于另一个线程可见，那必然是经过了主内存的传递</li>
</ul>
<p>(3) 有序性：</p>
<ul>
<li>Java 内存模型是通过按需禁止重排序来避免有序性问题的</li>
<li>通过底层指令集的某些指令来禁止重排序，Java 语言层面可以使用 volatile 关键字</li>
</ul>
<h4 id="3-3-2-关键字的并发保证"><a href="#3-3-2-关键字的并发保证" class="headerlink" title="3.3.2 关键字的并发保证"></a>3.3.2 关键字的并发保证</h4><p>Java 语言中的并发关键字包括 synchronized、volatile、final。</p>
<p>(1) synchronized：</p>
<ul>
<li>可以保证原子性、可见性、有序性</li>
<li>原子性：由“一个变量在同一时刻只允许一条线程对其进行 lock 操作”规则保证</li>
<li>可见性：由“对变量执行 unlock 操作前，必须先把此变量同步回主内存中”规则保证</li>
<li>有序性：由“一个变量在同一时刻只允许一条线程对其进行 lock 操作”规则保证，这条规则决定了持有同一个锁的两个同步块只能串行地进入</li>
</ul>
<p>(2) volatile：</p>
<ul>
<li>可以保证可见性和有序性</li>
<li>可见性：volatile 变量保证了新值可以立即同步回主内存中，以及每次使用前立即从主内存中刷新</li>
<li>有序性：volatile 关键字本身设计就包含了禁止指令重排序地语义</li>
</ul>
<p>(3) final：</p>
<ul>
<li>可以保证可见性</li>
<li>可见性：被 final 修饰的字段，在构造器中一旦正确安全初始化完成后（安全发布），就保证了它的可见性</li>
</ul>
<p>并发关键字可以让程序自己选择是否要控制可见性和有序性。</p>
<h4 id="3-3-3-先行发生原则（happens-before）的并发保证"><a href="#3-3-3-先行发生原则（happens-before）的并发保证" class="headerlink" title="3.3.3 先行发生原则（happens-before）的并发保证"></a>3.3.3 先行发生原则（happens-before）的并发保证</h4><p>Java 内存模型为了保证可见性和有序性，规定了一种先行发生原则（happens-before）。</p>
<p>先行发生原则定义：</p>
<ul>
<li>想要保证执行操作 B 的线程，能够看到执行操作 A 的结果，A 和 B 必须满足 Happen-Before 原则</li>
<li>如果操作 A 发生于操作 B 之前，那么操作 A 产生的“影响”就能被执行操作 B 的线程所观察到</li>
<li>其中“影响”包括：修改了内存中共享变量的值、发送了消息、调用了方法等</li>
</ul>
<p>先行发生原则特点：</p>
<ul>
<li>操作 A 先行发生于操作 B，这里先行是指时间顺序上的先行发生</li>
<li>前一个操作的“影响”对后续操作是可见的。比如修改了内存中共享变量的值</li>
</ul>
<p>先行发生规则：</p>
<ul>
<li>程序次序规则（Program Order Rule）：一个线程内，保证程序语义的串行性</li>
<li>管程锁定规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作（必须是同一个锁）</li>
<li>volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量，对于它的写操作先行发生于后面对它的读操作</li>
<li>线程启动规则（Thread Start Rule）：Thread 对象的 start() 方法先行发生于此线程的每一个动作</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作，都先行于对于此线程的终止检测</li>
<li>线程中断规则（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于对此线程的中断检测</li>
<li>对象终结规则（Object Termination Rule）：对象的初始化完成（构造函数执行结束）先行发生于它的 finallize() 方法的开始</li>
<li>传递性规则（Transitivity Rule）：如果 A 先行于 B，B 先行于 C，那么 A 先行于 C</li>
</ul>
<p>举几个例子：</p>
<p>(1) 管程锁定规则</p>
<p>管程锁定规则，规定了 unlock 操作先行发生于 lock 操作。</p>
<p>也就是说，上一个 unlock 操作之前产生的“影响”，对于下一个 lock 操作是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程 A</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 此处自动加锁 lock</span></span><br><span class="line">  <span class="comment">// count 是共享变量</span></span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">// 此处自动解锁 unlock</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 B </span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 此处会执行 lock 操作</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.count == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 管程锁定规则可以确保看到 count 变量的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 此处会执行 unlock 操作</span></span><br></pre></td></tr></table></figure>

<p>假设线程 A 先拿到锁，对 count 变量进行了修改，得到 count = 1，然后执行 unlock 操作退出加锁区域。</p>
<p>接着线程 B 再执行 lock 操作去获取锁，线程 A 的 unlock 操作先于线程 B 的 lock 操作执行。</p>
<p>依据管程锁定规则，那么线程 B 就能看到线程 A 的修改，也就是线程 B 内可以看到 count = 1。</p>
<p>(2) 线程启动规则</p>
<p>线程启动规则，规定了 Thread 对象的 start() 方法先行发生于此线程的每一个动作。</p>
<p>也就是说，在 Thread 对象的 start() 方法执行前所产生的“影响”，线程内都是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Thread B = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="comment">// 主线程调用B.start()之前</span></span><br><span class="line">  <span class="comment">// 所有对共享变量的修改，此处皆可见</span></span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 线程启动规则可以保证能进入到这里</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对共享变量var修改</span></span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count &gt; 0 是为了确保 count = 1 在 B.start(); 之前执行（程序次序规则）</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 主线程启动子线程</span></span><br><span class="line">  B.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程在启动子线程 B 的 start() 方法前的操作，即 count = 1，对于线程 B 内而言，是可见的。</p>
<p>也就是，主线程对 count 的修改，先行于线程 B 的 start() 方法，那么线程 B 内部就可以看到修改的结果。</p>
<h4 id="3-3-4-初始化安全性的并发保证"><a href="#3-3-4-初始化安全性的并发保证" class="headerlink" title="3.3.4 初始化安全性的并发保证"></a>3.3.4 初始化安全性的并发保证</h4><p>内存模型还提供了一些在对象初始化方面的并发保证：</p>
<ul>
<li>静态初始化器，可以保证对所有线程具有可见性</li>
<li>对于被正确构造的对象，所有线程都能看到构造函数给 final 域设置的值，包括 final 域引用对象内可达的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeStates</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; states;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        states = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        states.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        states.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        states.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，由 SafeStates 创建的对象，它里面的 object 和 states，对于所有线程而言，都是可见的。</p>
<p>而且，states 里面的值 <code>1</code>、<code>2</code>、<code>3</code> 对所有线程也是可见的。</p>
<p>但是，初始化安全性的保证，只保证对象在初始化阶段是安全可见的。</p>
<p>如果后面改变的了对象的值，比如在构造函数外执行 <code>state.put(&quot;4&quot;, &quot;d&quot;)</code>，这个值的可见性就无法保证，必须采用同步。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>16_01_并发问题来源</title>
    <url>/lang/java/core/concurrency/16_01_%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90/</url>
    <content><![CDATA[<h1 id="并发问题来源"><a href="#并发问题来源" class="headerlink" title="并发问题来源"></a>并发问题来源</h1><h1 id="一、缓存带来的可见性问题"><a href="#一、缓存带来的可见性问题" class="headerlink" title="一、缓存带来的可见性问题"></a>一、缓存带来的可见性问题</h1><ul>
<li>计算机中可以保存数据的地方有几个：寄存器、缓存、主内存</li>
<li>原始数据都保存在主存上，最初的读取和最终的写入，都是在主存上操作</li>
<li>CPU 与主存之间存在缓存，每个 CPU 都有自己独立的的缓存</li>
<li>操作数据时，首先要将原始数据从主存中读取到 CPU 的缓存中，然后再对缓存的数据进行操作</li>
<li>单 CPU 下，一个线程对缓存的修改，对于另一个线程来说是可见的，因为只有一个缓存</li>
<li>多 CPU 下，线程可能运行在不同 CPU 上，操作的是各自不同的缓存，相互之间是不可见的</li>
</ul>
<span id="more"></span>

<p>比如，主存中一个变量 count = 1；</p>
<p>线程 A 在 CPU1 上运行，读取 count 到缓存 Cache1，然后执行 count++;</p>
<p>线程 B 在 CPU2 上运行，也读取 count 缓存 Cache2，然后执行 count++;</p>
<p>假如 A 和 B 是同时读取的 count，它们拿到后都是 1，接着执行了 count++ 后，结果都变成了 2。</p>
<p>最后线程 A 和线程 B 同步变量到主存后，count 的值最终只会是 2，但是理论上应该是 3 才对。</p>
<p>这都是因为线程 A 和线程 B 各自只在自己的缓存上操作数据，相互不可见，导致没有意识到 count 被改了。</p>
<h1 id="二、任务切换带来的原子性问题"><a href="#二、任务切换带来的原子性问题" class="headerlink" title="二、任务切换带来的原子性问题"></a>二、任务切换带来的原子性问题</h1><ul>
<li>一个线程任务不可能长期占用 CPU，每隔一段时间，就需要切换线程任务</li>
<li>线程任务切换一般采用时间片作为单位，比如 50 毫秒一个时间片</li>
<li>线程在执行1个或多个时间片后，就可能会被切换到其他线程任务</li>
<li>如果后面的线程修改了之前线程的数据，那等下次轮到之前线程执行时，它的状态就可能会和它之前被切换前的状态不一致，继续执行下去就有可能出现并发问题</li>
</ul>
<p>比如 long 变量是 64 位。</p>
<p>线程 A 刚加载了它的前 32 位数据，就被切换走了，开始执行线程 B。</p>
<p>然后线程 B 把变量值改了，写了新值进去，然后又切换回线程 A 执行。</p>
<p>此时线程 A 去加载后 32 位时，数据已经和之前的不一样了。</p>
<p>最终，旧值的前 32 位 + 新值的后 32 位，这 2 个 32 位拼起来的 64 位就会是一个意料之外的值。</p>
<h1 id="三、指令重排带来的有序性问题"><a href="#三、指令重排带来的有序性问题" class="headerlink" title="三、指令重排带来的有序性问题"></a>三、指令重排带来的有序性问题</h1><ul>
<li>编译器生成的指令顺序，可能会和源代码的顺序不同，因为它会对代码进行优化，以便提高执行效率</li>
<li>处理器可以采用乱序或并行的方式来执行指令，比如指令流水线，所以也不一定是按照编译器生成的指令顺序来执行</li>
<li>缓存变量提交到主内存的次序可能会改变，即缓存中先写的变量，不一定会被先提交到主内存中</li>
</ul>
<p>比如下面可能会出现重排序的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PossibleReordering</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">            x = b; <span class="comment">// 2</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            b = <span class="number">1</span>; <span class="comment">// 3</span></span><br><span class="line">            y = a; <span class="comment">// 4</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        one.start();</span><br><span class="line">        other.start();</span><br><span class="line"></span><br><span class="line">        one.join();</span><br><span class="line">        other.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;(&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每个线程中的各个操作没有数据流依赖性，所以这些操作可以乱序执行。</p>
<p>也就是说，1和2之间没有依赖关系，所以重排序后2可能比1先执行；同理，4也可能比3先执行。</p>
<p>因此，输出的结果就可能有4种：</p>
<ul>
<li>(0, 1)</li>
<li>(1, 0)</li>
<li>(1, 1)</li>
<li>(0, 0)</li>
</ul>
<p>其中，(0, 0) 就是由于指令重排引起的，重排后的执行顺序可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间线&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">线程A       x=b;                    a=1;</span><br><span class="line"></span><br><span class="line">线程B               b=1;    y=a;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>15_02_原子变量</title>
    <url>/lang/java/core/concurrency/15_02_%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h1><h2 id="一、原子变量类"><a href="#一、原子变量类" class="headerlink" title="一、原子变量类"></a>一、原子变量类</h2><p>原子变量类相当于是一种泛化的 volatile 变量，能够支持原子和有条件的读写操作。</p>
<h3 id="1-1-原子类型"><a href="#1-1-原子类型" class="headerlink" title="1.1 原子类型"></a>1.1 原子类型</h3><ul>
<li>标量类：AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference</li>
<li>数组类：AtomicIntegerArray、AtomicLongArray、AtomicBooleanArray</li>
<li>更新器类：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicBooleanFieldUpdater</li>
<li>复合变量类：AtomicMarkableReference</li>
</ul>
<span id="more"></span>

<h3 id="1-2-性能比较"><a href="#1-2-性能比较" class="headerlink" title="1.2 性能比较"></a>1.2 性能比较</h3><ul>
<li>原子变量比锁的粒度更细、量级更轻</li>
<li>原子变量将发生竞争的范围缩小至单个变量上</li>
<li>原子变量通常会更快，因为它不需要挂起或重新调度线程</li>
<li>在高度竞争的情况下，锁的性能会比原子变量更好，原因是锁会挂起线程，避免了很多线程上下文切换</li>
<li>在中低竞争的情况下，原子变量能提供更高的可伸缩性</li>
</ul>
<h2 id="二、非阻塞算法"><a href="#二、非阻塞算法" class="headerlink" title="二、非阻塞算法"></a>二、非阻塞算法</h2><ul>
<li>非阻塞的计数器：单状态</li>
<li>非阻塞的数字区域：单不可变对象，包含多状态</li>
<li>非阻塞的栈：单状态</li>
<li>非阻塞的队列：多状态</li>
</ul>
<h3 id="2-1-非阻塞的计数器"><a href="#2-1-非阻塞的计数器" class="headerlink" title="2.1 非阻塞的计数器"></a>2.1 非阻塞的计数器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《并发编程实战》-第15章</span></span><br><span class="line"><span class="comment"> * 基于 CAS 实现的非阻塞计数器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/4/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimulatedCAS value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = value.get();</span><br><span class="line">        &#125; <span class="keyword">while</span> (v != value.compareAndSwap(v, v + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-非阻塞的数字区域"><a href="#2-2-非阻塞的数字区域" class="headerlink" title="2.2 非阻塞的数字区域"></a>2.2 非阻塞的数字区域</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《并发编程实战》-第15章</span></span><br><span class="line"><span class="comment"> *  原子变量 + 不可变对象实现多状态更新</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/4/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasNumberRange</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不变性条件：lower &lt;= upper</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lower;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> upper;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IntPair</span><span class="params">(<span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lower = lower;</span><br><span class="line">            <span class="keyword">this</span>.upper = upper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;IntPair&gt; values = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">new</span> IntPair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values.get().lower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUpper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values.get().upper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            IntPair oldValue = values.get();</span><br><span class="line">            <span class="keyword">if</span> (i &gt; oldValue.upper) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Can&#x27;t set lower to &quot;</span> + i + <span class="string">&quot; &gt; upper&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            IntPair newValue = <span class="keyword">new</span> IntPair(i, oldValue.upper);</span><br><span class="line">            <span class="keyword">if</span> (values.compareAndSet(oldValue,newValue)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            IntPair oldValue = values.get();</span><br><span class="line">            <span class="keyword">if</span> (i &lt; oldValue.lower) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Can&#x27;t set upper to &quot;</span> + i + <span class="string">&quot; &lt; lower&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            IntPair newValue = <span class="keyword">new</span> IntPair(oldValue.lower, i);</span><br><span class="line">            <span class="keyword">if</span> (values.compareAndSet(oldValue,newValue)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-非阻塞的栈"><a href="#2-2-非阻塞的栈" class="headerlink" title="2.2 非阻塞的栈"></a>2.2 非阻塞的栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *《并发编程实战》-第15章</span></span><br><span class="line"><span class="comment"> * 非阻塞栈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/4/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&lt;E&gt;&gt; top = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; newTop = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">        Node&lt;E&gt; oldTop;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldTop = top.get();</span><br><span class="line">            newTop.next = oldTop;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldTop, newTop));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; oldTop;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldTop = top.get();</span><br><span class="line">            <span class="keyword">if</span> (oldTop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldTop, oldTop.next));</span><br><span class="line">        oldTop.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> oldTop.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> E item;</span><br><span class="line">        <span class="keyword">public</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-非阻塞的队列"><a href="#2-3-非阻塞的队列" class="headerlink" title="2.3 非阻塞的队列"></a>2.3 非阻塞的队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *《并发编程实战》-第15章</span></span><br><span class="line"><span class="comment"> * 非阻塞链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; dummy = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; head = <span class="keyword">new</span> AtomicReference&lt;&gt;(dummy);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; tail = <span class="keyword">new</span> AtomicReference&lt;&gt;(dummy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 推入队列尾部</span></span><br><span class="line"><span class="comment">     * 分 2 步 CAS：</span></span><br><span class="line"><span class="comment">     * 1. 设置 tail.next 为 newNode</span></span><br><span class="line"><span class="comment">     * 2. 设置 tail 为 tail.next</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(item, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Node&lt;E&gt; curTail = tail.get();</span><br><span class="line">            Node&lt;E&gt; next = curTail.next.get();</span><br><span class="line">            <span class="keyword">if</span> (curTail != tail.get()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 中间态，可能成功或失败</span></span><br><span class="line">                <span class="comment">// 2. 设置 tail 为 tail.next</span></span><br><span class="line">                tail.compareAndSet(curTail, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 设置 tail.next 为新增加的 item</span></span><br><span class="line">                <span class="keyword">if</span> (curTail.next.compareAndSet(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                    <span class="comment">// 中间态，可能成功或失败</span></span><br><span class="line">                    <span class="comment">// 2. 设置 tail 为 tail.next</span></span><br><span class="line">                    tail.compareAndSet(curTail, newNode);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// head 是一个哨兵节点，下一个节点才是数据</span></span><br><span class="line">            Node&lt;E&gt; curHead = head.get();</span><br><span class="line">            Node&lt;E&gt; firstNode = curHead.next.get();</span><br><span class="line">            <span class="keyword">if</span> (firstNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;E&gt; secondNode = firstNode.next.get();</span><br><span class="line">            <span class="keyword">if</span> (curHead.next.compareAndSet(firstNode, secondNode)) &#123;</span><br><span class="line">                firstNode.next.set(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> firstNode.item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E item;</span><br><span class="line">        <span class="keyword">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">new</span> AtomicReference&lt;&gt;(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>15_01_CAS操作</title>
    <url>/lang/java/core/concurrency/15_01_CAS%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="CAS-操作"><a href="#CAS-操作" class="headerlink" title="CAS 操作"></a>CAS 操作</h1><h2 id="一、锁的劣势"><a href="#一、锁的劣势" class="headerlink" title="一、锁的劣势"></a>一、锁的劣势</h2><ul>
<li>采用独占的方式访问锁的守护变量</li>
<li>获取锁，存在挂起和恢复线程的问题，这些操作都比较耗时</li>
<li>等待锁时，线程不能做其他的事情</li>
<li>容易出现活跃性故障，比如死锁、活锁等</li>
<li>锁竞争激烈时，线程调度开销会非常大</li>
</ul>
<span id="more"></span>

<h2 id="二、CAS-操作"><a href="#二、CAS-操作" class="headerlink" title="二、CAS 操作"></a>二、CAS 操作</h2><h3 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h3><p>基本原理：</p>
<ol>
<li>CAS 包含3个操作数：内存原值 V，期望旧值 A，写入新值 B</li>
<li>当且仅当 V == A 时，才能将 V 更新为 B</li>
</ol>
<p>简单地说，就是当 V == A 时，CAS 就认为没有其他线程修改过内存值 V，可以直接写入新值。</p>
<ul>
<li>当多线程竞争同一个 CAS 时，只有其中一个线程可以成功，其他线程均失败</li>
</ul>
<p>用代码模拟 CAS 操作大概如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulatedCAS</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line">        <span class="keyword">if</span> (oldValue == expectValue) &#123;</span><br><span class="line">            value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (expectValue == compareAndSwap(expectValue, newValue));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上 CAS 操作会由底层的 JVM 或操作系统实现，是一种原子操作。</p>
<p>CAS 的使用模式通常是这样的：</p>
<ol>
<li>首先从内存 V 中读取到值 A，此时 V == A</li>
<li>然后根据 A 计算得到新值 B</li>
<li>接着通过 CAS 以原子方式将 V 的值更新为 B</li>
<li>如果 CAS 成功，则返回；否则一般都需要重新执行 CAS</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    A = V;</span><br><span class="line">    B = A + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (CAS(V, A, B)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 CAS 时，一般都是循环执行代码，直到 CAS 成功为止。</p>
<h3 id="2-2-硬件支持"><a href="#2-2-硬件支持" class="headerlink" title="2.2 硬件支持"></a>2.2 硬件支持</h3><p>在多处理器架构中，一般都提供有一些特殊指令，用于管理对共享数据的并发访问：</p>
<ul>
<li>Test-and-Set（测试并设置）</li>
<li>Fetch-and-Increment（获取并递增）</li>
<li>Compare-and-Swap（比较并交换）</li>
<li>Load-Linked（加载链接）</li>
<li>Store-Conditional（存储条件）</li>
</ul>
<p>这些特殊指令，提供了某种形式的“原子“读写操作，可以安全地访问共享数据。</p>
<h3 id="2-3-JVM-支持"><a href="#2-3-JVM-支持" class="headerlink" title="2.3 JVM 支持"></a>2.3 JVM 支持</h3><p>硬件指令虽然提供了 CAS 的实现，但是在 Java 代码中是不能直接使用硬件指令的。</p>
<p>所以 JVM 会将 CAS 代码编译成底层硬件提供的最有效方法：</p>
<ul>
<li>在支持 CAS 的平台上，JVM 会将 CAS 代码编译为相应的（多条）机器指令</li>
<li>在不支持 CAS 的平台上，JVM 将会使用自旋锁来代替 CAS 操作</li>
</ul>
<p>JVM 为 Java 代码执行 CAS 操作提供了底层的支持。</p>
<h3 id="2-4-锁和-CAS-的区别"><a href="#2-4-锁和-CAS-的区别" class="headerlink" title="2.4 锁和 CAS 的区别"></a>2.4 锁和 CAS 的区别</h3><ul>
<li>独占锁是一项悲观技术；而 CAS 是一项乐观的技术</li>
<li>获取锁失败时，线程会阻塞挂起；而竞争 CAS 失败时，线程不会阻塞，而是直接返回</li>
<li>锁的获取可能导致操作系统级别的锁定、线程挂起以及上下文切换等；而 CAS 操作不会</li>
<li>锁可以自动处理竞争问题（JVM 实现）；而 CAS 需要由调用者处理竞争问题（循环 CAS 直到成功）</li>
<li>锁定时，至少需要一次 CAS，所以锁的开销基本都会比 CAS 大</li>
<li>竞争激烈时，锁的性能会更好；而竞争不激烈时，CAS 的性能会更好</li>
<li>竞争激烈时，CAS 会导致很多线程空自旋等待，浪费 CPU 资源</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>14_条件队列</title>
    <url>/lang/java/core/concurrency/14_%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h1><h2 id="一、状态依赖性管理"><a href="#一、状态依赖性管理" class="headerlink" title="一、状态依赖性管理"></a>一、状态依赖性管理</h2><h3 id="1-1、前提条件"><a href="#1-1、前提条件" class="headerlink" title="1.1、前提条件"></a>1.1、前提条件</h3><p>类中一般有很多依赖于状态的方法，只有满足某些条件时才能正常执行。</p>
<p>比如说，在有界队列中的方法：</p>
<ul>
<li><code>put</code> 方法调用前，必须满足 <code>!isFull()</code> 条件</li>
<li><code>take</code> 方法调用前，必须满足 <code>!isEmpty()</code> 条件</li>
</ul>
<p>像  <code>!isFull()</code>、<code>!isEmpty()</code> 这种被操作依赖的状态条件，称为前提条件。</p>
<span id="more"></span>

<p>前提条件中可能包含一个或多个状态变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前提条件 <code>isEmpty()</code> 这里就包含了一个状态变量：<code>size</code>。</p>
<h3 id="1-2-前提条件的处理"><a href="#1-2-前提条件的处理" class="headerlink" title="1.2 前提条件的处理"></a>1.2 前提条件的处理</h3><p>对于单线程程序而言，当前提条件不满足时，都是直接从该方法返回；</p>
<p>但是对于并发程序而言，前提条件不满足的情况下，可以有其他选择方案：</p>
<ul>
<li>前提条件失败，可以直接返回</li>
<li>前提条件失败，可以一直等待条件变为真</li>
</ul>
<p>并发程序中，前提条件可以等待的要求就是：线程之间共享状态变量。</p>
<ul>
<li>线程在等待前提条件变为真，而变为真的情况只能是被其他线程修改了状态变量</li>
</ul>
<p>因此，对于前提条件的要求如下：</p>
<ul>
<li>前提条件中涉及的状态变量，必须由对象的锁来保护，否则会有线程安全性问题</li>
<li>等待前提条件变为真的线程，必须释放对象的锁，否则其他线程无法修改状态变量</li>
</ul>
<p>前提条件的等待实现，有2种方式：</p>
<ul>
<li>非阻塞的轮询</li>
<li>阻塞的等待</li>
</ul>
<h2 id="二、非阻塞的轮询"><a href="#二、非阻塞的轮询" class="headerlink" title="二、非阻塞的轮询"></a>二、非阻塞的轮询</h2><h3 id="2-1-将前提条件的失败传递给调用者"><a href="#2-1-将前提条件的失败传递给调用者" class="headerlink" title="2.1 将前提条件的失败传递给调用者"></a>2.1 将前提条件的失败传递给调用者</h3><p>前提条件失败，最简单的处理方式就是：直接返回失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    doPut(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前提条件失败后，调用者将收到异常。</p>
<p>但是，如果调用者想要一直等待到前提条件变为真，就必须自己处理异常和重试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        put(item);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        <span class="comment">// 等待前提条件变为真</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式称为忙等待或者自旋等待，会消耗大量的 CPU 时间。</p>
<p>不过，这种方式还可以使用休眠来进行优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        put(item);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        <span class="comment">// 休眠一会，避免消耗大量的 CPU 时间</span></span><br><span class="line">        Thread.sleep(SLEEP_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但存在一个问题，休眠可能会导致系统的响应性变差。</p>
<p>因为在休眠期间，前提条件可能变为真了，但是线程还处于休眠状态，无法执行。</p>
<h3 id="2-2-通过轮询与休眠来实现简单的阻塞"><a href="#2-2-通过轮询与休眠来实现简单的阻塞" class="headerlink" title="2.2 通过轮询与休眠来实现简单的阻塞"></a>2.2 通过轮询与休眠来实现简单的阻塞</h3><p>由调用者来负责处理异常和重试，调用的代码会变得非常复杂。</p>
<p>为了减低调用者的代码重复率和复杂度，可以将重试移入方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isFull()) &#123;</span><br><span class="line">                doPut(item);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 休眠一会，避免消耗大量的 CPU 时间</span></span><br><span class="line">        Thread.sleep(SLEEP_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将代码迁入方法内后，调用者那边就变简单了，只需要调用接口即可。</p>
<p>不过这种方式依旧存在响应性问题。</p>
<h3 id="2-3-非阻塞方式的弊端"><a href="#2-3-非阻塞方式的弊端" class="headerlink" title="2.3 非阻塞方式的弊端"></a>2.3 非阻塞方式的弊端</h3><p>非阻塞方式实现的前提条件等待弊端有：</p>
<ul>
<li>自旋等待会消耗大量的 CPU 时间</li>
<li>定时休眠会导致系统的响应性变差</li>
</ul>
<p>每次失败都会休眠一段时间，如果休眠期间前提条件变为真了，但还是要等休眠结束后，才会继续执行。</p>
<h2 id="三、阻塞的条件队列"><a href="#三、阻塞的条件队列" class="headerlink" title="三、阻塞的条件队列"></a>三、阻塞的条件队列</h2><h3 id="3-1-条件队列"><a href="#3-1-条件队列" class="headerlink" title="3.1 条件队列"></a>3.1 条件队列</h3><p>条件队列是通过一种等待-通知的方式，用来解决非阻塞方式的弊端。</p>
<ul>
<li>当前提条件失败时，线程进入阻塞等待状态</li>
<li>当前提条件满足后（其他线程修改状态后），通知唤醒等待线程</li>
</ul>
<p>通过等待-通知的方式，避免了自旋等待和定时休眠的问题。</p>
<p>实际上，等待-通知方式的原理就是：</p>
<ul>
<li>阻塞等待时，将当前线程放入锁对象的一个队列中</li>
<li>通知唤醒时，从锁对象队列中取出一个或多个线程，让它们继续执行</li>
</ul>
<p>在等待-通知过程中用到的队列，就称为条件队列。</p>
<h3 id="3-2-条件谓词（前提条件）"><a href="#3-2-条件谓词（前提条件）" class="headerlink" title="3.2 条件谓词（前提条件）"></a>3.2 条件谓词（前提条件）</h3><p>条件谓词，就是指的被某个操作依赖的前提条件，它是由类中各个状态变量构成的表达式。</p>
<p>比如条件谓词（前提条件） <code>isEmpty()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用到的状态变量就是 <code>size</code>。</p>
<p>在设计一个依赖于状态的类时，必须找出类中的条件谓词和依赖于条件谓词的操作。</p>
<p>比如之前提到的：</p>
<ul>
<li>依赖操作：<code>put()</code>、<code>take()</code></li>
<li>条件谓词：<code>isEmpty()</code>、<code>isFull()</code></li>
<li>状态变量：<code>size</code></li>
</ul>
<p>统计完后，这些操作中涉及到的条件谓词、变量代码都需要加锁处理。</p>
<h3 id="3-3-内置条件队列"><a href="#3-3-内置条件队列" class="headerlink" title="3.3 内置条件队列"></a>3.3 内置条件队列</h3><p>在 Java 中，每个对象都内置有一个条件队列。</p>
<p>操作内置条件队列，需要执行特定的方法。比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line">            wait(); <span class="comment">// 进入内置条件队列阻塞等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        doPut(item);</span><br><span class="line">        notifyAll(); <span class="comment">// 通知唤醒内置条件队列中的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行 <code>wait()</code> 方法之后，实际上就会进入 <code>this</code> 对象的内置条件队列。</p>
<p>而执行 <code>notifyAll()</code> 方法之后，就会唤醒所有在内置条件队列中的线程。</p>
<p>内置条件队列，底层是由 JVM 来实现和维护的，所以无需写 Java 代码去管理。</p>
<h3 id="3-4-显式条件队列"><a href="#3-4-显式条件队列" class="headerlink" title="3.4 显式条件队列"></a>3.4 显式条件队列</h3><p>除了内置锁，Java 中还提供了显式锁 Lock，它的作用和内置锁是一样的。</p>
<p>显式锁也有自己的条件队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line">            lock.await(); <span class="comment">// 进入显式条件队列阻塞等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        doPut(item);</span><br><span class="line">        lock.signalAll(); <span class="comment">// 通知唤醒显式条件队列中的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显式条件队列和内置条件队列的区别是：</p>
<ul>
<li>内置条件队列，是由 JVM 来实现和维护的；而显式锁的条件队列是由锁类自己实现的</li>
<li>内置条件队列，只能有一个；而显式锁的条件队列可以有多个</li>
<li>内置锁的条件等待是不可中断的；而显示锁的条件等待是可以中断的</li>
<li>内置的条件队列是非公平的；而显式的条件队列提供了公平和非公平两种方式</li>
</ul>
<p>比如说，显示锁支持多个条件队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line"><span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line">            notFull.await(); <span class="comment">// notFull 条件队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        doPut(item);</span><br><span class="line">        notEmpty.signalAll(); <span class="comment">// notEmpty 条件队列</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就用了 2 个显式条件队列，分别是 <code>notFull</code> 和 <code>notEmpty</code>。</p>
<h3 id="3-5-条件队列和轮询"><a href="#3-5-条件队列和轮询" class="headerlink" title="3.5 条件队列和轮询"></a>3.5 条件队列和轮询</h3><p>阻塞的条件队列和非阻塞的轮询，在本质上还是一样的：</p>
<ul>
<li>条件队列并没有改变轮询的语义</li>
<li>条件队列只是对轮询进行了优化：CPU 效率、上下文切换开销和响应性</li>
</ul>
<p>条件队列只是使得前提条件的等待方式变得更高效了。</p>
<h2 id="四、条件队列的使用"><a href="#四、条件队列的使用" class="headerlink" title="四、条件队列的使用"></a>四、条件队列的使用</h2><h3 id="4-1-加锁后操作"><a href="#4-1-加锁后操作" class="headerlink" title="4.1 加锁后操作"></a>4.1 加锁后操作</h3><p>条件队列，是绑定在等待对象上的，所以对条件队列的操作，都必须先拿到对象的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 先拿到对象的锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line">            <span class="comment">// 在锁对象的条件队列上阻塞等待</span></span><br><span class="line">            lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        doPut(item);</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作条件队列，不管是出队还是入队，都需要先获取对象的锁。</p>
<p>对于内置条件队列而言，<code>wait()</code>、<code>notifyAll()</code> 方法就是入队和出队的操作。</p>
<p>所以 <code>wait()</code> 方法和 <code>notifyAll()</code> 方法必须在获取对象锁之后才能执行。</p>
<h3 id="4-2-循环等待条件"><a href="#4-2-循环等待条件" class="headerlink" title="4.2 循环等待条件"></a>4.2 循环等待条件</h3><p>线程被唤醒后，必须重新校验条件谓词，避免是伪唤醒：</p>
<ul>
<li>条件队列可以被多个条件谓词使用，比如 <code>isEmpty()</code> 和 <code>isFull()</code> 可以共用同一个条件队列</li>
<li>线程从开始唤醒到真正执行这段时间内，条件谓词有可能从真变为了假</li>
</ul>
<p>基于各种情况，线程唤醒后，应该再重新验证一下条件谓词，否则可能会出现线程安全问题。</p>
<p>不要使用这种非循环等待的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123; <span class="comment">// 应该用 while 循环</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        doPut(item);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为你永远不知道，为什么线程会被唤醒，比如这种无条件唤醒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设此时阻塞了</span></span><br><span class="line">queue.put(item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有条件，直接唤醒所有线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">    queue.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程完全不知道，是在什么情况下被唤醒的，它只知道被唤醒了而已。</p>
<p>如果唤醒后直接执行后续代码，有可能条件是不满足的，所以应该采用循环等待的方式。</p>
<h4 id="4-3-锁对象必须是同一个"><a href="#4-3-锁对象必须是同一个" class="headerlink" title="4.3 锁对象必须是同一个"></a>4.3 锁对象必须是同一个</h4><p>不同的对象，拥有各自不同的条件队列。</p>
<p>前提条件用到的锁对象，必须和条件队列绑定的锁对象是同一个。</p>
<p>比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            lock2.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        doPut(item);</span><br><span class="line">        lock3.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如执行了 <code>lock2.wait()</code> 方法，那么线程就会被阻塞，并进入 <code>lock2</code> 的条件队列中。</p>
<p>线程进入了阻塞，而此时线程还拿着 <code>lock1</code> 的锁没有释放，因为线程阻塞后释放的是 <code>lock2</code> 的锁。</p>
<p>这就导致，其他线程完全没有办法执行 <code>put()</code> 方法了。</p>
<p>除此以外，状态变量不是由同一个锁保护，还可能出现死锁、并发安全等问题。</p>
<h3 id="4-4-避免信号丢失"><a href="#4-4-避免信号丢失" class="headerlink" title="4.4 避免信号丢失"></a>4.4 避免信号丢失</h3><p>信号丢失，是指线程在等待一个已经发生过的信号。</p>
<p>唤醒可以分为 2 种方式：</p>
<ul>
<li><code>notify</code>：随机唤醒条件队列中的一个线程</li>
<li><code>notifyAll</code>：唤醒条件队列中的所有线程</li>
</ul>
<p>其中，使用 <code>notify</code> 唤醒1个线程时，有可能导致信号丢失。</p>
<ul>
<li>一个条件队列可以绑定多个条件谓词</li>
<li>唤醒随机时，就不知道是唤醒的是哪个条件谓词相关的线程</li>
<li>可能通知信号被其他条件谓词的线程劫持了，从而导致真正需要的线程无法唤醒</li>
</ul>
<p>举个栗子：</p>
<ol>
<li>线程 A 在等待条件 PA；线程 B 在等待条件 PB</li>
<li>此时条件 PA 满足了，然后调用 <code>notify()</code> 方法唤醒，结果唤醒的是线程 B</li>
<li>线程 B 一看，自己的 PB 条件还未满足，又阻塞去了</li>
<li>结果导致线程 A 没有收到唤醒信号</li>
</ol>
<p>所以，如果想使用 <code>notify()</code> 方法，必须满足以下条件：</p>
<ul>
<li>条件队列关联的条件谓词是一样的</li>
<li>所有等待线程的类型都相同</li>
<li>单进单出，每次只有1个线程来执行</li>
</ul>
<p>建议，优先使用 <code>notifyAll()</code> 方法，除非使用 <code>notifyAll()</code> 方法出现了性能问题。</p>
<p><code>notifyAll()</code> 方法会唤醒所有等待线程，因此会带来一些性能问题：</p>
<ul>
<li>可能会出现大量的上下文切换</li>
<li>可能会出现大量的锁竞争</li>
</ul>
<p>比如说，n 个等待线程，使用 <code>notifyAll()</code> 可能会导致 <code>O(n^2)</code> 次唤醒操作，但实际只需要 n 次而已。</p>
<p>不过，可以使用条件通知来稍微优化一下 <code>notifyAll()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> wasEmpty = isEmpty();</span><br><span class="line">        doPut(item);</span><br><span class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，单次通知 <code>notify()</code> 和条件通知，都是对 <code>notifyAll()</code> 的优化。</p>
<p>但是这 2 种优化在使用时很容易写错，所以应该考虑清楚后再使用。</p>
<h3 id="4-5-子类继承"><a href="#4-5-子类继承" class="headerlink" title="4.5 子类继承"></a>4.5 子类继承</h3><p>当父类使用单次通知或条件通知时，子类可能会变得比较复杂。</p>
<ul>
<li>子类可能会违背单次通知和条件通知的原则</li>
</ul>
<p>也就是说，单次通知和条件通知都是限制了特定情况下触发的，如果子类变更了这类需求，就有可能导致信号丢失等问题。</p>
<ul>
<li>子类如果破坏了单次通知和条件通知，那么子类需要自己增加合适的通知机制，比如使用 <code>notifyAll</code></li>
</ul>
<p>对于状态依赖且使用条件队列的类，其设计原则应该满足：</p>
<ul>
<li>要么等待-通知等协议完全向子类公开，协议需写入正式文档</li>
<li>要么完全阻止子类参与等待-通知等过程</li>
</ul>
<p>因为等待-通知机制是很容易出错的，所以设计时需谨慎。</p>
<ul>
<li>公开给子类实现：将父类的协议规定写入文档，让子类按文档要求实现</li>
<li>禁止子类参与等待-通知过程：将条件队列、锁、状态变量等隐藏起来，使得子类看不见</li>
</ul>
<p>实际上就是，要么完全由子类自己实现等待-通知，要么完全由父类实现等待-通知。</p>
<h3 id="4-6-入口协议和出口协议"><a href="#4-6-入口协议和出口协议" class="headerlink" title="4.6 入口协议和出口协议"></a>4.6 入口协议和出口协议</h3><p>对于依赖状态或影响状态的操作，都应该定义好入口协议和出口协议：</p>
<ul>
<li>入口协议：即该操作的条件谓词（前提条件）</li>
<li>出口协议：即该操作修改的状态所影响到的条件谓词</li>
</ul>
<p>比如说，操作 <code>put</code> 的出入口协议：</p>
<p>入口协议：<code>isEmpty()</code><br>出口协议：<code>isFull()</code></p>
<p>在实际使用时，应该这样：</p>
<ul>
<li>入口协议不满足时，进入条件队列等待阻塞</li>
<li>出口协议满足时，通知条件队列唤醒线程</li>
</ul>
<p>用代码来表示，大概就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V item)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 入口协议，不满足时进入条件队列等待</span></span><br><span class="line">        <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doPut(item);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出口协议，满足后通知条件队列唤醒线程</span></span><br><span class="line">        notEmpty.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，应该将入口协议和出口协议写入正式文档。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前提条件：</p>
<ul>
<li>前提条件：被操作方法依赖的状态条件，可能包含一个或多个状态变量</li>
<li>对于并发程序而言，在前提条件不满足的情况下，可以有不同的处理方案<ul>
<li>前提条件失败，可以直接返回</li>
<li>前提条件失败，可以一直等待条件变为真</li>
</ul>
</li>
<li>线程在等待前提条件变为真，而变为真的情况只能是被其他线程修改了状态变量</li>
<li>前提条件中涉及的状态变量，必须由对象的锁来保护，否则会有线程安全性问题</li>
<li>等待前提条件变为真的线程，必须释放对象的锁，否则其他线程无法修改状态变量</li>
<li>前提条件的等待实现，有2种方式：<ul>
<li>非阻塞的轮询</li>
<li>阻塞的等待</li>
</ul>
</li>
</ul>
<p>轮询等待（忙等待、自旋等待）：</p>
<ul>
<li>轮询等待直到前提条件变为真，就必须自己处理异常和重试</li>
<li>轮询等待的弊端：<ul>
<li>自旋等待会消耗大量的 CPU 时间</li>
<li>定时休眠会导致系统的响应性变差</li>
</ul>
</li>
</ul>
<p>条件队列：</p>
<ul>
<li><p>条件队列是通过一种等待-通知的方式，用来解决非阻塞方式的弊端</p>
<ul>
<li>当前提条件失败时，线程进入阻塞等待状态</li>
<li>当前提条件满足后（其他线程修改状态后），通知唤醒等待线程</li>
</ul>
</li>
<li><p>条件队列：在等待-通知过程中用到的队列</p>
</li>
<li><p>条件谓词：就是指的被某个操作依赖的前提条件</p>
</li>
</ul>
<p>内置条件队列：</p>
<ul>
<li>在 Java 中，每个对象都内置有一个条件队列</li>
<li>执行 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 方法，实际就是内置条件队列的出入队操作</li>
<li>内置的条件队列，底层是由 JVM 来实现和维护的，所以无需写 Java 代码去管理</li>
</ul>
<p>显式条件队列：</p>
<ul>
<li>除了内置锁，Java 中还提供了显式锁 Lock，它的作用和内置锁是一样的</li>
<li>内置条件队列，是由 JVM 来实现和维护的；而显式锁的条件队列是由类自己实现的</li>
<li>内置条件队列，只能有一个；而显式锁的条件队列可以有多个</li>
<li>内置锁的条件等待是不可中断的；而显示锁的条件等待是可以中断的</li>
<li>内置的条件队列是非公平的；而显式的条件队列提供了公平和非公平两种方式</li>
</ul>
<p>条件队列和轮询的区别：</p>
<ul>
<li>条件队列并没有改变轮询的语义</li>
<li>条件队列只是对轮询进行了优化：CPU 效率、上下文切换开销和响应性</li>
<li>条件队列只是使得前提条件的等待方式变得更高效了</li>
</ul>
<p>条件队列的使用：</p>
<ul>
<li>加锁后操作：操作条件队列，不管是出队还是入队，都必须要先获取对象的锁</li>
<li>循环等待条件：线程被唤醒后，必须重新校验条件谓词，避免是伪唤醒</li>
<li>锁对象必须是同一个：前提条件用到的锁对象，必须和条件队列绑定的锁对象是同一个</li>
<li>避免信号丢失：优先使用 <code>notifyAll()</code> 方法</li>
<li>子类继承：要么完全由子类自己实现等待-通知，要么完全由父类实现等待-通知</li>
<li>入口协议和出口协议：<ul>
<li>入口协议：即该操作的条件谓词（前提条件）</li>
<li>出口协议：即该操作修改的状态所影响的条件谓词</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>13_显式锁</title>
    <url>/lang/java/core/concurrency/13_%E6%98%BE%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h1><h2 id="一、内置锁的局限"><a href="#一、内置锁的局限" class="headerlink" title="一、内置锁的局限"></a>一、内置锁的局限</h2><ul>
<li>无法中断一个正在等待内置锁的线程</li>
<li>无法实现非阻塞结构的加锁规则</li>
<li>无法实现公平性的锁等待</li>
</ul>
<span id="more"></span>

<h2 id="二、显示锁"><a href="#二、显示锁" class="headerlink" title="二、显示锁"></a>二、显示锁</h2><h3 id="2-1-显示锁概念"><a href="#2-1-显示锁概念" class="headerlink" title="2.1 显示锁概念"></a>2.1 显示锁概念</h3><ul>
<li>提供了无条件的、可轮询的、定时的、可中断的锁获取操作</li>
<li>加锁和解锁都是显式的</li>
<li>提供了与内置锁相同的内存可见性语义</li>
<li>在加锁语义、调度算法、顺序保证、性能特性等方面可能有所不同</li>
<li>必须在 finally 块中释放</li>
</ul>
<h3 id="2-2-轮询锁和定时锁"><a href="#2-2-轮询锁和定时锁" class="headerlink" title="2.2 轮询锁和定时锁"></a>2.2 轮询锁和定时锁</h3><ul>
<li>可定时和可轮询的锁获取模式，是由 tryLock 方法实现</li>
<li>可定时和可轮询的锁获取可避免死锁的发生</li>
</ul>
<h3 id="2-3-可中断的锁获取"><a href="#2-3-可中断的锁获取" class="headerlink" title="2.3 可中断的锁获取"></a>2.3 可中断的锁获取</h3><ul>
<li>可中断的锁获取模式，是由 lockInterruptibly 方法实现</li>
</ul>
<h3 id="2-4-非块结构的加锁"><a href="#2-4-非块结构的加锁" class="headerlink" title="2.4 非块结构的加锁"></a>2.4 非块结构的加锁</h3><ul>
<li>内置锁模式，锁的获取和释放都是基于代码块的</li>
<li>显示锁模式，可以用于对非块结构加锁，比如锁分段技术、连锁式加锁等</li>
</ul>
<h3 id="2-5-公平性"><a href="#2-5-公平性" class="headerlink" title="2.5 公平性"></a>2.5 公平性</h3><ul>
<li>公平性是指，在等待锁的线程中，线程获取锁的顺序是不变的</li>
<li>显示锁，提供了公平性的锁获取方式</li>
<li>在大多数情况下，非公平锁的性能要高于公平锁的性能</li>
<li>非公平性性能高的原因是：恢复一个挂起的线程与该线程真正开始运行之间，存在着严重的延迟</li>
</ul>
<p>比如说，唤醒挂起线程时间点在 10ms，但是挂起线程真正开始执行时间点则是在 1000ms，时间间隔达到 990ms 之久，这2个时间点之间就存在很大的时间空隙，实际上可以先运行其他线程。</p>
<h2 id="三、读写锁"><a href="#三、读写锁" class="headerlink" title="三、读写锁"></a>三、读写锁</h2><p>互斥模式：</p>
<ul>
<li>内置锁和显示锁采用的都是互斥锁模式，每次只能有一个线程拥有锁</li>
<li>互斥锁是一种强硬的加锁规则，限制了并发性</li>
</ul>
<p>读写分离模式：</p>
<ul>
<li>在许多情况下，多线程的读操作是可以并发执行的，无需加互斥锁</li>
<li>读写锁将读锁和写锁分离，多个线程可以同时读锁，不会互斥</li>
</ul>
<h2 id="四、锁的选择"><a href="#四、锁的选择" class="headerlink" title="四、锁的选择"></a>四、锁的选择</h2><ul>
<li>优先选择内置锁</li>
<li>需要高级功能时，再选择显示锁，高级功能包括：<ul>
<li>可定时的锁</li>
<li>可轮询非阻塞的锁获取</li>
<li>可中断的锁获取</li>
<li>公平锁模式</li>
<li>非块结构的加锁</li>
</ul>
</li>
<li>在读多写少的情况下，为了提高并发性，可以考虑使用读写锁</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>12_并发程序测试</title>
    <url>/lang/java/core/concurrency/12_%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="并发程序测试"><a href="#并发程序测试" class="headerlink" title="并发程序测试"></a>并发程序测试</h1><h2 id="一、并发程序测试"><a href="#一、并发程序测试" class="headerlink" title="一、并发程序测试"></a>一、并发程序测试</h2><h3 id="1-1-并发测试的挑战"><a href="#1-1-并发测试的挑战" class="headerlink" title="1.1 并发测试的挑战"></a>1.1 并发测试的挑战</h3><ul>
<li>潜在错误的发生具有不确定性，是随机的</li>
</ul>
<h3 id="1-2-并发测试的类型"><a href="#1-2-并发测试的类型" class="headerlink" title="1.2 并发测试的类型"></a>1.2 并发测试的类型</h3><h3 id="1-2-1-安全性测试"><a href="#1-2-1-安全性测试" class="headerlink" title="1.2.1 安全性测试"></a>1.2.1 安全性测试</h3><ul>
<li>安全性：不发生任何错误的行为</li>
<li>安全性测试：通常采用测试不变性条件和后验条件的形式，即判断某个类的行为在并发测试下，其状态是否与其规范一致</li>
</ul>
<span id="more"></span>

<h3 id="1-2-2-活跃性测试"><a href="#1-2-2-活跃性测试" class="headerlink" title="1.2.2 活跃性测试"></a>1.2.2 活跃性测试</h3><ul>
<li>活跃性：某个“良好”的行为“终究”会发生</li>
<li>活跃性测试与性能测试息息相关，活跃性测试比较难量化，所以常用性能测试替代</li>
<li>性能测试可通过多个方面来衡量：<ul>
<li>吞吐量：一组并发任务在已完成任务中所占的比例</li>
<li>响应性（延迟）：请求从发出到完成所用的时间</li>
<li>可伸缩性：在增加更多资源的情况下，吞吐量的提升情况</li>
</ul>
</li>
</ul>
<h2 id="二、正确性测试"><a href="#二、正确性测试" class="headerlink" title="二、正确性测试"></a>二、正确性测试</h2><h3 id="2-1-正确性测试的基本思路"><a href="#2-1-正确性测试的基本思路" class="headerlink" title="2.1 正确性测试的基本思路"></a>2.1 正确性测试的基本思路</h3><ul>
<li>找出需要检查的不变性条件和后验条件</li>
<li>为不变性条件和后验条件编写测试用例</li>
<li>在编写测试用例时，不断探索发现新的测试情况</li>
<li>为新的情况编写测试用例</li>
</ul>
<h3 id="2-2-常用的测试方法"><a href="#2-2-常用的测试方法" class="headerlink" title="2.2 常用的测试方法"></a>2.2 常用的测试方法</h3><h4 id="2-2-1-直接验证测试"><a href="#2-2-1-直接验证测试" class="headerlink" title="2.2.1 直接验证测试"></a>2.2.1 直接验证测试</h4><ul>
<li>直接调用对象的对外接口方法，验证它的不变性条件和后验条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testIsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    assertTrue(list.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-回调钩子测试"><a href="#2-2-2-回调钩子测试" class="headerlink" title="2.2.2 回调钩子测试"></a>2.2.2 回调钩子测试</h4><ul>
<li>有些对象拥有自己的一些生命周期，不同时期的状态有固定的规范</li>
<li>比如线程的生命周期可以是：创建、启动、阻塞、结束</li>
<li>可以在对象生命周期中添加一些钩子函数，在每个阶段调用测试方法，验证当时的状态是否正确</li>
</ul>
<h4 id="2-2-3-随机安全测试"><a href="#2-2-3-随机安全测试" class="headerlink" title="2.2.3 随机安全测试"></a>2.2.3 随机安全测试</h4><ul>
<li>想要测试在不可预测的并发访问情况下，执行结果是否一直是安全正确的</li>
<li>需要多次验证，并且每次验证应该是随机的，但是结果应该总是安全正确的</li>
<li>随机性结果的验证，可以通过校验和计算函数来实现，即对入参和返回进行校验比较</li>
<li>大多数随机生成器类都是线程安全的，使用它们会带来额外的同步开销，使用一些简单的随机生成器更好</li>
</ul>
<p>简单的随机数生成函数（基于 hashCode + nanoTime + xorShift）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomInt</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xorShift(object.hashCode() * System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xorShift</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">6</span>);</span><br><span class="line">    y ^= (y &gt;&gt;&gt; <span class="number">21</span>);</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-4-阻塞中断测试"><a href="#2-2-4-阻塞中断测试" class="headerlink" title="2.2.4 阻塞中断测试"></a>2.2.4 阻塞中断测试</h4><ul>
<li>如果某个方法在特殊条件下进入了阻塞，那么只有当线程不再执行时，测试才是成功的</li>
<li>测试阻塞方法的方式：<ul>
<li>在一个单独线程中启动阻塞方法</li>
<li>等待线程进入阻塞状态</li>
<li>在另一个线程中调用中断，将阻塞线程中断唤醒</li>
</ul>
</li>
<li>阻塞方法要求能够响应中断并返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 做某些阻塞操作...</span></span><br><span class="line">            fail();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 等待线程进入阻塞状态</span></span><br><span class="line">        Thread.sleep(LOCKUP_DETECT_TIMEOUT);</span><br><span class="line">        <span class="comment">// 中断阻塞线程</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">        <span class="comment">// 等待线程结束</span></span><br><span class="line">        t.join(LOCKUP_DETECT_TIMEOUT);</span><br><span class="line">        <span class="comment">// 验证线程是否已经结束</span></span><br><span class="line">        assertTrue(t.isAlive());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        fail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-5-资源管理测试"><a href="#2-2-5-资源管理测试" class="headerlink" title="2.2.5 资源管理测试"></a>2.2.5 资源管理测试</h4><ul>
<li>对于任何持有或管理其他对象的对象，应该在不需要的时候释放和销毁它们的引用</li>
<li>并发线程很多时，将会非常消耗资源，最终可能导致资源耗尽和应用程序故障失败</li>
<li>为了防止资源耗尽，需要测试线程拥有的资源是否已经正确释放</li>
<li>测试资源的占用和释放，可以采用一些分析工具，分析内存中的对象信息，比如堆中对象的垃圾回收情况</li>
</ul>
<h4 id="2-2-6-上下文切换测试"><a href="#2-2-6-上下文切换测试" class="headerlink" title="2.2.6 上下文切换测试"></a>2.2.6 上下文切换测试</h4><ul>
<li>并发问题的来源，就是因为线程之间的资源竞争</li>
<li>为了提高并发错误发生的可能性，可以提高线程之间的上下文切换频率</li>
<li>可以通过使用 Thread.yield() 方法来产生更多的交替操作</li>
</ul>
<h2 id="三、性能测试"><a href="#三、性能测试" class="headerlink" title="三、性能测试"></a>三、性能测试</h2><h3 id="3-1-性能测试目的"><a href="#3-1-性能测试目的" class="headerlink" title="3.1 性能测试目的"></a>3.1 性能测试目的</h3><ul>
<li>通过衡量测试用例的性能，反映出对象在应用程序中的实际用途，比如并发容器适用于高并发的情况</li>
<li>根据测试结果，调整各种不同的限制参数，比如线程数量、缓存容量等</li>
</ul>
<h3 id="3-2-常用测试方法"><a href="#3-2-常用测试方法" class="headerlink" title="3.2 常用测试方法"></a>3.2 常用测试方法</h3><h4 id="3-2-1-计时功能测试"><a href="#3-2-1-计时功能测试" class="headerlink" title="3.2.1 计时功能测试"></a>3.2.1 计时功能测试</h4><ul>
<li>性能最直接的方式，就是计算并发任务的完成时间</li>
<li>所有并发任务总的完成时间、各个任务的完成时间、操作平均完成时间</li>
<li>计时测试，可能需要用到闭锁（latch）、栅栏（Barrier）等方式来同时为各个任务计时</li>
</ul>
<h4 id="3-2-2-算法对比测试"><a href="#3-2-2-算法对比测试" class="headerlink" title="3.2.2 算法对比测试"></a>3.2.2 算法对比测试</h4><ul>
<li>通过对比其他的算法实现，来衡量当前算法的性能</li>
<li>比如对比同步容器和并发容器的性能，就能明显看出各自的性能差异</li>
</ul>
<h4 id="3-2-3-稳定性测试"><a href="#3-2-3-稳定性测试" class="headerlink" title="3.2.3 稳定性测试"></a>3.2.3 稳定性测试</h4><ul>
<li>除了任务完成的速度，还应该测试任务在各种情况下的稳定性</li>
<li>比如，算法 A 的完成时间在 10ms ~ 200ms 之间，算法 B 的完成时间在 70ms ~ 100ms 之间，就说明算法 B 更具稳定性</li>
<li>有时候，稳定性比速度更具有价值，所以应视情况而定</li>
</ul>
<h2 id="四、并发测试的陷阱"><a href="#四、并发测试的陷阱" class="headerlink" title="四、并发测试的陷阱"></a>四、并发测试的陷阱</h2><h3 id="4-1-垃圾回收"><a href="#4-1-垃圾回收" class="headerlink" title="4.1 垃圾回收"></a>4.1 垃圾回收</h3><ul>
<li>垃圾回收的执行无法预测，可以在任何时刻运行，测试不应该考虑垃圾回收的触发时机</li>
<li>防止垃圾回收造成测试偏差：<ul>
<li>无垃圾回收：确保垃圾回收不会执行（通过打印gc日志查看）</li>
<li>平均垃圾回收：确保垃圾回收多次执行，基本平均到每次测试中，减少误差</li>
</ul>
</li>
<li>平均垃圾回收策略，在实际环境中的表现会更好</li>
</ul>
<h3 id="4-2-动态编译"><a href="#4-2-动态编译" class="headerlink" title="4.2 动态编译"></a>4.2 动态编译</h3><ul>
<li>通常情况，JVM 都是通过解释字节码的方式来运行程序</li>
<li>但是如果某个方法频繁调用，JVM 的动态编译器会直接将方法编译为机器代码，后面直接就运行机器代码，不再解释字节码运行了</li>
<li>在某些情况下，动态编译执行还可能回退回解释执行</li>
<li>动态编译具有更好的性能，但是这会对性能测试造成一定的影响</li>
<li>避免动态编译影响的方式：<ul>
<li>避免动态编译：测试应具有更普遍的随机性，避免动态编译的触发</li>
<li>错开动态编辑：等到动态编译之后，再开始测试性能</li>
</ul>
</li>
<li>如果动态编译不可避免，那么性能测试就应该延迟到等动态编译完成后再开始</li>
</ul>
<h3 id="4-3-针对性优化"><a href="#4-3-针对性优化" class="headerlink" title="4.3 针对性优化"></a>4.3 针对性优化</h3><ul>
<li>JVM 会根据实际的执行过程，来生成更优的代码</li>
<li>也就是说，同一套代码，在不同环境下执行，被 JVM 优化后的代码可能会有不同</li>
<li>测试应覆盖执行代码的所有分支情况，避免 JVM 针对某种情况进行针对性优化</li>
<li>比如，如果执行某个方法时，一直都是只执行某条代码分支，多次执行以后，JVM 有可能会针对它进行代码优化</li>
</ul>
<h3 id="4-4-无用代码的消除"><a href="#4-4-无用代码的消除" class="headerlink" title="4.4 无用代码的消除"></a>4.4 无用代码的消除</h3><ul>
<li>优化编译器，可能会消除对最终结果没有任何影响的无用代码</li>
<li>测试代码中，有些代码虽然不影响最终的结果，但也是必要的，它不应该被优化器给优化掉</li>
<li>可以通过查看机器代码，来验证测试代码是否被优化了</li>
<li>避免无用代码被优化掉的小技巧：使用对象的 hashCode 与任意值（如 nanoTime）比较</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (object.hashCode() == System.nanoTime()) &#123;</span><br><span class="line">    <span class="comment">// 输出一个无用的消息</span></span><br><span class="line">    System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-5-不真实竞争"><a href="#4-5-不真实竞争" class="headerlink" title="4.5 不真实竞争"></a>4.5 不真实竞争</h3><ul>
<li>测试程序，应该与实际使用相适应，否则测试结果就会显得不真实，毫无意义</li>
<li>如果实际使用中，任务都是用于计算密集型的，那么测试程序应该是计算密集型的</li>
</ul>
<h2 id="五、其他测试方法"><a href="#五、其他测试方法" class="headerlink" title="五、其他测试方法"></a>五、其他测试方法</h2><h3 id="5-1-代码审查"><a href="#5-1-代码审查" class="headerlink" title="5.1 代码审查"></a>5.1 代码审查</h3><ul>
<li>并发专家能够比大多数测试程序更高效地发现一些竞争问题（毕竟测试代码也是人写的）</li>
<li>通过找出常见的设计性问题，还可以提高代码的质量</li>
<li>可以提前发现问题，降低后期维护的成本和风险</li>
</ul>
<h3 id="5-2-静态代码分析"><a href="#5-2-静态代码分析" class="headerlink" title="5.2 静态代码分析"></a>5.2 静态代码分析</h3><ul>
<li>一些代码扫描工具（如 findBug），可以自动发现一些常见的代码错误</li>
<li>不一致的同步：加锁对象不一致，导致加锁无用</li>
<li>未释放的锁：锁释放没有放 finally 块中，异常时可能导致锁永远无法释放</li>
<li>调用 Thread.run()：不要调用 Thread 的 run() 方法，而是调用 start() 方法</li>
<li>双重校验锁：错误的习惯用法，写不好就会出现一堆问题</li>
<li>Lock 的误用：Lock 并不是作为同步块来使用的</li>
<li>自旋循环：自旋等待不加 volatile 可能会导致 CPU 无限高负载，闭锁和条件等待通常是一种更好的方式</li>
</ul>
<h3 id="5-3-面向方面技术"><a href="#5-3-面向方面技术" class="headerlink" title="5.3 面向方面技术"></a>5.3 面向方面技术</h3><ul>
<li>通过切面编程，去验证在各个阶段的状态和线程</li>
<li>并发领域的切面技术还不够成熟，作用有限</li>
</ul>
<h3 id="5-4-分析与监测工具"><a href="#5-4-分析与监测工具" class="headerlink" title="5.4 分析与监测工具"></a>5.4 分析与监测工具</h3><ul>
<li>存在一些分析工具，可以给出程序内部的详细执行信息</li>
<li>比如线程状态、线程堆栈、线程锁对象、线程等待、死锁分析等</li>
<li>分析工具通常采用侵入式实现，有可能会对程序的执行时序和行为产生较大的影响</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>11_性能问题</title>
    <url>/lang/java/core/concurrency/11_%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h1><h2 id="一、性能优化"><a href="#一、性能优化" class="headerlink" title="一、性能优化"></a>一、性能优化</h2><h3 id="1-1-目的"><a href="#1-1-目的" class="headerlink" title="1.1 目的"></a>1.1 目的</h3><ul>
<li>提高程序的整体运行性能</li>
</ul>
<h3 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h3><ul>
<li>始终把安全性放在第一</li>
<li>程序正确后，再想办法提高运行速度</li>
</ul>
<span id="more"></span>

<h3 id="1-3-指标"><a href="#1-3-指标" class="headerlink" title="1.3 指标"></a>1.3 指标</h3><ul>
<li>吞吐率优化：更有效地利用现有资源，用同样的资源做更多的事</li>
<li>可伸缩性优化：当增加新资源时，新资源可以得到利用，程序的性能可以提升</li>
</ul>
<h3 id="1-4-权衡因素"><a href="#1-4-权衡因素" class="headerlink" title="1.4 权衡因素"></a>1.4 权衡因素</h3><ul>
<li>进行性能优化时，一定要有明确的性能需求，清楚了解什么时候优化，什么时候不优化</li>
<li>必须以测试为基准，验证性能的优化程度，不要靠猜测</li>
<li>做出性能优化决策时，必须考虑以下问题：<ul>
<li>做了什么优化？优化了什么地方？</li>
<li>在什么样的场景下优化了？其他场景是否使用？</li>
<li>优化的场景发生概率如何？</li>
<li>这种优化会带来哪些问题？需要付出什么代价？例如增加开发风险或维护开销？</li>
</ul>
</li>
<li>避免不成熟的优化，一定要预估优化风险，以及验证优化结果</li>
</ul>
<h2 id="二、线程开销"><a href="#二、线程开销" class="headerlink" title="二、线程开销"></a>二、线程开销</h2><h3 id="2-1-上下文切换"><a href="#2-1-上下文切换" class="headerlink" title="2.1 上下文切换"></a>2.1 上下文切换</h3><ul>
<li>线程调度，会引起上下文切换</li>
<li>上下文切换，会涉及到应用程序、JVM、操作系统等多方面的切换开销</li>
<li>在 JVM、操作系统上消耗的时间越多，应用程序可用时间越少</li>
<li>上下文切换的开销与平台有关，在大多数处理器中，上下文切换开销相当于 5000 ~ 10000 个时钟周期</li>
<li>线程数量越多（竞争）、IO阻塞越多（挂起），上下文切换越频繁</li>
</ul>
<h3 id="2-2-内存同步"><a href="#2-2-内存同步" class="headerlink" title="2.2 内存同步"></a>2.2 内存同步</h3><ul>
<li>同步实现会使用到特殊的硬件指令，比如内存栅栏，它有刷新缓存使得缓存无效、停止执行管道、禁止指令重排序等功能</li>
<li>同步需要锁定共享内存总线，而所有处理器都共享这条总线，所以同步期间会影响其他线程的性能</li>
</ul>
<h3 id="2-3-阻塞"><a href="#2-3-阻塞" class="headerlink" title="2.3 阻塞"></a>2.3 阻塞</h3><ul>
<li>阻塞会导致线程挂起，从而产生上下文切换</li>
<li>阻塞挂起至少会引起2次上下文切换，一次是挂起，一次是恢复</li>
</ul>
<h2 id="三、并发锁优化"><a href="#三、并发锁优化" class="headerlink" title="三、并发锁优化"></a>三、并发锁优化</h2><p>有3种方式可以降低锁的竞争程度：</p>
<ul>
<li>减少锁的持有时间</li>
<li>降低锁的请求频率</li>
<li>使用带有协调机制的独占锁，这些机制允许更高的并发性</li>
</ul>
<h3 id="3-1-减少锁持有时间"><a href="#3-1-减少锁持有时间" class="headerlink" title="3.1 减少锁持有时间"></a>3.1 减少锁持有时间</h3><ul>
<li>缩小同步代码块范围</li>
<li>拆分过大的同步代码块成小的同步代码块</li>
<li>同步代码块不宜过小，需保证安全性、原子性</li>
<li>同步代码块不易过多，避免频繁加锁解锁</li>
</ul>
<h3 id="3-2-降低锁粒度"><a href="#3-2-降低锁粒度" class="headerlink" title="3.2 降低锁粒度"></a>3.2 降低锁粒度</h3><ul>
<li>减少锁的请求频率，即请求锁数量少了，就能减少发生竞争的可能性</li>
</ul>
<h4 id="3-2-1-锁分解"><a href="#3-2-1-锁分解" class="headerlink" title="3.2.1 锁分解"></a>3.2.1 锁分解</h4><ul>
<li>对象中存在多个相互独立的状态</li>
<li>对象存在适中而不激烈的锁竞争</li>
<li>根据相互独立的状态，使用不同的锁</li>
</ul>
<h4 id="3-2-2-锁分段"><a href="#3-2-2-锁分段" class="headerlink" title="3.2.2 锁分段"></a>3.2.2 锁分段</h4><ul>
<li>锁分解的进一步扩展</li>
<li>对象存在激烈的锁竞争</li>
<li>根据不同的数据范围，使用不同的锁</li>
</ul>
<h4 id="3-2-3-避免热点域"><a href="#3-2-3-避免热点域" class="headerlink" title="3.2.3 避免热点域"></a>3.2.3 避免热点域</h4><ul>
<li>被多个锁共享的状态变量</li>
<li>多个操作都涉及到的状态变量</li>
<li>需要多个锁才能访问的状态变量</li>
<li>避免热点域，因为它往往需要加多个锁，或者加全局锁才能操作</li>
</ul>
<h3 id="3-3-避免独占锁"><a href="#3-3-避免独占锁" class="headerlink" title="3.3 避免独占锁"></a>3.3 避免独占锁</h3><ul>
<li>并发容器</li>
<li>读写锁分离</li>
<li>不可变对象</li>
<li>原子变量</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>10_活跃性问题</title>
    <url>/lang/java/core/concurrency/10_%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h1><h2 id="一、死锁"><a href="#一、死锁" class="headerlink" title="一、死锁"></a>一、死锁</h2><h3 id="1-1-死锁条件"><a href="#1-1-死锁条件" class="headerlink" title="1.1 死锁条件"></a>1.1 死锁条件</h3><ul>
<li>互斥：资源是互斥的，只能被一个线程持有</li>
<li>占用且等待：线程占有一些资源后，在等待其他资源，等待过程中不会释放自己已占用的资源</li>
<li>不可剥夺：不可以强行剥夺已被线程占有的资源</li>
<li>循环等待：占用资源的线程在循环等待其他占用资源的线程释放资源</li>
</ul>
<span id="more"></span>

<h3 id="1-2-死锁避免"><a href="#1-2-死锁避免" class="headerlink" title="1.2 死锁避免"></a>1.2 死锁避免</h3><p>避免死锁的办法，就是破坏死锁的四个条件：</p>
<ul>
<li>互斥：开放调用，减少锁范围，避免对方法加锁，避免获取多个锁</li>
<li>占用且等待：一次性获取全部资源，避免锁等待</li>
<li>不可剥夺：线程自己释放资源即可，比如超时释放锁，随机等待获取锁等</li>
<li>循环等待：对资源进行排序，有序申请占用资源</li>
</ul>
<h3 id="1-3-死锁诊断"><a href="#1-3-死锁诊断" class="headerlink" title="1.3 死锁诊断"></a>1.3 死锁诊断</h3><ul>
<li>代码分析<ul>
<li>找出可能获取多个锁的代码区域</li>
<li>全局分析，确保获取它们获取锁的顺序是一致的，避免循环等待</li>
</ul>
</li>
<li>JVM 线程转储信息<ul>
<li>JVM 线程转储信息可以打印出死锁相关信息</li>
</ul>
</li>
</ul>
<h2 id="二、饥饿"><a href="#二、饥饿" class="headerlink" title="二、饥饿"></a>二、饥饿</h2><ul>
<li>饥饿：线程由于无法访问它所需资源而不能继续执行时，发生饥饿</li>
<li>出现这种现象的情况有：<ul>
<li>优先级使用不当</li>
<li>长时间持有锁不释放</li>
</ul>
</li>
<li>解决饥饿的方案有：<ul>
<li>避免使用优先级</li>
<li>使用公平锁，线程按先来后到执行，有序执行</li>
<li>超时释放锁，避免长时间持有锁</li>
</ul>
</li>
</ul>
<h2 id="三、活锁"><a href="#三、活锁" class="headerlink" title="三、活锁"></a>三、活锁</h2><ul>
<li>活锁：线程之间相互谦让，同时加锁资源又同时释放资源，导致没有线程可以执行</li>
<li>出现这种现象的情况有：<ul>
<li>冲突后同时等待和重发，比如网络数据包，两台机器同时发包导致冲突，然后又等待同样的时间，再继续发包，又会冲突</li>
<li>过度的错误恢复，将不可修复错误当作可修复错误重复执行。比如，事务执行失败回滚，然后又重新执行，又失败回滚，一直循环</li>
</ul>
</li>
<li>避免活锁的方案有：<ul>
<li>随机等待时间，避免活锁的同时占用和同时释放资源，随机等待可以降低冲突</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>08_02_串行算法的并行化</title>
    <url>/lang/java/core/concurrency/08_02_%E4%B8%B2%E8%A1%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%8C%96/</url>
    <content><![CDATA[<h1 id="串行算法的并行化"><a href="#串行算法的并行化" class="headerlink" title="串行算法的并行化"></a>串行算法的并行化</h1><h2 id="一、并行化要求"><a href="#一、并行化要求" class="headerlink" title="一、并行化要求"></a>一、并行化要求</h2><ul>
<li>递归的每次迭代都是独立的</li>
<li>将每个迭代拆分成任务并发执行</li>
</ul>
<span id="more"></span>

<h2 id="二、多个结果的获取"><a href="#二、多个结果的获取" class="headerlink" title="二、多个结果的获取"></a>二、多个结果的获取</h2><ul>
<li>使用 <code>ExecutorService.invokeAll()</code> 方法等待所有并发线程执行完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelInvokeAllResults</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getParallelResults</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 统计所有迭代节点，节点之间相互独立</span></span><br><span class="line">        List&lt;Node&lt;T&gt;&gt; allNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;T&gt; node : nodes) &#123;</span><br><span class="line">            collectAllNodes(node, allNodes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有节点的计算任务</span></span><br><span class="line">        List&lt;Callable&lt;T&gt;&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(allNodes.size());</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;T&gt; node : nodes) &#123;</span><br><span class="line">            tasks.add(node::compute);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并行方式计算</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures = exec.invokeAll(tasks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集并行计算结果</span></span><br><span class="line">        List&lt;T&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;(futures.size());</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;T&gt; f : futures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                results.add(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                results.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收集所有节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">collectAllNodes</span><span class="params">(Node&lt;T&gt; node, List&lt;Node&lt;T&gt;&gt; allNodes)</span> </span>&#123;</span><br><span class="line">        allNodes.add(node);</span><br><span class="line">        <span class="keyword">if</span> (node.getChildren() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;T&gt; c : node.getChildren()) &#123;</span><br><span class="line">                collectAllNodes(c, allNodes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用共享变量 <code>BlockingQueue</code> 实例，用于存放并发线程的返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelParamQueueResults</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getParallelResults</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 并行方式计算</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;T&gt; resultQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归并行计算结果</span></span><br><span class="line">        parallelRecursive(exec, nodes, resultQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待计算结果</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        exec.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并行递归计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelRecursive</span><span class="params">(<span class="keyword">final</span> Executor exec, List&lt;Node&lt;T&gt;&gt; nodes, <span class="keyword">final</span> Collection&lt;T&gt; results)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;T&gt; node : nodes) &#123;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                results.add(node.compute());</span><br><span class="line">            &#125;);</span><br><span class="line">            parallelRecursive(exec, node.getChildren(), results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、单个结果的获取"><a href="#三、单个结果的获取" class="headerlink" title="三、单个结果的获取"></a>三、单个结果的获取</h2><ul>
<li>使用 <code>ExecutorService.invokeAny()</code> 方法等待任意一个并发线程执行完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelInvokeAnyResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getParallelResult</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 统计所有迭代节点，节点之间相互独立</span></span><br><span class="line">        List&lt;Node&lt;T&gt;&gt; allNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;T&gt; node : nodes) &#123;</span><br><span class="line">            collectAllNodes(node, allNodes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有节点的计算任务</span></span><br><span class="line">        List&lt;Callable&lt;T&gt;&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(allNodes.size());</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;T&gt; node : nodes) &#123;</span><br><span class="line">            tasks.add(node::compute);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并行方式计算</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        T result = exec.invokeAny(tasks);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收集所有节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">collectAllNodes</span><span class="params">(Node&lt;T&gt; node, List&lt;Node&lt;T&gt;&gt; allNodes)</span> </span>&#123;</span><br><span class="line">        allNodes.add(node);</span><br><span class="line">        <span class="keyword">if</span> (node.getChildren() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;T&gt; c : node.getChildren()) &#123;</span><br><span class="line">                collectAllNodes(c, allNodes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用共享变量闭锁 <code>CountDownLatch(1)</code> 实例，保证只设置一次返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelLatchResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getParallelResult</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归并行计算结果</span></span><br><span class="line">        ValueLatch&lt;T&gt; result = <span class="keyword">new</span> ValueLatch&lt;&gt;();</span><br><span class="line">        parallelRecursive(exec, nodes, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待计算结果</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        exec.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并行递归计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelRecursive</span><span class="params">(<span class="keyword">final</span> Executor exec, List&lt;Node&lt;T&gt;&gt; nodes, <span class="keyword">final</span> ValueLatch&lt;T&gt; valueLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;T&gt; node : nodes) &#123;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                T result = node.compute();</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    valueLatch.setValue(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            parallelRecursive(exec, node.getChildren(), valueLatch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueLatch</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> latch.getCount() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSet()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、无结果的处理"><a href="#四、无结果的处理" class="headerlink" title="四、无结果的处理"></a>四、无结果的处理</h2><ul>
<li>统计任务的数量，当最后一个任务执行完成后，如果还是没有结果，返回 null</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelNoResult</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getParallelResult</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger countTask = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归并行计算结果</span></span><br><span class="line">        ValueLatch&lt;T&gt; result = <span class="keyword">new</span> ValueLatch&lt;&gt;();</span><br><span class="line">        parallelRecursive(exec, nodes, result, countTask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待计算结果</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        exec.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并行递归计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelRecursive</span><span class="params">(<span class="keyword">final</span> Executor exec, List&lt;Node&lt;T&gt;&gt; nodes, <span class="keyword">final</span> ValueLatch&lt;T&gt; valueLatch,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">final</span> AtomicInteger countTask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;T&gt; node : nodes) &#123;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 统计任务的数量</span></span><br><span class="line">                    countTask.incrementAndGet();</span><br><span class="line">                    T result = node.compute();</span><br><span class="line">                    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 有可能导致没有返回结果</span></span><br><span class="line">                        valueLatch.setValue(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (countTask.decrementAndGet() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 最后一个任务结束时，返回 null</span></span><br><span class="line">                        valueLatch.setValue(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            parallelRecursive(exec, node.getChildren(), valueLatch, countTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>08_01_线程池的使用</title>
    <url>/lang/java/core/concurrency/08_01_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><h2 id="一、默认线程池的弊端"><a href="#一、默认线程池的弊端" class="headerlink" title="一、默认线程池的弊端"></a>一、默认线程池的弊端</h2><p>并非所有任务都能适用于默认的执行策略，比如：</p>
<ul>
<li>依赖性任务</li>
<li>线程封闭的任务</li>
<li>长时间运行的任务</li>
<li>使用线程本地变量的任务</li>
</ul>
<p>这类任务往往需要指定特定的执行策略，否则可能会产生活跃性问题。</p>
<span id="more"></span>

<h3 id="1-1-线程饥饿死锁"><a href="#1-1-线程饥饿死锁" class="headerlink" title="1.1 线程饥饿死锁"></a>1.1 线程饥饿死锁</h3><p>在线程池中，如果任务依赖于其他任务，那么就有可能产生死锁。</p>
<p>比如说，在只有1个线程的线程池中运行依赖任务时，就能产生死锁。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDeadlock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单线程的线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderPageTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Future&lt;String&gt; header, footer;</span><br><span class="line">            header = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">&quot;header.html&quot;</span>));</span><br><span class="line">            footer = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">&quot;footer.html&quot;</span>));</span><br><span class="line">            String page = renderBody();</span><br><span class="line">            <span class="comment">// 将发生死锁 —— 由于任务在等待子任务的结果</span></span><br><span class="line">            <span class="keyword">return</span> header.get() + page + footer.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非线程池容量无限大，否则只要任务之间有依赖，那么就存在饥饿死锁的可能。</p>
<p>解决饥饿死锁的最好办法就是：</p>
<ul>
<li>不同类型的任务使用不同的线程池</li>
<li>依赖的任务分离开来，使用不同的线程池</li>
</ul>
<p>只要避免在同一个线程池中运行依赖的任务，就能避免线程饥饿死锁。</p>
<h3 id="1-2-长时间运行"><a href="#1-2-长时间运行" class="headerlink" title="1.2 长时间运行"></a>1.2 长时间运行</h3><p>有时候，应用程序对任务的响应时间是有要求的，比如 GUI 程序。</p>
<p>如果一个任务在线程池中长时间阻塞，那么即使不出现死锁，线程池的响应性也会变得很差。</p>
<p>这类问题很难解决，但有一种办法可以缓解问题：</p>
<ul>
<li>限制任务等待资源的时间，不要无限制地等待</li>
<li>如果任务等待超时，那么就将任务移除或重新放回队列等待执行</li>
</ul>
<p>这个缓解方案，关键是评估任务的最长执行时间，否则如果限定时间太短，那么任务有可能永远无法完成。</p>
<h2 id="二、线程池的优化"><a href="#二、线程池的优化" class="headerlink" title="二、线程池的优化"></a>二、线程池的优化</h2><p>只有当任务都是同类型，并且相互独立时，线程池的性能才能达到最优。</p>
<h3 id="2-1-线程的创建和销毁"><a href="#2-1-线程的创建和销毁" class="headerlink" title="2.1 线程的创建和销毁"></a>2.1 线程的创建和销毁</h3><p>与线程池中线程的创建和销毁有关的因素：</p>
<ul>
<li>核心线程数量（Core Pool Size）</li>
<li>最大线程数量（Maximum Pool Size）</li>
<li>线程存活时间（Keep-Alive Time）</li>
</ul>
<p>线程什么时候创建？</p>
<ol>
<li>线程池在初始化时，线程数量为 0，按需创建线程</li>
<li>“线程池大小 &lt; 核心线程数量”，当有任务到来时，就创建一个新的线程</li>
<li>“线程池大小 == 核心线程数量”，如果有任务到来，就将任务放入队列中等待执行</li>
<li>“核心线程数量 &lt;= 线程池大小 &lt; 最大线程数量”，且任务队列满了，就创建一个新的线程</li>
<li>“线程池大小 &gt; 最大线程数量”，且任务队列满了，那么就拒绝执行任务</li>
</ol>
<p>线程什么时候销毁？</p>
<ul>
<li>“核心线程数量 &lt; 线程池大小”，且线程的空闲时间超过了存活时间，就销毁线程</li>
<li>默认情况下，核心线程一旦被创建，就永远不会被销毁</li>
<li>如果设置了 <code>allowCoreThreadTimeOut</code> 参数，当核心线程的空闲时间超过了存活时间，也会被销毁</li>
</ul>
<p>通过调节线程池的核心线程数量、最大线程数量、存活时间，可以帮助线程池回收空闲线程占用的资源。</p>
<h3 id="2-2-线程数量"><a href="#2-2-线程数量" class="headerlink" title="2.2 线程数量"></a>2.2 线程数量</h3><p>线程数量的相关问题：</p>
<ul>
<li>避免“过大”和“过小”</li>
<li>“过大”，容易出现资源耗尽、资源竞争过于激烈等问题</li>
<li>“过小”，没有充分利用处理器资源，降低了吞吐率</li>
</ul>
<p>线程数量影响因素：</p>
<ul>
<li>计算环境：处理器数量？</li>
<li>资源预算：多大的内存？可用的内存？</li>
<li>任务特性：计算密集型？IO密集型？</li>
</ul>
<p>核心线程数量？</p>
<ul>
<li>当计算密集型任务时，在 N 个处理器的情况下，通常线程池大小为 N+1 时性能最优</li>
<li>当 IO 密集型任务时，必须先估算出任务等待时间和计算时间的比值 R，然后再计算线程数量</li>
<li>当 IO 密集型任务时，通常线程数量为 “处理器数量N * CPU使用率U * (1 + R)” 时性能最优</li>
</ul>
<p>最大线程数量？</p>
<ul>
<li>计算每个任务对自由的需求量</li>
<li>用资源的可用总量除以每个任务的需求量，得到线程池的大小上限</li>
</ul>
<p>这些都只是理论上的计算，现实中使用时，可以先用这种方案预设线程池数量。</p>
<p>然后再对实际环境进行监控和分析，不断调节线程池的大小。</p>
<h3 id="2-3-任务队列"><a href="#2-3-任务队列" class="headerlink" title="2.3 任务队列"></a>2.3 任务队列</h3><p>任务队列类型的选择：</p>
<ul>
<li>有界队列<ul>
<li>避免资源耗尽</li>
<li>任务相互独立</li>
<li>控制任务执行顺序，FIFO？LIFO？Priority？</li>
<li>有界队列的大小需要和线程池大小一起调节</li>
<li>可以拒绝任务</li>
</ul>
</li>
<li>无界队列<ul>
<li>有足够的可用资源</li>
<li>任务之间存在依赖性，避免死锁</li>
<li>不能拒绝任务</li>
</ul>
</li>
<li>同步移交<ul>
<li>避免任务排队</li>
<li>线程池大小是无界的</li>
<li>可以拒绝任务</li>
</ul>
</li>
</ul>
<p>根据实际情况选择不同的队列。</p>
<h3 id="2-4-拒绝策略"><a href="#2-4-拒绝策略" class="headerlink" title="2.4 拒绝策略"></a>2.4 拒绝策略</h3><ul>
<li>中止（AbortPolicy）：直接报错，停止当前线程</li>
<li>抛弃（DiscardPolicy）：直接丢弃当前任务</li>
<li>抛弃最老的（DiscardOldestPolicy）：丢弃最老的任务</li>
<li>调度者运行（CallerRunsPolicy）：在调用者线程执行任务</li>
</ul>
<h3 id="2-5-线程工厂"><a href="#2-5-线程工厂" class="headerlink" title="2.5 线程工厂"></a>2.5 线程工厂</h3><p>自定义线程工厂？</p>
<ul>
<li>每当线程池需要新的线程时，都会调用线程工厂的 newThread 方法创建新的线程</li>
<li>默认的线程工厂方法会创建一个新的、非守护的线程，并且没有任何特殊配置信息</li>
<li>实现 <code>ThreadFactory</code> 接口来自定义线程工厂方法，创建自定义线程</li>
</ul>
<p>不可配置线程池？</p>
<ul>
<li>通过 <code>Executors.unmodifiableThreadPool</code> 方法可以封装现有的线程池</li>
<li>封装后使其只暴露 <code>ExecutorService</code> 接口，因此不能对它进行配置</li>
</ul>
<p>线程安全策略？</p>
<ul>
<li>通过 <code>Executors.priviledgedThreadFactory</code> 方法会返回一个有安全策略的线程工厂</li>
<li>线程工厂创建出来的线程，拥有与创建线程池的线程相同的访问权限、上下文权限</li>
</ul>
<h3 id="2-6-生命钩子"><a href="#2-6-生命钩子" class="headerlink" title="2.6 生命钩子"></a>2.6 生命钩子</h3><p>线程池的钩子？</p>
<ul>
<li><code>beforeExecute</code>：在任务执行前调用</li>
<li><code>afterExecute</code>：在任务执行后调用</li>
<li><code>terminated</code>：在线程池关闭后调用</li>
</ul>
<p>钩子的作用？</p>
<ul>
<li>可以用于添加日志、计时、监视、统计信息收集等功能</li>
<li>可以用于释放资源、清理数据、发送通知等</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimingThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong numTasks = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong totalTime = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Thread %s: start %s%n&quot;</span>, t, r);</span><br><span class="line">        startTime.set(System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> taskTime = endTime - startTime.get();</span><br><span class="line">            numTasks.incrementAndGet();</span><br><span class="line">            totalTime.addAndGet(taskTime);</span><br><span class="line">            System.out.printf(<span class="string">&quot;Thread %s: end %s, time=%dns%n&quot;</span>, t, r, taskTime);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;Terminated: avg time=%dns&quot;</span>, totalTime.get() / numTasks.get());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.terminated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>07_05_程序关闭</title>
    <url>/lang/java/core/concurrency/07_05_%E7%A8%8B%E5%BA%8F%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<h1 id="程序关闭"><a href="#程序关闭" class="headerlink" title="程序关闭"></a>程序关闭</h1><p>JVM 既可以正常关闭，也可以强行关闭。</p>
<p>正常关闭方式有：</p>
<ul>
<li>最后一个“正常（非守护）”线程结束时</li>
<li>调用了 <code>System.exit()</code> 方法</li>
<li>通过其他特定于平台的方法（比如发送 SIGNAL 信号，或键入 CRTL + C）</li>
</ul>
<span id="more"></span>

<p>强制关闭方式有：</p>
<ul>
<li>调用了 <code>Runtime.getRuntime().halt()</code> 方法</li>
<li>在操作系统中“杀死” JVM 进程</li>
</ul>
<p>不同的关闭方式，JVM 可能会有不同的表现。</p>
<h2 id="一、关闭钩子"><a href="#一、关闭钩子" class="headerlink" title="一、关闭钩子"></a>一、关闭钩子</h2><p>关闭钩子是指通过 <code>Runtime.addShutdownHook(Thread hook)</code> 注册的但未开始的线程。</p>
<p>注意，关闭钩子是一个 Thread 线程对象，执行时是按照线程的方式运行。</p>
<p>正常关闭 JVM 时，会触发关闭钩子的执行：</p>
<ol>
<li>首先调用所有已注册的关闭钩子，关闭钩子（也就是线程）是并发执行的</li>
<li>接着当所有的关闭钩子执行结束后，如果 <code>runFinalizersOnExit</code> 属性为 true，则调用所有已注册的 <code>finalizer</code> 钩子</li>
<li>最后 JVM 进入终结阶段，JVM 会强制关闭，剩余的还未结束的线程（守护或非守护线程）也会被强制结束</li>
</ol>
<p>强制关闭 JVM 时，不会运行关闭钩子。</p>
<p>关闭钩子的设计应该满足：</p>
<ul>
<li>关闭钩子应该是线程安全的，访问共享数据必须使用同步机制</li>
<li>关闭钩子不应该对应用程序的状态或 JVM 的关闭原因做出任何假设，不要依赖程序的状态</li>
<li>关闭钩子之间不应该有依赖关系，否则可能会导致死锁</li>
<li>关闭钩子必须尽快退出，避免延迟 JVM 关闭时间</li>
<li>关闭钩子不应该抛出异常，避免导致 JVM 关闭失败</li>
</ul>
<p>关闭钩子的设计应该要尽量简单，比如做一些程序的清理工作。</p>
<h2 id="二、守护线程"><a href="#二、守护线程" class="headerlink" title="二、守护线程"></a>二、守护线程</h2><ul>
<li>线程可以分为2种：普通线程和守护线程</li>
<li>守护线程和普通线程之间的差异仅在于当线程退出时发生的操作</li>
<li>守护线程是一个特殊的线程，它不会阻碍程序关闭，而是会在程序关闭时自动结束</li>
<li>尽可能少用守护线程，因为它很容易就被抛弃，而大部分情况下线程都需要在退出时清理资源</li>
<li>守护线程最好用于执行“内部”任务，执行一些周期性任务，比如清理缓存等</li>
</ul>
<h2 id="三、终结器"><a href="#三、终结器" class="headerlink" title="三、终结器"></a>三、终结器</h2><ul>
<li>垃圾回收器在回收垃圾对象时，会先执行对象中定义的终结器 <code>finalize()</code></li>
<li>避免使用终结器，终结器并不保证它会在何时运行，是否会运行</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序的关闭，需要各个环节的相互配合才能完成：</p>
<ul>
<li>程序关闭，需要等待服务停止</li>
<li>服务停止，需要等待线程结束</li>
<li>线程结束，需要等待任务完成/取消</li>
<li>任务取消，需要通过中断来完成</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>07_04_服务停止</title>
    <url>/lang/java/core/concurrency/07_04_%E6%9C%8D%E5%8A%A1%E5%81%9C%E6%AD%A2/</url>
    <content><![CDATA[<h1 id="服务停止"><a href="#服务停止" class="headerlink" title="服务停止"></a>服务停止</h1><p>应用程序中通常会创建拥有多个线程的服务，比如线程池。</p>
<p>一般来说，服务的生命周期基本都比线程的生命周期要长。</p>
<p>当要停止服务时，服务拥有的这些线程也需要同时结束，所以服务应该要提供相应的生命周期方法，比如 <code>shutdown()</code>、<code>shutdownNow()</code> 这样的。</p>
<span id="more"></span>

<h2 id="一、结束正在运行的线程"><a href="#一、结束正在运行的线程" class="headerlink" title="一、结束正在运行的线程"></a>一、结束正在运行的线程</h2><p>服务如何结束正在运行的线程？理论上可以通过中断来关闭。</p>
<p>中断线程只能由其所有者才能做，而服务是线程的所有者，刚好可以对线程执行中断。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogWriter</span><span class="params">(Writer writer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        logger = <span class="keyword">new</span> LoggerThread(writer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    writer.println(queue.take());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅只是中断了线程，就可以关闭线程了吗？</p>
<p>还不行，因为中断还有可能来着其他未知的地方，比如非所有者发起的非法中断。</p>
<p>而且直接退出也有可能会丢失部分信息，比如上面的例子就会导致后面的日志信息丢失。</p>
<p>一个好的服务，应该具备更好的关闭线程机制。</p>
<h3 id="1-1-关闭标志"><a href="#1-1-关闭标志" class="headerlink" title="1.1 关闭标志"></a>1.1 关闭标志</h3><p>可以在服务中设置一个标志，表明服务要停止了，线程应该要结束。</p>
<p>此时禁止向线程提交任何数据，等线程清理完当前剩余的数据后，就可以退出了。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread loggerThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrintWriter writer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> reservations;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loggerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            isShutdown = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        loggerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShutdown) &#123;</span><br><span class="line">                <span class="comment">// 服务关闭了，禁止继续提交日志</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Shutdown&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录日志数量</span></span><br><span class="line">            ++reservations;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(LogService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="comment">// 服务关闭且剩余日志都处理完了，线程才能退出</span></span><br><span class="line">                        <span class="keyword">if</span> (isShutdown &amp;&amp; reservations == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String msg = queue.take();</span><br><span class="line">                    <span class="keyword">synchronized</span> (LogService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        reservations--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    writer.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 即使发生了中断，只要服务没关闭就继续执行</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过设置“请求关闭”标志，避免了日志的提交，并且服务线程是在处理完日志后才退出的。</p>
<h3 id="1-2-“毒丸”对象"><a href="#1-2-“毒丸”对象" class="headerlink" title="1.2 “毒丸”对象"></a>1.2 “毒丸”对象</h3><p>当服务是一种类似生产者-消费者模式的运行方式时，还有一种“毒丸”方式可以用。</p>
<p>“毒丸”，是将一个结束对象放到处理队列中，当处理线程收到这个对象时，就立即结束退出。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogPoisonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread loggerThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrintWriter writer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poison = <span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            isShutdown = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 放入“毒丸”</span></span><br><span class="line">                queue.put(poison);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        loggerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShutdown) &#123;</span><br><span class="line">                <span class="comment">// 服务关闭了，禁止继续提交日志</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Shutdown&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    String msg = queue.take();</span><br><span class="line">                    <span class="comment">// 当遇到了“毒丸”对象，就立即停止</span></span><br><span class="line">                    <span class="keyword">if</span> (msg == poison) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    writer.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 即使发生了中断，只要服务没关闭就继续执行</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过“毒丸”对象的使用，并不是那么简单，需要满足一些条件：</p>
<ul>
<li>只有在生产者和消费者数量已知的情况下，“毒丸”对象才能使用</li>
<li>“毒丸”对象只有在无界队列中才能可靠工作</li>
</ul>
<p>一颗“毒丸”，只能停止一条线程，所以如果有多条生产者-消费者线程，那就需要提供多个“毒丸”。</p>
<p>提交“毒丸”的时候，不能被阻塞，否则会存在线程阻塞，关闭操作不应该被阻塞，所以只能用无界队列。</p>
<h2 id="二、处理非正常的线程终止"><a href="#二、处理非正常的线程终止" class="headerlink" title="二、处理非正常的线程终止"></a>二、处理非正常的线程终止</h2><p>线程并非一定会正常终止，而是可能会提前死亡。</p>
<p>导致线程提前死亡的主要原因就是 <code>RuntimeException</code> 异常，而任何代码都可能抛出 <code>RuntimeException</code> 异常。</p>
<h3 id="2-1-主动捕获异常"><a href="#2-1-主动捕获异常" class="headerlink" title="2.1 主动捕获异常"></a>2.1 主动捕获异常</h3><p>处理线程异常死亡的最简单方式，就是捕获异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            runTask(getTaskFromWorkQueue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        thrown = e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadExited(<span class="keyword">this</span>, thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获异常后，再通过正常方式退出线程，这样可以降低线程异常死亡对程序的影响。</p>
<h3 id="2-2-异常处理回调"><a href="#2-2-异常处理回调" class="headerlink" title="2.2 异常处理回调"></a>2.2 异常处理回调</h3><p>除了主动捕获异常的方式，在 Thread API 中还提供了异常回调接口 <code>UncaughtExceptionHandler</code>。</p>
<p><code>UncaughtExceptionHandler</code> 可以用于处理线程由于未捕获异常而终止的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要实现这个接口，并将其注册到线程对象中即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.setUncaughtExceptionHandler(<span class="keyword">new</span> UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外，Thread 还提供了全局的异常回调接口 <code>Thread.setDefaultUncaughtExceptionHandler</code>。</p>
<h2 id="三、关闭-ExecutorService"><a href="#三、关闭-ExecutorService" class="headerlink" title="三、关闭 ExecutorService"></a>三、关闭 ExecutorService</h2><p><code>ExecutorService</code> 提供了2种方式停止服务：</p>
<ul>
<li><code>shutdownNow()</code>：强制停止服务，关闭速度快，但是存在很大的风险，任务可能在执行过程中被迫结束</li>
<li><code>shutdown()</code>：正常停止服务，会等到队列中的所有任务都执行完毕后才停止服务</li>
</ul>
<p>这2种方式的差别就在于各自的安全性和响应性。</p>
<h3 id="3-1-强制关闭-shutdownNow"><a href="#3-1-强制关闭-shutdownNow" class="headerlink" title="3.1 强制关闭 shutdownNow"></a>3.1 强制关闭 shutdownNow</h3><p><code>shutdownNow()</code> 会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务。</p>
<p>但是没有常规办法识别出哪些任务已经开始但尚未结束，即不知道哪些任务处于可执行状态。</p>
<p>可以用以下的方法来跟踪关闭后被取消的任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; tasksCancelledAtShutdown = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        exec.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 如果服务关闭了，并且线程被中断了</span></span><br><span class="line">                <span class="keyword">if</span> (isShutdown() &amp;&amp; Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">// 关闭后被取消的线程</span></span><br><span class="line">                    tasksCancelledAtShutdown.add(runnable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这个方法依赖于任务不会屏蔽中断请求，否则没有办法跟踪。</p>
<h3 id="3-2-正常关闭-shutdown"><a href="#3-2-正常关闭-shutdown" class="headerlink" title="3.2 正常关闭 shutdown"></a>3.2 正常关闭 shutdown</h3><p><code>shutdown()</code> 只会尝试取消正在执行的任务，然后就直接返回了。</p>
<p>等待队列中所有任务执行完成后，<code>ExecutorService</code> 才会真正停止。</p>
<p>不过，为了避免任务长时间不结束，一般都会加上超时等待：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkMail</span><span class="params">(Set&lt;String&gt; hosts, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> AtomicBoolean hasMail = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String host : hosts) &#123;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (checkMail(host)) &#123;</span><br><span class="line">                    hasMail.set(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 停止服务</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        <span class="comment">// 超时等待服务停止，避免线程一直不结束</span></span><br><span class="line">        exec.awaitTermination(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasMail.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shutdown()</code> 虽然好，但就是存在永远停止不了的风险。</p>
<p>所以正常停止一般都是等待超时后，再循环等待，或者直接强制停止。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>07_02_线程中断</title>
    <url>/lang/java/core/concurrency/07_02_%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><p>中断线程，指的是向线程发起一个中断信号。</p>
<p>其目的是为了中断线程，对象是线程，而不是线程内运行的任务。</p>
<span id="more"></span>

<h2 id="一、中断策略"><a href="#一、中断策略" class="headerlink" title="一、中断策略"></a>一、中断策略</h2><p>任务有取消策略，线程也有对应的中断策略。</p>
<ul>
<li>中断策略：规定了线程如何解释某个中断请求</li>
<li>中断策略，不是指如何中断线程，而是指线程在收到中断后，如何处理这个中断请求</li>
</ul>
<p>具体来说，就是在线程发现中断时：</p>
<ul>
<li>该做什么工作（需要的话）</li>
<li>哪些工作单元对于中断来说是原子操作</li>
<li>以多快的速度响应中断</li>
</ul>
<p>每个线程都有各自的中断策略，可以有不同的处理。</p>
<h2 id="二、屏蔽中断策略"><a href="#二、屏蔽中断策略" class="headerlink" title="二、屏蔽中断策略"></a>二、屏蔽中断策略</h2><p>最简单的中断策略，就是屏蔽忽略线程的中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IgnoreThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable task;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task = tasks.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 屏蔽忽略所有的中断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种完全屏蔽中断的行为，不是一种很合理的方式，过于粗暴。</p>
<h2 id="三、结束线程策略"><a href="#三、结束线程策略" class="headerlink" title="三、结束线程策略"></a>三、结束线程策略</h2><p>最合理的中断策略，就是线程级取消操作或服务级取消操作：</p>
<ul>
<li>线程发现中断后，尽快退出结束，在必要时进行清理，通知某个所有者该线程已经退出</li>
</ul>
<p>比如说，线程可以运行多个任务，如果中断了线程，那还得等任务都执行完之后才能退出。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable task;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="comment">// 检查是否发生了中断</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                task = tasks.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 中断线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理</span></span><br><span class="line">            cleanup();</span><br><span class="line">            <span class="comment">// 通知结束</span></span><br><span class="line">            notifyExit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收到中断后结束线程，算是一种比较合理的中断策略了。</p>
<h2 id="四、重启线程策略"><a href="#四、重启线程策略" class="headerlink" title="四、重启线程策略"></a>四、重启线程策略</h2><p>还有其他的中断策略，比如暂停服务或重启服务：</p>
<ul>
<li>线程收到中断后，它先是销毁当前线程，然后再重新创建一个新的线程来替代</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RebuildThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable task;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="comment">// 检查是否发生了中断</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                task = tasks.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 中断线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 重启新线程</span></span><br><span class="line">            createWorker(tasks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种重启线程策略，实际在线程池中可能会用到。</p>
<p>因为如果一个线程异常退出后，线程池可能需要补充一个新线程来恢复之前的规模。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>中断线程：</p>
<ul>
<li>中断线程，指的是向线程发起一个中断信号</li>
<li>中断线程，对象是线程，而不是线程内运行的任务</li>
</ul>
<p>线程如何解释某个中断请求：</p>
<ul>
<li>该做什么工作（需要的话）</li>
<li>哪些工作单元对于中断来说是原子操作</li>
<li>以多快的速度响应中断</li>
</ul>
<p>中断策略：</p>
<ul>
<li>屏蔽中断策略</li>
<li>结束线程策略</li>
<li>重启线程策略</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>07_03_中断响应</title>
    <url>/lang/java/core/concurrency/07_03_%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h1 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h1><p>在取消任务和中断线程中，中断都起到了很大作用：</p>
<ul>
<li>取消任务，最合理的方式就是使用中断</li>
<li>中断线程，线程收到中断后作何处理</li>
</ul>
<p>但是有个问题：</p>
<ul>
<li>任务和线程都能接收中断请求，那怎么区分？</li>
</ul>
<p>也就是，中断响应由谁来负责？</p>
<span id="more"></span>

<h2 id="一、区分任务取消和线程中断"><a href="#一、区分任务取消和线程中断" class="headerlink" title="一、区分任务取消和线程中断"></a>一、区分任务取消和线程中断</h2><ul>
<li>任务取消和线程中断，是 2 种不同的行为</li>
<li>任务取消的目的是结束任务执行；线程中断的目的是向线程发送中断信号</li>
<li>任务取消的对象是任务；线程中断的对象是线程</li>
<li>中断事件，是从下往上冒泡的，而任务运行在线程内，所以是任务先收到中断，才轮到线程</li>
</ul>
<h2 id="二、避免任务屏蔽中断"><a href="#二、避免任务屏蔽中断" class="headerlink" title="二、避免任务屏蔽中断"></a>二、避免任务屏蔽中断</h2><p>由于是任务先收到中断，如果任务把中断屏蔽了，那后面线程就收不到中断信息了。</p>
<p>所以，不管在何种情况下：</p>
<ul>
<li>任务收到中断后，无论任务是否响应中断，都不应该清除中断信息</li>
<li>只有实现了中断策略的代码才可以屏蔽中断请求</li>
</ul>
<p>也就是说，不要在任务中随便屏蔽中断信号。</p>
<p>错误示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// 错误做法</span></span><br><span class="line">        <span class="comment">// 不要捕获中断后，什么都不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确做法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// 正确做法</span></span><br><span class="line">        <span class="comment">// 把中断信号恢复回来</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，如果没有实现中断策略，在收到中断后有2种处理策略：</p>
<ul>
<li>传递异常：将中断异常抛出，交由调用者处理。比如代码库都是这样做的</li>
<li>恢复中断状态：不想或没办法传递异常时，可以再次调用 <code>interrupt</code> 方法来恢复中断状态</li>
</ul>
<p>任务只要保证中断信息能留下来即可，至于什么时候恢复，可以自由选择。</p>
<p>比如，可以等所有任务执行完成后，再恢复中断信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayExitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable task;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 检查是否发生了中断</span></span><br><span class="line">                    <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                        <span class="comment">// 记录中断信息</span></span><br><span class="line">                        interrupted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    task = getNextTask();</span><br><span class="line">                    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 记录中断信息</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                <span class="comment">// 恢复中断信息</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的任务，可能中断处理方式不同，但最终应该都能够保留中断状态才对。</p>
<p>除非确认中断信号已经没用了，否则任务万不可屏蔽中断请求。</p>
<h2 id="三、线程只能由所有者中断"><a href="#三、线程只能由所有者中断" class="headerlink" title="三、线程只能由所有者中断"></a>三、线程只能由所有者中断</h2><p>由于每个线程都有各自的中断策略，所以不要随便中断一个未知的线程。</p>
<ul>
<li>线程只能由其所有者中断，或者知晓中断对线程的含义才可以中断，否则不应该中断该线程</li>
</ul>
<p>因为不清楚中断策略，就不知道中断线程后会发生什么，会导致什么结果。</p>
<p>比如说，线程在收到中断后立即退出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable task;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                task = tasks.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 中断线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，中断后剩余未做的任务就不会再执行了，而这未必是任务提交人所要的结果。</p>
<p>所以，中断前必须先了解线程的中断策略，否则胡乱使用中断可能引发很多不可预料的结果。</p>
<h2 id="四、单独取消任务"><a href="#四、单独取消任务" class="headerlink" title="四、单独取消任务"></a>四、单独取消任务</h2><p>既然要把任务取消和线程中断区分开，那么应该怎么区分呢？</p>
<p>虽然都是用中断，但是可以将它们俩的调用方式区分开来。</p>
<ul>
<li>任务取消：封装一套任务取消的方式，比如 <code>Future.cancel()</code></li>
<li>线程中断：依旧使用原有的接口 <code>Thread.interrupt()</code></li>
</ul>
<p>通过使用不同的方式，就能大致区分它们（注意不是绝对的）。</p>
<p>可以单独封装任务的取消，比如这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread taskThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            taskCancel = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 使用中断来取消任务</span></span><br><span class="line">            taskThread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 收到中断请求</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否只是任务取消的中断请求</span></span><br><span class="line">            <span class="keyword">if</span> (taskCancel) &#123;</span><br><span class="line">                <span class="comment">// 在任务结束前，清除中断信息</span></span><br><span class="line">                Thread.interrupted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后这里为什么要清除中断信息？其实目的为了区分任务取消和线程中断。</p>
<p>但这种方式并不完美，本意只是为了清除任务取消引起的中断，但是实际上有可能清除了别的中断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">task.cancel();           <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">taskThread.interrupt();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>如果同时执行任务取消和线程中断，那么取消（1）就有可能把中断（2）的中断信息给清除了。</p>
<p>实际上，Java 的类库中已经封装好了任务的取消操作，就是 <code>Future.cancel()</code>。</p>
<p><code>Future.cancel()</code> 原理和上面代码类似，不过在最后没有清除中断信息，因为有可能清除掉别的中断。</p>
<p>不过还是建议，取消任务时尽量使用 <code>Future.cancel()</code>，而不要直接用 <code>Thread.interrupt()</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>区分任务取消和线程中断</p>
<ul>
<li>任务取消和线程中断，是 2 种不同的行为</li>
<li>任务取消的目的是结束任务执行；线程中断的目的是向线程发送中断信号</li>
<li>任务取消的对象是任务；线程中断的对象是线程</li>
<li>中断事件，是从下往上冒泡的，而任务运行在线程内，所以是任务先收到中断，才轮到线程</li>
</ul>
</li>
<li><p>避免任务屏蔽中断</p>
<ul>
<li>任务收到中断后，无论任务是否响应中断，都不应该清除中断信息</li>
<li>只有实现了中断策略的代码才可以屏蔽中断请求</li>
</ul>
</li>
<li><p>一般来说，如果没有实现中断策略，在收到中断后有2种处理策略：</p>
<ul>
<li>传递异常：将中断异常抛出，交由调用者处理。比如代码库都是这样做的</li>
<li>恢复中断状态：不想或没办法传递异常时，可以再次调用 <code>interrupt</code> 方法来恢复中断状态</li>
</ul>
</li>
<li><p>线程只能由其所有者中断，或者知晓中断对线程的含义才可以中断，否则不应该中断该线程</p>
</li>
<li><p>单独取消任务</p>
<ul>
<li>任务取消：封装一套任务取消的方式，比如 <code>Future.cancel()</code></li>
<li>线程中断：依旧使用原有的接口 <code>Thread.interrupt()</code></li>
</ul>
</li>
<li><p>线程中断实际上依赖于任务的中断处理，如果任务将中断屏蔽了，那么线程将不会收到中断</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>06_任务的执行</title>
    <url>/lang/java/core/concurrency/06_%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h1><h2 id="一、在线程中执行任务"><a href="#一、在线程中执行任务" class="headerlink" title="一、在线程中执行任务"></a>一、在线程中执行任务</h2><h3 id="1-1-串行执行"><a href="#1-1-串行执行" class="headerlink" title="1.1 串行执行"></a>1.1 串行执行</h3><p>串行执行，是指所有任务都在单个线程中串行地执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket connection = serverSocket.accept();</span><br><span class="line">            handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>串行执行，一般来说吞吐率或速响应性都比较差。</p>
<span id="more"></span>

<h3 id="1-2-独立线程执行"><a href="#1-2-独立线程执行" class="headerlink" title="1.2 独立线程执行"></a>1.2 独立线程执行</h3><p>独立线程执行，是指为每个任务单独创建一个新线程，并在新线程中执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket connection = serverSocket.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; handleRequest(connection)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式，可以提供高吞吐率和快响应性。</p>
<p>不过为每个任务创建独立的线程，这受限于服务器的负载能力。</p>
<h3 id="1-3-无限制创建线程存在的问题"><a href="#1-3-无限制创建线程存在的问题" class="headerlink" title="1.3 无限制创建线程存在的问题"></a>1.3 无限制创建线程存在的问题</h3><ul>
<li>线程生命周期的开销非常高：线程的创建和销毁是有代价的，会消耗大量的计算资源</li>
<li>资源消耗：活跃的线程会消耗系统资源，特别是内存资源</li>
<li>稳定性：系统中可创建的线程数量是有限制的，受多个因素制约</li>
</ul>
<h2 id="二、在线程池中执行任务"><a href="#二、在线程池中执行任务" class="headerlink" title="二、在线程池中执行任务"></a>二、在线程池中执行任务</h2><p>在前面的任务执行方式中：</p>
<ul>
<li>串行执行，吞吐率和响应性太差</li>
<li>为每个任务创建独立线程运行，资源管理太麻烦</li>
</ul>
<p>为此，可以取一种折中的方案：</p>
<ul>
<li>创建包含 n 个线程的线程池，来执行 m 个任务，线程和任务比例是 n:m</li>
<li>要求线程池的线程是可以复用的，因为它需要执行多个任务</li>
</ul>
<p>这种线程池方式，既避免了串行执行，也避免了资源不足的情况。</p>
<p>不过，实际的线程池会更复杂，它的基本设计理念是：</p>
<ul>
<li>将任务的提交过程与执行过程解耦开来</li>
<li>用 Runnable 表示任务</li>
<li>用 Executor 来提供任务执行的平台</li>
<li>Executor 还提供了对生命周期的支持、信息统计、程序管理、性能监控等机制</li>
</ul>
<p>线程池的使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorWebServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket connection = serverSocket.accept();</span><br><span class="line">            executor.execute(() -&gt; handleRequest(connection));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，线程池就是提供了自动管理线程和任务的功能。</p>
<h3 id="2-1-执行策略"><a href="#2-1-执行策略" class="headerlink" title="2.1 执行策略"></a>2.1 执行策略</h3><p>线程池中，还提供了设置执行策略的方式。</p>
<p>执行策略定义了任务执行的各种情况：</p>
<ul>
<li>在什么线程中执行任务？</li>
<li>任务按照什么顺序执行（FIFO、LIFO、优先级）？</li>
<li>有多少个任务可以并发执行？</li>
<li>任务等待队列能放多少个？</li>
<li>任务拒绝策略是什么（丢弃最新任务、丢弃最老任务）？</li>
<li>任务执行前后，应该执行哪些动作？</li>
</ul>
<p>在创建线程池时，可以自行决定选择何种执行策略，以适应实际的需求场景。</p>
<h3 id="2-2-线程池类型"><a href="#2-2-线程池类型" class="headerlink" title="2.2 线程池类型"></a>2.2 线程池类型</h3><p>线程池的优点：</p>
<ul>
<li>自动管理线程和任务</li>
<li>可以重用线程，避免线程创建和销毁带来的巨大开销</li>
<li>线程不销毁，可以快速执行任务，从而避免了任务的延迟执行，提高了响应性</li>
<li>防止创建线程过多，降低了线程之间的竞争，避免系统资源耗尽</li>
</ul>
<p>Java 类库中，提供了几种常用的线程池：</p>
<ul>
<li>固定长度线程池（newFixedThreadPool）：限制了线程最大数量，每次提交任务时，就会创建一个线程，直到达到线程最大数量为止</li>
<li>可缓存线程池（newCachedThreadPool）：每次提交任务，就会创建一个新线程，不存在线程数量限制</li>
<li>单线程池（newSingleThreadExecutor）：线程池中只有一个线程，提交任务时相当于串行执行</li>
<li>定时线程池（newScheduledThreadPool）：限制了线程最大数量，以延迟或定时方式执行任务</li>
</ul>
<p>除了这几种常用线程池，Java 类库中还提供了自定义线程池，不过需要自己实现接口。</p>
<h3 id="2-3-线程池生命周期"><a href="#2-3-线程池生命周期" class="headerlink" title="2.3 线程池生命周期"></a>2.3 线程池生命周期</h3><p>JVM 只有在所有（非守护）线程全部终止后才会退出，所以线程池的线程也要能结束才行。</p>
<p>ExecutorService 扩展了 Executor 接口，提供了线程池的生命周期。</p>
<p>线程池的生命周期有3种状态：</p>
<ul>
<li>运行：线程池创建后，就处于运行状态</li>
<li>关闭：执行 <code>shutdown</code>/<code>shotdownNow</code> 方法后，线程池处于关闭状态，拒绝提交新任务，但是会等已提交任务执行结束才终止</li>
<li>终止：线程池中所有任务都完成后，进入终止状态</li>
</ul>
<p>比如，支持关闭操作的线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (!executor.isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Socket connection = serverSocket.accept();</span><br><span class="line">                executor.execute(() -&gt; handleRequest(connection));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!executor.isShutdown()) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序结束时，必须把线程池关闭，否则线程是不会被回收的，JVM 也不会终止。</p>
<h2 id="三、任务的执行"><a href="#三、任务的执行" class="headerlink" title="三、任务的执行"></a>三、任务的执行</h2><h3 id="3-1-找出任务的并行性"><a href="#3-1-找出任务的并行性" class="headerlink" title="3.1 找出任务的并行性"></a>3.1 找出任务的并行性</h3><p>找到任务的并行性，提取出可并发执行的任务：</p>
<ul>
<li>有时候，任务边界是不明显的，需要找出可并发执行的任务</li>
<li>使用线程池执行任务，要求必须将任务描述为一个 Runnable</li>
</ul>
<p>比如说，渲染 HTML 页面，渲染图片和渲染其他节点可以分开成不同的任务并发执行。</p>
<h3 id="3-2-确定任务的类型"><a href="#3-2-确定任务的类型" class="headerlink" title="3.2 确定任务的类型"></a>3.2 确定任务的类型</h3><p>在执行任务前，应该要确认任务的类型，它需要怎么执行：</p>
<ul>
<li>Runnable 是普通的可执行的任务，没有返回值</li>
<li>Callable 是带有返回值的的任务</li>
<li>TimerTask 是定时任务，可以延迟或定时执行</li>
<li>Future 提供了有用的接口，可以取消任务的执行</li>
<li>…</li>
</ul>
<p>不同类型的任务，执行的方式不同，找出最合适的任务类型来执行。</p>
<h3 id="3-3-提高任务的并发性"><a href="#3-3-提高任务的并发性" class="headerlink" title="3.3 提高任务的并发性"></a>3.3 提高任务的并发性</h3><ul>
<li>只有大量相互独立且同构的任务并发执行，才能带来真正的性能提升</li>
<li>尽量提交相互独立的任务，减少依赖的任务</li>
<li>尽量把不同任务类型，提交到不同类型的线程池执行</li>
</ul>
<h3 id="3-4-等待任务的完成"><a href="#3-4-等待任务的完成" class="headerlink" title="3.4 等待任务的完成"></a>3.4 等待任务的完成</h3><p>有时候需要等待任务完成后，再执行某些操作，有多种方式可以等待：</p>
<ul>
<li>保留与每个任务关联的 <code>Future</code> 对象，使用它等待任务完成</li>
<li>使用 <code>CompletionService</code> 提供的方法，等待任务完成</li>
<li>使用 <code>ExecutorService</code> 的 <code>invokeAll</code> 方法，等待所有任务完成</li>
</ul>
<p>根据实际需求，是等待单个任务完成，还是等待所有任务完成，再选择不同的方式。</p>
<h3 id="3-5-为任务设置时限"><a href="#3-5-为任务设置时限" class="headerlink" title="3.5 为任务设置时限"></a>3.5 为任务设置时限</h3><p>有时候，任务无法在指定时间内完成，那么就不再需要它的结果了，可以放弃这个任务。</p>
<ul>
<li>可以为任务设置执行时限，超过时限后，任务会被取消，并且不再等待它完成</li>
<li>任务超时后，应该立即停止，避免继续计算浪费计算资源</li>
<li>需要评估任务的执行时间，才能确定任务的执行时限</li>
</ul>
<p>不是所有任务都需要时限，视具体情况而定。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在线程中执行任务：</p>
<ul>
<li>串行执行：所有任务都在一个线程内执行，吞吐率和响应性差</li>
<li>独立线程执行：为每个任务创建独立线程执行，资源消耗过大，且不稳定</li>
</ul>
<p>在线程池中运行：</p>
<ul>
<li>创建包含 n 个线程的线程池，来执行 m 个任务，线程和任务比例是 n:m</li>
<li>要求线程池的线程是可以复用的，因为它需要执行多个任务</li>
<li>将任务的提交过程与执行过程解耦开来</li>
<li>用 Runnable 表示任务</li>
<li>用 Executor 来提供任务执行的平台</li>
<li>Executor 还提供了对生命周期的支持、信息统计、程序管理、性能监控等机制</li>
</ul>
<p>执行策略：</p>
<ul>
<li>在什么线程中执行任务？</li>
<li>任务按照什么顺序执行（FIFO、LIFO、优先级）？</li>
<li>有多少个任务可以并发执行？</li>
<li>任务等待队列能放多少个？</li>
<li>任务拒绝策略是什么（丢弃最新任务、丢弃最老任务）？</li>
<li>任务执行前后，应该执行哪些动作？</li>
</ul>
<p>线程池优点：</p>
<ul>
<li>自动管理线程和任务</li>
<li>可以重用线程，避免线程创建和销毁带来的巨大开销</li>
<li>线程不销毁，可以快速执行任务，从而避免了任务的延迟执行，提高了响应性</li>
<li>防止创建线程过多，降低了线程之间的竞争，避免系统资源耗尽</li>
</ul>
<p>常见线程池：</p>
<ul>
<li>固定长度线程池（newFixedThreadPool）：限制了线程最大数量，每次提交任务时，就会创建一个线程，直到达到线程最大数量为止</li>
<li>可缓存线程池（newCachedThreadPool）：每次提交任务，就会创建一个新线程，不存在线程数量限制</li>
<li>单线程池（newSingleThreadExecutor）：线程池中只有一个线程，提交任务时相当于串行执行</li>
<li>定时线程池（newScheduledThreadPool）：限制了线程最大数量，以延迟或定时方式执行任务</li>
</ul>
<p>线程池生命周期：</p>
<ul>
<li>运行：线程池创建后，就处于运行状态</li>
<li>关闭：执行 <code>shutdown</code>/<code>shotdownNow</code> 方法后，线程池处于关闭状态，拒绝提交新任务，但是会等已提交任务执行结束才终止</li>
<li>终止：线程池中所有任务都完成后，进入终止状态</li>
</ul>
<p>任务的执行：</p>
<ul>
<li>找出任务的并行性</li>
<li>确定任务的类型</li>
<li>提高任务的并发性</li>
<li>等待任务完成</li>
<li>为任务设置时限</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>05_基础构建模块</title>
    <url>/lang/java/core/concurrency/05_%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h1><h2 id="一、同步容器"><a href="#一、同步容器" class="headerlink" title="一、同步容器"></a>一、同步容器</h2><ul>
<li>同步容器类都是线程安全的，比如 Vector 和 HashTable</li>
<li>实现线程安全的方式是：将它们的状态都封装起来，所有对外接口都是同步方法</li>
<li>对容器状态的访问都串行化，保证每次只有一个线程访问容器</li>
<li>能保证单个操作是线程安全的，但是复合操作是不能保证线程安全的</li>
<li>常见的不安全的复合操作包括：迭代、跳转、条件运算</li>
</ul>
<span id="more"></span>

<p>比如，条件运算的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deleteLast</span><span class="params">(Vector&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种复合操作，实际上是线程不安全的。</p>
<p>一般来说，同步容器的复合操作都需要加锁处理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deleteLast</span><span class="params">(Vector&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> list.remove(lastIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步容器类的锁就是对象本身，所以是对同步容器对象加锁。</p>
<p>不过，对于迭代器的处理，加锁并不都是一种好方法：</p>
<ul>
<li>容器元素很多时，对迭代操作加锁，会导致容器被长时间阻塞，影响程序的性能</li>
</ul>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncContainerIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Vector&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代时加锁，可能会使得容器锁无法释放，导致容器不可用。</p>
<p>所以，对于迭代器的处理，还可以用另一种方式处理：克隆容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCloneContainerIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Vector&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        Vector&lt;T&gt; clone = (Vector&lt;T&gt;) list.clone();</span><br><span class="line">        <span class="keyword">for</span> (T t : clone) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，克隆容器时，也存在明显的性能开销，但不会对原容器造成影响。</p>
<p>容器的迭代器使用，除了比较明显的调用以外，一些隐藏方法也可能会用到：</p>
<ul>
<li>hashCode、equals、toString</li>
<li>containsAll、removeAll、retainAll</li>
</ul>
<p>这些方法里面，实际上也隐含了对迭代器的使用，所以，这些方法也是不安全的。</p>
<h2 id="二、并发容器"><a href="#二、并发容器" class="headerlink" title="二、并发容器"></a>二、并发容器</h2><ul>
<li>并发容器类都是线程安全的</li>
<li>实现线程安全的方式是：将它们的状态都封装起来，内部对状态的访问是加锁同步的</li>
<li>并发容器是针对多个线程并发访问设计的，允许多个线程同时访问并发容器</li>
<li>主要用于替代同步的容器，提高并发访问的性能</li>
<li>并发容器的锁不是并发容器对象本身，对其加锁毫无意义</li>
</ul>
<p>比如说：</p>
<ul>
<li>ConcurrentHashMap 用于替代同步的 Map</li>
<li>CopyOnWriteArrayList 用于在遍历操作为主要操作的情况下替代同步的 List</li>
<li>…</li>
</ul>
<p>使用并发容器，可以获得比同步容器更高的并发性能。</p>
<p>由于并发容器的锁是对象本身，所以对并发容器对象加锁是没有意义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncContainer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(ConcurrentHashMap&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (map) &#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap 的锁并不是它自己，所以加锁操作毫无意义。</p>
<p>如果需要对整个容器进行独占访问，并发容器并不适合，这时应该用同步容器。</p>
<h2 id="三、同步工具类"><a href="#三、同步工具类" class="headerlink" title="三、同步工具类"></a>三、同步工具类</h2><ul>
<li>同步工具类，根据自身的状态来协调线程的控制流</li>
<li>特点：<ul>
<li>封装了一些状态，这些状态决定执行的线程是继续执行还是等待</li>
<li>提供了一些方法来对状态进行访问</li>
<li>提供一些方法来等待同步工具类达到某个状态</li>
</ul>
</li>
<li>同步工具类包括：<ul>
<li>闭锁（Latch）</li>
<li>信号量（Semaphore）</li>
<li>栅栏（Barrier）</li>
<li>阻塞队列（BlockingQueue）</li>
</ul>
</li>
</ul>
<h3 id="3-1-闭锁"><a href="#3-1-闭锁" class="headerlink" title="3.1 闭锁"></a>3.1 闭锁</h3><ul>
<li>延迟线程的进度直到其到达终止状态</li>
<li>用于确保某些活动直到其他活动都完成后才继续执行</li>
</ul>
<p>比如说，一个线程等待其他线程完成工作后，再继续执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTask</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 所有线程等待开始信号</span></span><br><span class="line">                    startGate.await();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 线程结束发起信号</span></span><br><span class="line">                        endGate.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    startGate.countDown();</span><br><span class="line">    endGate.await();</span><br><span class="line">    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭锁的作用，就是等待某些线程异步操作完成，再继续往下执行。</p>
<h3 id="3-2-信号量"><a href="#3-2-信号量" class="headerlink" title="3.2 信号量"></a>3.2 信号量</h3><ul>
<li>控制同时访问某个特定资源的操作数量</li>
<li>控制同时执行某个操作的线程数量</li>
</ul>
<p>比如说，信号量可以用于控制容器的元素数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sem.acquire();</span><br><span class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wasAdded = set.add(o);</span><br><span class="line">            <span class="keyword">return</span> wasAdded;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wasAdded) &#123;</span><br><span class="line">                sem.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</span><br><span class="line">        <span class="keyword">if</span> (wasRemoved) &#123;</span><br><span class="line">            sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wasRemoved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过信号量的数量限制，可以控制同时访问某个资源的线程数量。</p>
<h3 id="3-3-栅栏"><a href="#3-3-栅栏" class="headerlink" title="3.3 栅栏"></a>3.3 栅栏</h3><ul>
<li>阻塞一组线程直到某个事件发生</li>
<li>所有线程必须同时到达栅栏位置，才能继续执行</li>
<li>闭锁用于等待事件，栅栏则是等待线程</li>
<li>栅栏是可以重复使用的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTask</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Time</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Time time = <span class="keyword">new</span> Time();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nThreads + 1 是加上了主线程</span></span><br><span class="line">    <span class="keyword">final</span> CyclicBarrier gate = <span class="keyword">new</span> CyclicBarrier(nThreads + <span class="number">1</span>,</span><br><span class="line">            () -&gt; time.value = System.nanoTime() - time.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待所有线程开始</span></span><br><span class="line">                    gate.await();</span><br><span class="line"></span><br><span class="line">                    task.run();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">                    gate.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程开始</span></span><br><span class="line">    gate.await();</span><br><span class="line">    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    gate.await();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> time.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与闭锁不同，闭锁需要等到某个事件通知，如 countDown()，线程才会继续往下执行。</p>
<p>而栅栏等待的就是线程，只要所有线程都到达栅栏位置，就可以继续执行下去。</p>
<h2 id="四、缓存案例"><a href="#四、缓存案例" class="headerlink" title="四、缓存案例"></a>四、缓存案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;K, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;K, V&gt; computer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer</span><span class="params">(Computable&lt;K, V&gt; c)</span> </span>&#123;</span><br><span class="line">        computer = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; result = cache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                FutureTask&lt;V&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; computer.compute(key));</span><br><span class="line">                result = cache.putIfAbsent(key, task);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理并发访问的情况</span></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = task;</span><br><span class="line">                    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待计算完成</span></span><br><span class="line">                <span class="keyword">return</span> result.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>07_01_任务取消</title>
    <url>/lang/java/core/concurrency/07_01_%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88/</url>
    <content><![CDATA[<h1 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h1><p>任务、线程、服务、应用程序之间的关系：</p>
<ul>
<li>任务是最小的执行单元</li>
<li>任务在线程中执行</li>
<li>线程在服务（比如线程池服务）中运行</li>
<li>服务在应用程序（JVM）中运行</li>
</ul>
<span id="more"></span>

<p>取消某个操作的请求有很多，比如：</p>
<ul>
<li>用户请求取消</li>
<li>有时间限制的操作</li>
<li>应用程序事件</li>
<li>运行错误</li>
<li>应用程序关闭</li>
</ul>
<p>不同层次的取消操作，可能会导致不同的结果。</p>
<p>Java 中没有一种安全的抢占式方法来停止线程，所以也没有安全的方式可以直接取消任务。</p>
<p>只有一些协作式的机制，取消任务只能通过这种方式来安全实现。</p>
<h2 id="一、取消策略"><a href="#一、取消策略" class="headerlink" title="一、取消策略"></a>一、取消策略</h2><p>一个可取消的任务必须有取消策略（Cancellation Policy）：</p>
<ul>
<li>How：其他代码如何（How）请求取消任务</li>
<li>When：任务在何时（When）检查是否已经请求了取消</li>
<li>What：响应取消请求时，应该执行哪些（What）操作</li>
</ul>
<p>取消策略详细定义了任务取消的整个流程。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancellationTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取消策略的各个部分分别是：</p>
<ul>
<li>How：调用 <code>cancel()</code> 方法取消任务</li>
<li>When：在循环前验证取消标志 <code>while (!cancelled)</code></li>
<li>What：没有其他操作，直接结束任务</li>
</ul>
<p>对于每一种取消策略，都必须有它的 <code>How</code>，<code>When</code>，<code>What</code>。</p>
<h2 id="二、取消标志策略"><a href="#二、取消标志策略" class="headerlink" title="二、取消标志策略"></a>二、取消标志策略</h2><p>最简单的取消策略，就是使用一个取消标志，而任务定期检查这个标志。</p>
<p>如果设置了取消标志，那么任务就将提前结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCancellationTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger p = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">            p = p.nextProbablePrime();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在任务中检查取消标志，就可以实现取消任务的简单方式。</p>
<p>但是这种方式存在一个问题，那就是如果任务中执行了阻塞操作，任务就可能取消不了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkBlockCancellationTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingDeque&lt;BigInteger&gt; queue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkBlockCancellationTask</span><span class="params">(BlockingDeque&lt;BigInteger&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">                p = p.nextProbablePrime();</span><br><span class="line">                <span class="comment">// 阻塞操作，可能会一致阻塞</span></span><br><span class="line">                queue.put(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如这里执行了阻塞操作 <code>queue.put()</code>，假设操作一直阻塞，那么检查取消标志 <code>canceled</code> 的动作就一直不会触发。</p>
<p>这种情况下，任务没办法取消，只能一直等到阻塞结束后，才能够取消。</p>
<p>这其实和我们想要的效果不一样，我们想要的是那种取消后，任务就准备结束了。</p>
<h2 id="三、线程中断策略"><a href="#三、线程中断策略" class="headerlink" title="三、线程中断策略"></a>三、线程中断策略</h2><p>为了解决阻塞导致任务无法取消的问题，需要用到线程的中断：</p>
<ul>
<li>每个线程都有一个中断状态标志</li>
<li>大部分阻塞操作都支持抛出线程中断异常 <code>InterruptedException</code></li>
<li>JVM 不能保证阻塞方法检测到中断的速度，但是总是可以检测到中断的</li>
<li>线程中断并不会直接中断任务运行，而只是传递了请求中断的消息</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptCancellationTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingDeque&lt;BigInteger&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadInterruptCancellationTask</span><span class="params">(BlockingDeque&lt;BigInteger&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="comment">// 1. 和取消标志一样，定期检查中断标志</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                p = p.nextProbablePrime();</span><br><span class="line">                <span class="comment">// 阻塞操作，可能会一致阻塞</span></span><br><span class="line">                queue.put(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 2. 还提供了中断异常的取消方式</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和取消标志差不多，只是线程中断提供的取消功能更全面：它可以取消阻塞的任务。</p>
<ul>
<li> 通常，中断是实现任务取消的最合理方式</li>
</ul>
<p>所以，如果任务代码能够响应中断，最好使用中断作为取消策略。</p>
<h2 id="四、处理不可中断的操作"><a href="#四、处理不可中断的操作" class="headerlink" title="四、处理不可中断的操作"></a>四、处理不可中断的操作</h2><p>中断虽然能满足大部分的需求，但是：</p>
<ul>
<li>不是所有方法或阻塞操作都支持响应中断</li>
</ul>
<p>比如 Socket I/O 等方法，都不支持中断。</p>
<p>但是，可以使用类似中断的手段来取消任务，比如 Socket 可以用 <code>close()</code> 方法结束阻塞：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这种模拟中断的方式，需要事先了解线程阻塞的原因以及如何结束线程阻塞才行。</p>
<p>类似这种不可中断的阻塞，在 Java 类库中大约有这几种：</p>
<ul>
<li>Java.io 包中的 Socket I/O</li>
<li>Java.io 包中的同步 I/O</li>
<li>Selector 包中的异步 I/O</li>
<li>获取某个锁，指的是 Lock</li>
</ul>
<p>针对这些情况，可以利用类似上面的方式来封装中断处理。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>04_对象的组合</title>
    <url>/lang/java/core/concurrency/04_%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h1><h2 id="一、设计线程安全的类"><a href="#一、设计线程安全的类" class="headerlink" title="一、设计线程安全的类"></a>一、设计线程安全的类</h2><h3 id="1-1-设计过程"><a href="#1-1-设计过程" class="headerlink" title="1.1 设计过程"></a>1.1 设计过程</h3><h4 id="1-1-1-收集对象状态"><a href="#1-1-1-收集对象状态" class="headerlink" title="1.1.1 收集对象状态"></a>1.1.1 收集对象状态</h4><ul>
<li>收集类对象的所有状态</li>
<li>如果对象中引用了其他对象，那么该对象的状态也包括引用对象的状态</li>
<li>如果发布了某个可变对象的引用，那么就不应该算作对象的状态</li>
</ul>
<span id="more"></span>

<h4 id="1-1-2-收集同步需求"><a href="#1-1-2-收集同步需求" class="headerlink" title="1.1.2 收集同步需求"></a>1.1.2 收集同步需求</h4><ul>
<li>识别对象状态中哪些需要同步处理，即可能被多线程访问的状态</li>
<li>找出对象状态的先验条件、不变性条件、后验条件</li>
<li>如果不了解对象的不变性条件和后验条件，那么就不能确保线程安全性</li>
</ul>
<p>1）先验条件：验证是否可以进行状态迁移</p>
<p>状态迁移前，先验证某些条件是否满足，满足则继续：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isReady) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先验条件，主要是验证状态迁移前是否满足条件，比如 <code>if (!isReady)</code>。</p>
<p>2）不变性条件：状态值是否是有效的</p>
<p>针对状态变量本身进行验证，验证值是否有效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count can not be negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>count &gt;= 0</code> 属于有效状态；<code>count &lt; 0</code> 属于无效状态，所以 count 状态的不变性条件是：<code>count &gt;= 0</code>。</p>
<p>不变性条件，着重验证状态值是否有效，不能超出它设定的值域范围，比如这里的 <code>count &gt;= 0</code>。</p>
<p>3）后验条件：状态迁移后的值验证</p>
<p>状态迁移后，验证某些条件是否还满足，满足则完成状态迁移：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setMin</span><span class="params">(<span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; <span class="keyword">this</span>.max) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，min 传入的值是有效的，即满足不变性条件。</p>
<p>但是它还有额外的约束条件，那就是 <code>min &lt;= max</code>，这就属于后验条件，用于验证状态迁移的有效性。</p>
<h4 id="1-1-3-选择状态的并发访问策略"><a href="#1-1-3-选择状态的并发访问策略" class="headerlink" title="1.1.3 选择状态的并发访问策略"></a>1.1.3 选择状态的并发访问策略</h4><ul>
<li>选择状态的并发访问策略，以便确保状态的正确性</li>
<li>比如使用原子类、加锁等</li>
</ul>
<h3 id="1-2-线程安全实现-实例封闭"><a href="#1-2-线程安全实现-实例封闭" class="headerlink" title="1.2 线程安全实现-实例封闭"></a>1.2 线程安全实现-实例封闭</h3><ul>
<li>将状态都封装在对象内部</li>
<li>限制只能通过对象的方法访问状态</li>
</ul>
<h4 id="1-2-1-共享监视器模式"><a href="#1-2-1-共享监视器模式" class="headerlink" title="1.2.1 共享监视器模式"></a>1.2.1 共享监视器模式</h4><p>将当前对象作为锁对象，外部也可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareSync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用状态对象作为锁，那么在类外面也可以使用这个锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(ShareSync sync)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sync) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式会将锁暴露给外面，是一种共享的监视器模式。</p>
<p>不过，外部代码如果错误地获取锁对象，有可能会产生活跃性问题。</p>
<h4 id="1-2-2-私有监视器模式"><a href="#1-2-2-私有监视器模式" class="headerlink" title="1.2.2 私有监视器模式"></a>1.2.2 私有监视器模式</h4><p>对象内部使用私有的监视器，外部不能访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateSync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于加锁对象是私有的，在类外面也不能使用这个锁，是一种私有的监视器模式。</p>
<h4 id="1-2-3-重入锁模式"><a href="#1-2-3-重入锁模式" class="headerlink" title="1.2.3 重入锁模式"></a>1.2.3 重入锁模式</h4><p>除了使用监视器，还可以使用重入锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantSync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重入锁模式，除了写法有些不同，功能上和监视器模式差不多。</p>
<p>和监视器模式一样，重入锁模式也可以分为共享模式和私有模式。</p>
<h2 id="二、线程安全类的组合"><a href="#二、线程安全类的组合" class="headerlink" title="二、线程安全类的组合"></a>二、线程安全类的组合</h2><p>当从头构建一个类，或者将多个非线程安全的类组合在一起时，同步策略是相当有用的。</p>
<p>但是如果类中的各个状态都是线程安全的，那这个时候是否还需要同步策略？</p>
<h3 id="2-1-单状态组合"><a href="#2-1-单状态组合" class="headerlink" title="2.1 单状态组合"></a>2.1 单状态组合</h3><ul>
<li>单状态是普通类型，需要同步策略，由组合提供同步</li>
<li>单状态是线程安全类，可以由自身保证线程安全性，无需额外同步策略</li>
</ul>
<p>普通状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleSafeState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-多独立状态组合"><a href="#2-2-多独立状态组合" class="headerlink" title="2.2 多独立状态组合"></a>2.2 多独立状态组合</h3><ul>
<li>相互独立的多个普通状态，需要同步策略，由组合提供同步</li>
<li>相互独立的多个线程安全状态，无需额外的同步策略，由状态自身保证线程安全性</li>
</ul>
<p>普通独立状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全独立状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiSafeState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean ready = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ready.getAndSet(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-3-多关联状态组合"><a href="#2-3-多关联状态组合" class="headerlink" title="2.3 多关联状态组合"></a>2.3 多关联状态组合</h3><ul>
<li>有关联/依赖关系的多个状态，必须要同步策略，由组合提供同步</li>
<li>关联关系：先验条件、不定性条件、后验条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiRelationState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setMin</span><span class="params">(<span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; <span class="keyword">this</span>.max) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setMax</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; <span class="keyword">this</span>.min) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-公开状态组合"><a href="#2-4-公开状态组合" class="headerlink" title="2.4 公开状态组合"></a>2.4 公开状态组合</h3><ul>
<li>组合在一起的状态，以公开的方式发布给外部，实现状态共享</li>
<li>组合不需要再提供同步策略，因为已经不算在自己的管辖范围内了</li>
<li>由外部代码自行对发布的共享状态添加同步策略</li>
</ul>
<p>对外发布共享状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiPublicState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> AtomicBoolean ready = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部自己控制同步策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MultiPublicState state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">            state.count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.ready.getAndSet(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="三、线程安全类的扩展"><a href="#三、线程安全类的扩展" class="headerlink" title="三、线程安全类的扩展"></a>三、线程安全类的扩展</h2><ul>
<li>如何给线程安全类添加新的方法？</li>
<li>保证原子性、保证线程安全性？</li>
</ul>
<h3 id="3-1-客户端加锁机制"><a href="#3-1-客户端加锁机制" class="headerlink" title="3.1 客户端加锁机制"></a>3.1 客户端加锁机制</h3><p>客户端代码自己控制同步策略，实现所需功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putIfAbstent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!list.contains(value)) &#123;</span><br><span class="line">                list.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：不需要修改原始类的代码。</p>
<p>缺点：所有用到这个方法的地方，都要重复写一份同样的代码，容易出错。</p>
<h3 id="3-2-修改原始类源码"><a href="#3-2-修改原始类源码" class="headerlink" title="3.2 修改原始类源码"></a>3.2 修改原始类源码</h3><p>在有源码修改权的情况下，直接在原始类上添加线程安全方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putIfAbstent</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!contains(value)) &#123;</span><br><span class="line">            add(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：实现简单，封装性好，是最安全的。</p>
<p>缺点：第三方的代码基本上没办法修改。</p>
<h3 id="3-3-扩展原始类"><a href="#3-3-扩展原始类" class="headerlink" title="3.3 扩展原始类"></a>3.3 扩展原始类</h3><p>在原始类支持继承扩展的情况下，直接继承添加新方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildVector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putIfAbstent</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!contains(value)) &#123;</span><br><span class="line">            add(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：实现简单，可维护性好。</p>
<p>缺点：继承依赖于原始类对象，一旦原始类发生变更，继承类也需要同时更新；不是所有类都支持继承；继承还会增加类结构的复杂度。</p>
<h3 id="3-4-代理原始类对象"><a href="#3-4-代理原始类对象" class="headerlink" title="3.4 代理原始类对象"></a>3.4 代理原始类对象</h3><p>使用组合代理原始对象，包装一层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VectorProxy</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;E&gt; vector;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VectorProxy</span><span class="params">(Vector&lt;E&gt; vector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vector = vector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putIfAbstent</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vector.contains(value)) &#123;</span><br><span class="line">                vector.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：实现简单，封装性好，可维护性好。</p>
<p>缺点：对象类型发生变化，所有用到原始类的地方都需要修改。多加了一层，可能有轻微的性能损失。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计线程安全的类：</p>
<ul>
<li>收集对象状态</li>
<li>收集同步需求</li>
<li>选择状态的并发访问策略</li>
</ul>
<p>实例封闭：</p>
<ul>
<li>共享监视器模式</li>
<li>私有监视器模式</li>
<li>重入锁模式</li>
</ul>
<p>线程安全类的组合：</p>
<ul>
<li>单状态组合</li>
<li>多独立状态组合</li>
<li>多关联状态组合</li>
<li>公开状态组合</li>
</ul>
<p>线程安全类的扩展：</p>
<ul>
<li>客户端加锁机制</li>
<li>修改原始类源码</li>
<li>扩展原始类</li>
<li>代理原始类对象</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>03_对象的共享</title>
    <url>/lang/java/core/concurrency/03_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h1><h2 id="一、共享对象可能存在的问题？"><a href="#一、共享对象可能存在的问题？" class="headerlink" title="一、共享对象可能存在的问题？"></a>一、共享对象可能存在的问题？</h2><ul>
<li>多个线程同时访问或修改共享对象时，可能会出现冲突，即原子性问题</li>
<li>一个线程修改对象状态后，其他线程未必能够看到发生的变化，即内存可见性</li>
</ul>
<span id="more"></span>

<h2 id="二、共享对象的可见性"><a href="#二、共享对象的可见性" class="headerlink" title="二、共享对象的可见性"></a>二、共享对象的可见性</h2><h3 id="2-1-可见性问题有哪些？"><a href="#2-1-可见性问题有哪些？" class="headerlink" title="2.1 可见性问题有哪些？"></a>2.1 可见性问题有哪些？</h3><p>内存可见性可能带来的问题：</p>
<ul>
<li>无法确保一个线程在修改状态时，其他线程能够适时看到状态变化</li>
<li>比如，多核运CPU、多级缓存、重排序等，都可能会影响线程对对象状态的读取</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Novisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上说，等到 ready 为 true 后，子线程就会打印出 number 的值 42。</p>
<p>但是由于内存可见性，可能会出现几种情况：</p>
<ul>
<li><p>主线程在修改 ready 为 true 后，可能子线程看到的 ready 仍然是 false，结果就是程序一直循环等待下去；</p>
</li>
<li><p>还有一种可能，就是子线程会打印出 0，而不是 42。因为存在重排序的问题，代码 <code>ready = true;</code> 有可能会在 <code>number = 42;</code> 之前执行，导致数据与预期不符。</p>
</li>
</ul>
<p>内存可见性，会带来一些数据读写的有效性问题，比如失效数据、错误数据等。</p>
<h4 id="2-1-1-失效数据"><a href="#2-1-1-失效数据" class="headerlink" title="2.1.1 失效数据"></a>2.1.1 失效数据</h4><ul>
<li>一个线程修改了对象状态，其他线程可能获取到状态的最新值，也可能获取到旧的失效值</li>
<li>失效数据可能会导致意料之外的异常、数据结构被破坏、不精确的计算等等问题</li>
</ul>
<h4 id="2-1-2-错误的64位值"><a href="#2-1-2-错误的64位值" class="headerlink" title="2.1.2 错误的64位值"></a>2.1.2 错误的64位值</h4><ul>
<li>Java内存模型要求，变量的读取和写入都是原子操作</li>
<li>但是对于非 volatile 类型的 long 和 double 等 64 位的变量，JVM 是允许将 64 位的读写操作分成两个 32 位的读写操作的，这样就可能会出现错误的 64 位值</li>
<li>比如，先读取了变量的前 32 位数据，结果这个时候被别的线程修改了变量值，然后读取后 32 位数据，但是此时可能读到的是修改后的值的后 32 位数据，这时就会出现一个异常的不存在的 64 位值</li>
</ul>
<h3 id="2-2-如何解决可见性问题"><a href="#2-2-如何解决可见性问题" class="headerlink" title="2.2 如何解决可见性问题"></a>2.2 如何解决可见性问题</h3><ul>
<li>为了确保多线程之间的读写操作可见性，必须使用同步机制</li>
</ul>
<h4 id="2-2-1-内置锁（监视器）"><a href="#2-2-1-内置锁（监视器）" class="headerlink" title="2.2.1 内置锁（监视器）"></a>2.2.1 内置锁（监视器）</h4><ul>
<li>内置锁（监视器）是一种同步机制，它可以保证多个线程之间的读写操作可见性</li>
<li>为了保证所有线程都能够看到共享变量的最新值，所有读写线程都必须在同一个锁上同步</li>
</ul>
<h4 id="2-2-volatile-变量"><a href="#2-2-volatile-变量" class="headerlink" title="2.2. volatile 变量"></a>2.2. volatile 变量</h4><ul>
<li>volatile 变量提供了一种稍弱的同步机制，也可以保证线程之间的可见性</li>
<li>读取 volatile 变量时，总是会返回最新写入的值</li>
<li>写入 volatile 变量时，总是会立即写入新值，但是不会等待其他线程的写入，即不会阻塞其他线程的写操作</li>
<li>volatile 是一种比内置锁更轻量级的同步机制，因为它不会阻塞其他线程</li>
</ul>
<h2 id="三、什么是线程封闭（避免共享）？"><a href="#三、什么是线程封闭（避免共享）？" class="headerlink" title="三、什么是线程封闭（避免共享）？"></a>三、什么是线程封闭（避免共享）？</h2><ul>
<li>解决内存可见性问题的最简单方法，就是不共享变量，那样就不会出现内存可见性问题</li>
<li>如果不共享数据，仅在单线程中访问数据，就不需要同步，这种技术称为线程封闭</li>
</ul>
<h3 id="3-1-Ad-hoc-线程封闭"><a href="#3-1-Ad-hoc-线程封闭" class="headerlink" title="3.1 Ad-hoc 线程封闭"></a>3.1 Ad-hoc 线程封闭</h3><ul>
<li>线程封闭实现，由程序自己实现和维护</li>
<li>比如使用 volatile 变量，可以看到其他线程修改的最新值，但是不能避免线程安全性</li>
<li>这种由程序自己维护的线程封闭实现，代价比较大，而且比较脆弱</li>
</ul>
<h3 id="3-2-栈封闭"><a href="#3-2-栈封闭" class="headerlink" title="3.2 栈封闭"></a>3.2 栈封闭</h3><ul>
<li>只使用局部变量去访问对象，称为栈封闭</li>
<li>每个线程都有自己的栈，局部变量都在栈上，所以局部变量是只属于当前线程的</li>
<li>Java语言确保基本类型的局部变量始终是封闭在线程内的</li>
<li>对于引用类型的基本变量，只有局部生成的对象才是线程封闭的</li>
<li>这种方式，只能确保在栈中的局部对象是安全的，如果局部变量引用的是全局对象，全局对象还是会存在线程安全问题</li>
</ul>
<h3 id="3-3-线程本地变量-ThreadLocal"><a href="#3-3-线程本地变量-ThreadLocal" class="headerlink" title="3.3 线程本地变量 ThreadLocal"></a>3.3 线程本地变量 ThreadLocal</h3><ul>
<li>ThreadLocal 可以确保每个线程都拥有属于自己的变量副本</li>
<li>ThreadLocal 变量的修改，只对当前线程生效，不会影响其他线程</li>
<li>这种方式可以确保对象是安全的，但是不应该滥用，毕竟 ThreadLocal 变量保存的对象虽然是安全的，但是它自己本身却相当于是一种全局变量，那就会存在线程安全问题</li>
</ul>
<h2 id="四、如何安全共享？"><a href="#四、如何安全共享？" class="headerlink" title="四、如何安全共享？"></a>四、如何安全共享？</h2><p>想要在多个线程之间共享对象，必须确保安全地进行共享。</p>
<p>否则，可能会出现各种并发问题，比如线程之间的可见性问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Share</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Share instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Share</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Share(<span class="number">11</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似这种方式共享的对象，是非常不安全的，很容易就出现线程安全问题。比如：</p>
<ul>
<li>instance 共享对象可能被多个线程创建多次，最终只保留了最后的一个对象</li>
<li>其他线程可能看不到最新的 instance 共享对象，看到的可能是 null，也可能是某个实例</li>
<li>其他线程看到的共享对象 instance 的状态 number 可能是失效的，即 number 不是 11，而可能是 0</li>
</ul>
<p>反正如果不进行安全发布，共享对象就可能存在各种并发问题。</p>
<h3 id="4-1-什么是发布和逸出？"><a href="#4-1-什么是发布和逸出？" class="headerlink" title="4.1 什么是发布和逸出？"></a>4.1 什么是发布和逸出？</h3><p>发布（Publish）：使得对象能够在当前作用域之外的代码使用。</p>
<p>比如：</p>
<ul>
<li>将对象引用保存到其他代码可以访问的地方，比如保存到静态变量上</li>
<li>从方法调用中返回对象引用，使得其他地方可以使用</li>
<li>将对象引用作为参数传递给其他方法</li>
</ul>
<p>简单来说，就是将一个局部生成的对象暴露给外面，使得外面的代码可以使用它，这就是发布，实际就是共享对象。</p>
<p>逸出（Escape）：某个不应该发布的对象被发布出去了。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] numbers = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getNumbers() &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发布地数组 numbers 实际上已经属于逸出了，因为它的原始引用被发布到了外部，调用者就可以直接修改数组的数据。</p>
<p>实际上，应该复制一份数组，再进行发布，避免直接修改原数组，从而避免逸出。</p>
<p>虽然调用者不一定会对逸出数据进行操作，但是误用该引用的风险始终是存在的。</p>
<h3 id="4-2-什么是安全地构造对象？"><a href="#4-2-什么是安全地构造对象？" class="headerlink" title="4.2 什么是安全地构造对象？"></a>4.2 什么是安全地构造对象？</h3><p>安全地构造对象是指：</p>
<ul>
<li>不要发布一个尚未构造完成的对象</li>
<li>不要在构造过程中使 this 引用逸出</li>
</ul>
<p>常见的不安全构造对象方式有：</p>
<ul>
<li>在构造函数中启动一个线程，对象未构造完成之前，线程就可以看见 this 引用</li>
<li>在构造函数中调用可重写的方法，就有可能在子类中被逸出</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnsafePublish</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.number = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在对象还未构造完成之前，线程有可能就执行了，而此时对象的状态 number 可能是不对的。</p>
<h3 id="4-3-共享对象类型有哪些？"><a href="#4-3-共享对象类型有哪些？" class="headerlink" title="4.3 共享对象类型有哪些？"></a>4.3 共享对象类型有哪些？</h3><h4 id="4-3-1-不可变对象"><a href="#4-3-1-不可变对象" class="headerlink" title="4.3.1 不可变对象"></a>4.3.1 不可变对象</h4><p>不可变对象（Immutable Object）：对象在其被创建之后就不能被修改。</p>
<p>需满足以下条件：</p>
<ul>
<li>对象创建后其状态就不能修改</li>
<li>对象的所有域都是 final 类型（技术上不一定，只要保障不被修改即可）</li>
<li>对象是正确安全构造好的（没有 this 逸出等）</li>
</ul>
<p>不可变对象的特性：</p>
<ul>
<li>不可变对象一定是线程安全的</li>
</ul>
<p>因为线程的不安全性就是来源于状态的变化，不可变对象的状态无法改变，就不存在线程安全问题。</p>
<h4 id="4-3-2-事实不可变对象"><a href="#4-3-2-事实不可变对象" class="headerlink" title="4.3.2 事实不可变对象"></a>4.3.2 事实不可变对象</h4><p>事实不可变对象（Effectively Immutable Object）：技术上对象是可变的，但是在程序中发布后就不会再改变。</p>
<p>需满足条件：</p>
<ul>
<li>对象一旦创建完成后，就不会再有人去修改它，即使它是可以修改的</li>
</ul>
<p>事实不可变对象的特性：</p>
<ul>
<li>安全发布的事实不可变对象是线程安全的</li>
</ul>
<p>注意，事实不可变对象需要“安全发布”，才可以保证线程安全。</p>
<h4 id="4-3-3-可变对象"><a href="#4-3-3-可变对象" class="headerlink" title="4.3.3 可变对象"></a>4.3.3 可变对象</h4><p>可变对象：就是普通的发布对象，可以被任意线程修改。</p>
<h3 id="4-4-如何安全发布？"><a href="#4-4-如何安全发布？" class="headerlink" title="4.4 如何安全发布？"></a>4.4 如何安全发布？</h3><h4 id="4-4-1-安全发布的要求"><a href="#4-4-1-安全发布的要求" class="headerlink" title="4.4.1 安全发布的要求"></a>4.4.1 安全发布的要求</h4><ul>
<li>要安全地发布对象，必须保证对象的引用和对象的状态是同时对其他线程可见的</li>
</ul>
<h4 id="4-4-2-安全发布的常用模式"><a href="#4-4-2-安全发布的常用模式" class="headerlink" title="4.4.2 安全发布的常用模式"></a>4.4.2 安全发布的常用模式</h4><ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到 volatile 类型的域或者原子类 AtomicReference 中</li>
<li>将对象的引用保存到某个正确构造对象的 final 类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
<p>简单举例（实际不一定是这样用的）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Share</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由锁保护的域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Share&gt; instances = <span class="keyword">new</span> ConcurrentMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instances.put(<span class="string">&quot;share&quot;</span>, <span class="keyword">new</span> Share(<span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态初始化函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Share instance1 = <span class="keyword">new</span> Share(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// volatile 类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Share instance2;</span><br><span class="line">    <span class="comment">// final 域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Share instance3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Share</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Share</span><span class="params">(Share share)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instance3 = share;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-4-3-安全共享对象"><a href="#4-4-3-安全共享对象" class="headerlink" title="4.4.3 安全共享对象"></a>4.4.3 安全共享对象</h4><ul>
<li>不可变对象，可以通过任意机制发布</li>
<li>事实不可变对象，必须通过安全方式发布</li>
<li>可变对象，必须通过安全方式发布，并且使用时必须是线程安全的（如由原子类或者某个锁保护起来）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>共享对象问题：</p>
<ul>
<li>多个线程同时访问或修改共享对象时，可能会出现冲突，即读写冲突</li>
<li>一个线程修改对象状态后，其他线程未必能够看到发生的变化，即内存可见性</li>
</ul>
<p>可见性问题：</p>
<ul>
<li>无法确保一个线程在修改状态时，其他线程能够适时看到状态变化</li>
<li>失效数据：一个线程修改了对象状态，其他线程可能获取到状态的最新值，也可能获取到旧的失效值</li>
<li>错误数据：对于非 volatile 类型的 long 和 double 等 64 位的变量，JVM 是允许将 64 位的读写操作分成两个 32 位的读写操作的，这样就可能会出现错误的 64 位值</li>
</ul>
<p>可见性解决方案：</p>
<ul>
<li>为了确保多线程之间的读写操作可见性，必须使用同步机制</li>
<li>内置锁（监视器）<ul>
<li>内置锁（监视器）是一种同步机制，它可以保证多个线程之间的读写操作可见性</li>
<li>为了保证所有线程都能够看到共享变量的最新值，所有读写线程都必须在同一个锁上同步</li>
</ul>
</li>
<li>volatile 变量<ul>
<li>volatile 变量提供了一种稍弱的同步机制，也可以保证线程之间的可见性</li>
<li>读取 volatile 变量时，总是会返回最新写入的值</li>
<li>写入 volatile 变量时，总是会立即写入新值，但是不会等待其他线程的写入，即不会阻塞其他线程的写操作</li>
<li>volatile 是一种比内置锁更轻量级的同步机制，因为它不会阻塞其他线程</li>
</ul>
</li>
</ul>
<p>线程封闭（不共享）：</p>
<ul>
<li>Ad-hoc 线程封闭<ul>
<li>线程封闭实现，由程序自己实现和维护</li>
<li>这种由程序自己维护的线程封闭实现，代价比较大，而且比较脆弱</li>
</ul>
</li>
<li>栈封闭<ul>
<li>每个线程都有自己的栈，局部变量都在栈上，所以局部变量是只属于当前线程的</li>
<li>Java语言确保基本类型的局部变量始终是封闭在线程内的</li>
<li>对于引用类型的基本变量，只有局部生成的对象才是线程封闭的</li>
</ul>
</li>
<li>线程本地变量 ThreadLocal<ul>
<li>ThreadLocal 可以确保每个线程都拥有属于自己的变量副本</li>
<li>ThreadLocal 变量的修改，只对当前线程生效，不会影响其他线程</li>
</ul>
</li>
</ul>
<p>发布和逸出：</p>
<ul>
<li>发布（Publish）：使得对象能够在当前作用域之外的代码使用</li>
<li>逸出（Escape）：某个不应该发布的对象被发布出去了</li>
</ul>
<p>安全构造对象：</p>
<ul>
<li>不要发布一个尚未构造完成的对象</li>
<li>不要在构造过程中使 this 引用逸出</li>
</ul>
<p>共享对象类型：</p>
<ul>
<li>不可变对象（Immutable Object）：对象在其被创建之后就不能被修改</li>
<li>事实不可变对象（Effectively Immutable Object）：技术上对象是可变的，但是在程序中发布后就不会再改变</li>
<li>可变对象：就是普通的发布对象，可以被任意线程修改</li>
</ul>
<p>安全发布模式：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到 volatile 类型的域或者原子类 AtomicReference 中</li>
<li>将对象的引用保存到某个正确构造对象的 final 类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
<p>安全共享对象：</p>
<ul>
<li>不可变对象，可以通过任意机制发布</li>
<li>事实不可变对象，必须通过安全方式发布</li>
<li>可变对象，必须通过安全方式发布，并且必须是线程安全的或者由某个锁保护起来的</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>02_线程安全性</title>
    <url>/lang/java/core/concurrency/02_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><h2 id="一、什么是线程安全？"><a href="#一、什么是线程安全？" class="headerlink" title="一、什么是线程安全？"></a>一、什么是线程安全？</h2><ul>
<li><p>当多个线程访问某个类时，这个类始终能表现出正确的行为，就称这个类是线程安全的</p>
</li>
<li><p>线程安全类，一般都封装了必要的同步机制，使用时无需额外进行同步</p>
</li>
</ul>
<span id="more"></span>

<h2 id="二、线程安全隐患从何而来？"><a href="#二、线程安全隐患从何而来？" class="headerlink" title="二、线程安全隐患从何而来？"></a>二、线程安全隐患从何而来？</h2><ul>
<li><p>线程安全性，来自多个线程同时访问共享和可变的状态</p>
</li>
<li><p>共享，意味着可以被多个线程访问</p>
</li>
<li><p>可变，意味着状态的值在其生命周期内可以发生变化</p>
</li>
<li><p>一个对象是否是线程安全的，取决于它是否被多个线程访问</p>
</li>
</ul>
<h2 id="三、如何实现线程安全？"><a href="#三、如何实现线程安全？" class="headerlink" title="三、如何实现线程安全？"></a>三、如何实现线程安全？</h2><h3 id="1、无状态对象，一定是线程安全的"><a href="#1、无状态对象，一定是线程安全的" class="headerlink" title="1、无状态对象，一定是线程安全的"></a>1、无状态对象，一定是线程安全的</h3><ul>
<li><p>线程安全性，就是因为存在共享和可变的状态。</p>
</li>
<li><p>如果一个对象没有任何状态（没有任何共享和可变的状态），就不存在线程安全问题。</p>
</li>
</ul>
<h3 id="2、单一状态，可以使用原子类来维护，从而避免线程安全问题"><a href="#2、单一状态，可以使用原子类来维护，从而避免线程安全问题" class="headerlink" title="2、单一状态，可以使用原子类来维护，从而避免线程安全问题"></a>2、单一状态，可以使用原子类来维护，从而避免线程安全问题</h3><ul>
<li><p>原子操作，是指对于访问同一个状态的所有操作而言，是一些列不可分割的操作。</p>
</li>
<li><p>比如，“读取-修改-写入”（例如递增运算），为了保证线程安全，要求这些操作是原子的。</p>
</li>
<li><p>使用原子类来维护状态的对象，一定是线程安全的。</p>
</li>
</ul>
<h3 id="3、状态的复合操作，需要加锁同步机制来保证线程安全"><a href="#3、状态的复合操作，需要加锁同步机制来保证线程安全" class="headerlink" title="3、状态的复合操作，需要加锁同步机制来保证线程安全"></a>3、状态的复合操作，需要加锁同步机制来保证线程安全</h3><ul>
<li><p>原子类本身是线程安全的，但是多个原子操作组合在一起，就未必是线程安全的。</p>
</li>
<li><p>使用加锁同步机制，可以保证访问共享状态的复合操作是线程安全的。</p>
</li>
<li><p>使用加锁同步机制，必须保证同一个状态从始至终都只由同一个锁来保护。</p>
</li>
<li><p>同步锁是可重入的，即在同一个线程中，可以多次获取同一个锁，但是最后也要保证释放这么多次锁。</p>
</li>
<li><p>同步锁是互斥的，最多只有一个线程持有这个锁。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/design_pattern/mediator/</url>
    <content><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><h2 id="一、什么是中介者模式？"><a href="#一、什么是中介者模式？" class="headerlink" title="一、什么是中介者模式？"></a>一、什么是中介者模式？</h2><p>中介者模式（Mediator Design Pattern）：定义一个单独的（中介）对象，来封装一系列对象的交互。将这组对象之间的交互都委派给中介对象，来避免对象之间的直接交互。</p>
<p>英文原文：</p>
<blockquote>
<p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p>
</blockquote>
<p>它有几个特点：</p>
<ul>
<li>一组对象之间存在相互交流的情况，也就是一种网状关系</li>
<li>定义一个上帝（中介）对象，负责中转对象之间的交互，来避免对象之间的直接联系</li>
<li>相当于加了个中间层转换，把网状关系变成了星型关系</li>
</ul>
<p>中介者模式，也称为调停模式，负责多个对象之间的互相沟通。</p>
<span id="more"></span>

<h2 id="二、为什么要用中介者模式？"><a href="#二、为什么要用中介者模式？" class="headerlink" title="二、为什么要用中介者模式？"></a>二、为什么要用中介者模式？</h2><p>中介者模式的应用场景比较少，一般用在下面的场景中：</p>
<ul>
<li>多个对象之间存在复杂的网状关系，难以扩展和维护时</li>
</ul>
<p>通过使用中介者模式，可以避免复杂的网状关系，降低对象之间的耦合度。</p>
<p>原来1个对象需要和n个对象交互，使用中介者模式后，1个对象只需要和中介者打交道就可以了。</p>
<h2 id="三、怎么用中介者模式？"><a href="#三、怎么用中介者模式？" class="headerlink" title="三、怎么用中介者模式？"></a>三、怎么用中介者模式？</h2><p>中介者模式中的角色：</p>
<ul>
<li>中介者（Mediator）：定义决策的接口</li>
<li>具体中介者（Concrete Mediator）：实现了中介者接口的具体角色</li>
<li>同事（Colleague）：定义了与中介者交互的接口</li>
<li>具体同事（Concrete Colleague）：实现了同事接口的具体角色</li>
</ul>
<p>中介者模式结构：</p>
<p><img src="/images/assets/designpattern/mediator.png" alt="中介者模式结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/mediator-demo.png" alt="示例程序结构"></p>
<p>中介者（Mediator）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createColleagues</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">colleagueChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同事（Colleague）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setColleagueEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体同事（Concrete Colleague）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColleagueCheckbox</span> <span class="keyword">extends</span> <span class="title">Checkbox</span> <span class="keyword">implements</span> <span class="title">ItemListener</span>, <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColleagueCheckbox</span><span class="params">(String caption, CheckboxGroup group, <span class="keyword">boolean</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(caption, group, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        setEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">itemStateChanged</span><span class="params">(ItemEvent e)</span> </span>&#123;</span><br><span class="line">        mediator.colleagueChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColleagueButton</span> <span class="keyword">extends</span> <span class="title">Button</span> <span class="keyword">implements</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColleagueButton</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(caption);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        setEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColleagueTextField</span> <span class="keyword">extends</span> <span class="title">TextField</span> <span class="keyword">implements</span> <span class="title">TextListener</span>, <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColleagueTextField</span><span class="params">(String text, <span class="keyword">int</span> columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(text, columns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        setEnabled(enabled);</span><br><span class="line">        setBackground(enabled ? Color.WHITE : Color.lightGray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">textValueChanged</span><span class="params">(TextEvent e)</span> </span>&#123;</span><br><span class="line">        mediator.colleagueChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体中介者（Concrete Mediator）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span>, <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ColleagueCheckbox checkGuest;</span><br><span class="line">    <span class="keyword">private</span> ColleagueCheckbox checkLogin;</span><br><span class="line">    <span class="keyword">private</span> ColleagueTextField textUser;</span><br><span class="line">    <span class="keyword">private</span> ColleagueTextField textPass;</span><br><span class="line">    <span class="keyword">private</span> ColleagueButton buttonOk;</span><br><span class="line">    <span class="keyword">private</span> ColleagueButton buttonCancel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginFrame</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line"></span><br><span class="line">        setBackground(Color.lightGray);</span><br><span class="line">        setLayout(<span class="keyword">new</span> GridLayout(<span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        createColleagues();</span><br><span class="line"></span><br><span class="line">        add(checkGuest);</span><br><span class="line">        add(checkLogin);</span><br><span class="line">        add(<span class="keyword">new</span> Label(<span class="string">&quot;Username&quot;</span>));</span><br><span class="line">        add(textUser);</span><br><span class="line">        add(<span class="keyword">new</span> Label(<span class="string">&quot;Password&quot;</span>));</span><br><span class="line">        add(textPass);</span><br><span class="line">        add(buttonOk);</span><br><span class="line">        add(buttonCancel);</span><br><span class="line"></span><br><span class="line">        colleagueChanged();</span><br><span class="line"></span><br><span class="line">        pack();</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createColleagues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化组件</span></span><br><span class="line">        CheckboxGroup g = <span class="keyword">new</span> CheckboxGroup();</span><br><span class="line">        checkGuest = <span class="keyword">new</span> ColleagueCheckbox(<span class="string">&quot;Guest&quot;</span>, g, <span class="keyword">true</span>);</span><br><span class="line">        checkLogin = <span class="keyword">new</span> ColleagueCheckbox(<span class="string">&quot;Login&quot;</span>, g, <span class="keyword">true</span>);</span><br><span class="line">        textUser = <span class="keyword">new</span> ColleagueTextField(<span class="string">&quot;&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        textPass = <span class="keyword">new</span> ColleagueTextField(<span class="string">&quot;&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        textPass.setEchoChar(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        buttonOk = <span class="keyword">new</span> ColleagueButton(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">        buttonCancel = <span class="keyword">new</span> ColleagueButton(<span class="string">&quot;Cancel&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定中介者</span></span><br><span class="line">        checkGuest.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        checkLogin.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        textUser.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        textPass.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        buttonOk.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        buttonCancel.setMediator(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定事件处理</span></span><br><span class="line">        checkGuest.addItemListener(checkGuest);</span><br><span class="line">        checkLogin.addItemListener(checkLogin);</span><br><span class="line">        textUser.addTextListener(textUser);</span><br><span class="line">        textPass.addTextListener(textPass);</span><br><span class="line">        buttonOk.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonCancel.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">colleagueChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkGuest.getState()) &#123;</span><br><span class="line">            <span class="comment">// 访客模式</span></span><br><span class="line">            textUser.setColleagueEnabled(<span class="keyword">false</span>);</span><br><span class="line">            textPass.setColleagueEnabled(<span class="keyword">false</span>);</span><br><span class="line">            buttonOk.setColleagueEnabled(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录模式</span></span><br><span class="line">            textUser.setColleagueEnabled(<span class="keyword">true</span>);</span><br><span class="line">            userPassChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">userPassChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (textUser.getText().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            textPass.setColleagueEnabled(<span class="keyword">true</span>);</span><br><span class="line">            buttonOk.setColleagueEnabled(textPass.getText().length() &gt; <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            textPass.setColleagueEnabled(<span class="keyword">false</span>);</span><br><span class="line">            buttonOk.setColleagueEnabled(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、中介者模式有什么优缺点？"><a href="#四、中介者模式有什么优缺点？" class="headerlink" title="四、中介者模式有什么优缺点？"></a>四、中介者模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>从网状关系，变成了星型关系，复杂度变低了</li>
<li>对象之间的交互变简单了，更容易扩展和维护</li>
</ul>
<p>缺点：</p>
<ul>
<li>中介者对象容易变得臃肿，难以维护</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/design_pattern/memento/</url>
    <content><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="一、什么是备忘录模式？"><a href="#一、什么是备忘录模式？" class="headerlink" title="一、什么是备忘录模式？"></a>一、什么是备忘录模式？</h2><p>备忘录模式（Memento Desidn Pattern）：在不违背封装性原则的前提下，捕获一个对象的内部状态，并在对象之外保存，以便之后恢复对象为先前的状态。</p>
<p>它的几个特点是：</p>
<ul>
<li>要求不要违背封装性原则</li>
<li>保存的是对象的内部状态，意味着对象外部不应该对保存的数据进行操作，而是假设不知道它的数据结构</li>
<li>保存的数据，相当于快照，可以用于撤销恢复</li>
</ul>
<p>备忘录模式，也称为快照模式。</p>
<span id="more"></span>

<h2 id="二、为什么要用备忘录模式？"><a href="#二、为什么要用备忘录模式？" class="headerlink" title="二、为什么要用备忘录模式？"></a>二、为什么要用备忘录模式？</h2><p>备忘录模式，使用的场景比较有限，主要就是用在防丢失、撤销、恢复上。</p>
<p>比如说，</p>
<ul>
<li>编辑软件一般都会提供撤回操作 <code>Ctrl + Z</code>，回退到修改之前的状态</li>
<li>数据库也提供了回滚操作，可以回滚到之前的状态</li>
<li>玩游戏时，游戏也可以存档，失败后可以从存档状态重新开始</li>
</ul>
<p>很多地方都可以用备忘录模式，但是场景大部分都是快照、撤销、恢复等。</p>
<h2 id="三、怎么用备忘录模式？"><a href="#三、怎么用备忘录模式？" class="headerlink" title="三、怎么用备忘录模式？"></a>三、怎么用备忘录模式？</h2><p>备忘录模式中的角色：</p>
<ul>
<li>生成者（Originator）：生成和恢复快照的角色</li>
<li>快照（Memento）：生成者生成的内部状态快照数据</li>
<li>负责人（Caretaker）：负责通知生成者进行快照的生成和恢复，快照也是在此管理</li>
</ul>
<p>备忘录模型结构：</p>
<p><img src="/images/assets/designpattern/memento.png" alt="备忘录模式结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/memento-demo.png" alt="备忘录模式结构"></p>
<p>生成者（Originator）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gamer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] fruitsName = &#123;</span><br><span class="line">            <span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;葡萄&quot;</span>, <span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;橘子&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; fruits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gamer</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String prefix = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (random.nextBoolean()) &#123;</span><br><span class="line">            prefix = <span class="string">&quot;好吃的&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix + fruitsName[random.nextInt(fruitsName.length)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dice = random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dice == <span class="number">1</span>) &#123;</span><br><span class="line">            money += <span class="number">100</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;所持金钱增加了。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dice == <span class="number">2</span>) &#123;</span><br><span class="line">            money /= <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;所持金钱减半了。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dice == <span class="number">6</span>) &#123;</span><br><span class="line">            String f = getFruit();</span><br><span class="line">            System.out.println(<span class="string">&quot;获得了水果（&quot;</span> + f + <span class="string">&quot;）。&quot;</span>);</span><br><span class="line">            fruits.add(f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;什么都没有发生。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Memento memento = <span class="keyword">new</span> Memento(money);</span><br><span class="line">        <span class="keyword">for</span> (String f : fruits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.startsWith(<span class="string">&quot;好吃的&quot;</span>)) &#123;</span><br><span class="line">                memento.addFruit(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = memento.getMoney();</span><br><span class="line">        <span class="keyword">this</span>.fruits = memento.getFruits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Gamer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&quot;, fruits=&quot;</span> + fruits +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快照（Memento）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; fruits;</span><br><span class="line"></span><br><span class="line">    Memento(<span class="keyword">int</span> money) &#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.fruits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFruit</span><span class="params">(String fruit)</span> </span>&#123;</span><br><span class="line">        fruits.add(fruit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function">ArrayList&lt;String&gt; <span class="title">getFruits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ArrayList&lt;String&gt;) fruits.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负责人（Caretaker）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Gamer gamer = <span class="keyword">new</span> Gamer(<span class="number">100</span>);</span><br><span class="line">    Memento memento = gamer.createMemento();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===== &quot;</span> + i + <span class="string">&quot; =====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span> + gamer);</span><br><span class="line"></span><br><span class="line">        gamer.bet();</span><br><span class="line">        System.out.println(<span class="string">&quot;所持金钱为 &quot;</span> + gamer.getMoney() + <span class="string">&quot; 元。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存状态</span></span><br><span class="line">        <span class="keyword">if</span> (gamer.getMoney() &gt; memento.getMoney()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所持金钱增加了，保存当前状态。&quot;</span>);</span><br><span class="line">            memento = gamer.createMemento();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gamer.getMoney() &lt; memento.getMoney() / <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所持金钱减半了，保存当前状态。&quot;</span>);</span><br><span class="line">            gamer.restoreMemento(memento);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、备忘录模式有什么优缺点？"><a href="#四、备忘录模式有什么优缺点？" class="headerlink" title="四、备忘录模式有什么优缺点？"></a>四、备忘录模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>实现了内部状态的封装，避免被外部破坏</li>
<li>提供了快速备份、撤销、恢复的操作</li>
<li>将快照单独管理，避免生成者报错过多数据，符合单一职责</li>
</ul>
<p>缺点：</p>
<ul>
<li>快照会占用较多内存资源</li>
</ul>
<h2 id="五、备忘录模式的优化？"><a href="#五、备忘录模式的优化？" class="headerlink" title="五、备忘录模式的优化？"></a>五、备忘录模式的优化？</h2><ul>
<li>全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复</li>
<li>比如，每天进行一次全量备份，没小时进行一次增量备份</li>
<li>恢复备份时，可以用前一天的全量备份 + 当天的增量备份</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/design_pattern/iterator/</url>
    <content><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="一、什么是迭代器模式？"><a href="#一、什么是迭代器模式？" class="headerlink" title="一、什么是迭代器模式？"></a>一、什么是迭代器模式？</h2><p>迭代器模式（Iterator Design Pattern）：提供一种方式来访问聚合里面的所有元素，而不暴露聚合对象的内部数据结构。</p>
<p>迭代器模式，也称为游标模式，主要用于遍历数据集合。</p>
<p>迭代器模式的几个特点：</p>
<ul>
<li>目的是为了遍历集合数据</li>
<li>特点是可以避免集合的内部数据结构暴露，增加集合内部实现的灵活性</li>
</ul>
<p>迭代器是为了遍历集合数据，所以一个完整的迭代器，肯定是包括集合和迭代器2部分。</p>
<span id="more"></span>

<p>迭代器模式，关注重点在于遍历数据，而不是按照什么顺序遍历。</p>
<p>比如说，集合里是按照字母顺序保存的，但使用迭代器遍历时，遍历顺序并不一定是按字母排序。</p>
<p>所以，迭代器并不一定按照结构遍历，而是主要为了遍历数据。</p>
<h2 id="二、为什么要用迭代器模式？"><a href="#二、为什么要用迭代器模式？" class="headerlink" title="二、为什么要用迭代器模式？"></a>二、为什么要用迭代器模式？</h2><h3 id="2-1-想要遍历集合的所有数据"><a href="#2-1-想要遍历集合的所有数据" class="headerlink" title="2.1 想要遍历集合的所有数据"></a>2.1 想要遍历集合的所有数据</h3><p>迭代器的目的就是为了遍历数据，所以是为了遍历集合，可使用迭代模式。</p>
<h3 id="2-2-不想暴露集合内部数据结构"><a href="#2-2-不想暴露集合内部数据结构" class="headerlink" title="2.2 不想暴露集合内部数据结构"></a>2.2 不想暴露集合内部数据结构</h3><p>有些时候，会出现</p>
<ul>
<li>不想被人知道集合内部的数据结构</li>
<li>或者可能会修改内部数据结构实现</li>
</ul>
<p>的情况，这时就需要隐藏内部的数据结构实现。</p>
<p>但是又需要遍历数据，这个时候就可以提供一个迭代器接口给外面调用。</p>
<h3 id="2-3-想要统一集合的遍历结构"><a href="#2-3-想要统一集合的遍历结构" class="headerlink" title="2.3 想要统一集合的遍历结构"></a>2.3 想要统一集合的遍历结构</h3><p>假如有很多种集合类型，比如 List、Set、Map、Tree、Graph 等。</p>
<p>每种数据结构是不同的，在实际遍历时需要写的代码也不一样。</p>
<p>比如，遍历树的方式就有前序遍历、中序遍历、后序遍历等，代码都不同。</p>
<p>想要按照统一的方式遍历这些集合，就可以用迭代器来实现。</p>
<h3 id="2-4-想要特殊的遍历方式"><a href="#2-4-想要特殊的遍历方式" class="headerlink" title="2.4 想要特殊的遍历方式"></a>2.4 想要特殊的遍历方式</h3><p>有时候，想要按照某种顺序去遍历集合中的数据，可以自定义迭代器是完成。</p>
<p>比如按照字母顺序遍历，按照添加顺序遍历，按照添加顺序逆序遍历等等。</p>
<p>这个时候，可以为不同的遍历方式提供不同的迭代器实现。</p>
<h2 id="三、怎么用迭代器模式？"><a href="#三、怎么用迭代器模式？" class="headerlink" title="三、怎么用迭代器模式？"></a>三、怎么用迭代器模式？</h2><p>迭代器模式中的角色包括：</p>
<ul>
<li>迭代器（Iterator）：定义了遍历集合数据的接口</li>
<li>具体迭代器（ConcreteIterator）：实现了迭代器接口的具体迭代器，和具体的集合数据结构绑定</li>
<li>集合（Aggregate）：集合接口，定了了创建迭代器的接口</li>
<li>具体集合（ConcreteAggregate）：实现了集合接口的具体集合，提供属于自己的迭代器实现</li>
</ul>
<p>迭代器模型结构：</p>
<p><img src="/images/assets/designpattern/iterator.png" alt="迭代器模型结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/iterator-demo.png" alt="迭代器模型结构"></p>
<p>迭代器（Iterator）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集合（Aggregate）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体集合（ConcreteAggregate）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span> <span class="keyword">implements</span> <span class="title">Aggregate</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Book[] books;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookShelf</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books = <span class="keyword">new</span> Book[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBookAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> books[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        sortInsert(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortInsert</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = last;</span><br><span class="line">        <span class="keyword">for</span> (; index &gt; <span class="number">0</span>; index--) &#123;</span><br><span class="line">            Book b = books[index - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (book.getName().compareTo(b.getName()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            books[index] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        books[index] = book;</span><br><span class="line">        last++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Book&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookShelfIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体迭代器（ConcreteIterator）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelfIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BookShelf bookShelf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookShelfIterator</span><span class="params">(BookShelf bookShelf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookShelf = bookShelf;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; bookShelf.getLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookShelf.getBookAt(index++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四、迭代器模式有什么优缺点？"><a href="#四、迭代器模式有什么优缺点？" class="headerlink" title="四、迭代器模式有什么优缺点？"></a>四、迭代器模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>统一集合的遍历方式，特别是对于复杂结构来说更友好</li>
<li>集合与迭代分离，耦合性低，很方便扩展迭代器</li>
<li>隐藏集合的数据结构，提高集合内部实现的灵活性</li>
</ul>
<p>缺点：</p>
<ul>
<li>客户端只能调用已有的迭代器，集合实现者需提供足够的迭代器实现</li>
<li>迭代器增加了类的数量，在一定程度上增加了程序的复杂性</li>
</ul>
<h2 id="五、实际场景"><a href="#五、实际场景" class="headerlink" title="五、实际场景"></a>五、实际场景</h2><ul>
<li>JDK 中的集合类，基本都实现了 Iterator 迭代器</li>
<li>ArrayList 中提供了正序和逆序2种迭代器</li>
<li>LinkedHashMap 提供了按照添加顺序遍历的迭代器接口</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>职责链模式</title>
    <url>/design_pattern/chain/</url>
    <content><![CDATA[<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><h2 id="一、职责链模式是什么？"><a href="#一、职责链模式是什么？" class="headerlink" title="一、职责链模式是什么？"></a>一、职责链模式是什么？</h2><p>职责链模式（Chain of Responsibility Design Pattern）：将请求的发送和接收解耦，让多个接收者都有机会处理这个请求。将接收者串联起来，并沿着接收者链传递请求，直到某个接收者能够处理它为止。</p>
<p>英语原文：</p>
<blockquote>
<p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>
</blockquote>
<p>职责链的几个特点：</p>
<ul>
<li>存在多个接收者可以处理请求</li>
<li>请求只需被某个接收者处理即可</li>
<li>请求也可以被多个接收者处理</li>
</ul>
<p>职责链的目的在于，找到一个可以处理请求的接收者就好了。</p>
<span id="more"></span>

<h2 id="二、为什么要用职责链模式？"><a href="#二、为什么要用职责链模式？" class="headerlink" title="二、为什么要用职责链模式？"></a>二、为什么要用职责链模式？</h2><h3 id="2-1-想要运行时确定请求接收者"><a href="#2-1-想要运行时确定请求接收者" class="headerlink" title="2.1 想要运行时确定请求接收者"></a>2.1 想要运行时确定请求接收者</h3><p>如果谁负责处理某个请求是不确定的，而是想要在运行时确定，可以尝试用职责链。</p>
<h3 id="2-2-想要动态增删处理者"><a href="#2-2-想要动态增删处理者" class="headerlink" title="2.2 想要动态增删处理者"></a>2.2 想要动态增删处理者</h3><p>想要在运行时动态添加和删除，或者自定义接收处理，可以用职责链模式。</p>
<h3 id="2-3-想要按优先级处理请求"><a href="#2-3-想要按优先级处理请求" class="headerlink" title="2.3 想要按优先级处理请求"></a>2.3 想要按优先级处理请求</h3><p>如果想要根据请求类型，按照某种优先级处理，可以使用职责链模式。</p>
<p>可以按优先级处理，是职责链一个重要的特性。</p>
<h2 id="三、职责链模式怎么用？"><a href="#三、职责链模式怎么用？" class="headerlink" title="三、职责链模式怎么用？"></a>三、职责链模式怎么用？</h2><p>职责链模式可以分为2种情况：</p>
<ul>
<li>只要有一个接收者处理请求，职责链就停止了</li>
<li>所有接收者都可以处理请求，直到职责链结束</li>
</ul>
<p>具体使用哪种形式，看实际的需求。</p>
<p>职责链模式中出现的角色：</p>
<ul>
<li>处理者（Handler）：定义职责链中处理器的接口</li>
<li>具体处理者（ConcreteHandler）：实现了处理者接口的具体实现，是实际处理请求的接收者</li>
<li>请求者（Client）：发送请求的角色</li>
</ul>
<p>职责链结构：</p>
<p><img src="/images/assets/designpattern/chain.png" alt="职责链结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/chain-demo.png" alt="职责链结构"></p>
<p>处理者接口（Handler）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Support next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Support</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Support <span class="title">setNext</span><span class="params">(Support next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决问题的步骤</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">support</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resolve(trouble)) &#123;</span><br><span class="line">            done(trouble);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.support(trouble);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fail(trouble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决问题的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble  trouble)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">        System.out.println(trouble + <span class="string">&quot; is resolved by &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">        System.out.println(trouble + <span class="string">&quot; can not be resolved.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体处理者（ConcreteHandler）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoSupport</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OddSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OddSupport</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (trouble.getNumber() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitSupport</span><span class="params">(String name, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (trouble.getNumber() &lt; limit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpecialSupport</span><span class="params">(String name, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (trouble.getNumber() == number) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四、职责链模式有什么优缺点？"><a href="#四、职责链模式有什么优缺点？" class="headerlink" title="四、职责链模式有什么优缺点？"></a>四、职责链模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>请求和接收解耦，可扩展性好</li>
<li>接收者可以动态调整，灵活性好</li>
<li>每个接收者的职责唯一，符合单一职责原则</li>
</ul>
<p>缺点：</p>
<ul>
<li>职责链可能存在有序性，接收者不能随意调整，否则容易出问题</li>
<li>职责链需要注意循环链接的问题</li>
<li>职责链可能比较长，影响效率</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/design_pattern/strategy/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="一、什么是策略模式？"><a href="#一、什么是策略模式？" class="headerlink" title="一、什么是策略模式？"></a>一、什么是策略模式？</h2><p>策略模式（Strategy Design Pattern）：定义一系列算法，并将算法封装起来，使得它们可以相互替换。策略模式可以使得算法独立于客户端（即使用算法的地方）。</p>
<p>英语原文: </p>
<blockquote>
<p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>
</blockquote>
<p>策略模式有几个特点：</p>
<ul>
<li>存在多种算法</li>
<li>算法之间可以相互替换，说明它们返回结果的影响是一样的，只是算法内部实现不同</li>
<li>策略独立于客户端，单独实现</li>
</ul>
<p>比如说，排序功能，排序的结果可能都是一样的，但是可以使用不同的算法，如选择排序、冒泡排序、快速排序等。</p>
<span id="more"></span>


<h2 id="二、为什么要用策略模式？"><a href="#二、为什么要用策略模式？" class="headerlink" title="二、为什么要用策略模式？"></a>二、为什么要用策略模式？</h2><h3 id="2-1-好处在于：策略与客户端解耦"><a href="#2-1-好处在于：策略与客户端解耦" class="headerlink" title="2.1 好处在于：策略与客户端解耦"></a>2.1 好处在于：策略与客户端解耦</h3><p>策略独立封装，在客户端那边是感知不到细节的，很方便扩展新的实现。</p>
<h3 id="2-2-典型应用场景：在运行时动态选择策略"><a href="#2-2-典型应用场景：在运行时动态选择策略" class="headerlink" title="2.2 典型应用场景：在运行时动态选择策略"></a>2.2 典型应用场景：在运行时动态选择策略</h3><p>比如说，程序中设置一个类型变量，指定某种策略，然后在运行时改变类型值，就能动态改变策略。</p>
<p>例如，排序策略，数据很少时，直接用冒泡排序，数据很多时，可以用归并排序。</p>
<h3 id="2-3-利用策略模式来移除if-else语句"><a href="#2-3-利用策略模式来移除if-else语句" class="headerlink" title="2.3 利用策略模式来移除if-else语句"></a>2.3 利用策略模式来移除if-else语句</h3><p>策略独立封装后，就可以采用查表法去获取指定的策略，无需使用if-else语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Strategy strategy = StrategyFactory.get(strategyType);</span><br></pre></td></tr></table></figure>

<p>当然，实际上if-else语句并没有移除，只是从客户端转移到了策略获取的地方。</p>
<p>但是这样做就减少了客户端的工作量，避免了很多出错的情况。</p>
<h2 id="三、怎么用策略模式？"><a href="#三、怎么用策略模式？" class="headerlink" title="三、怎么用策略模式？"></a>三、怎么用策略模式？</h2><p>使用策略模式，重点在于策略之间的可替换性。</p>
<p>策略模式中的角色包括：</p>
<ul>
<li>策略（Strategy）：定义了策略所必须的接口。</li>
<li>具体策略（ConcreteStrategy）：实现了策略接口的具体策略（战略、方法和算法）</li>
<li>上下文（Context）：使用策略的地方，即调用Strategy接口的地方</li>
</ul>
<p>策略模式的结构：</p>
<p><img src="/images/assets/designpattern/strategy.png" alt="策略模式结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/strategy-demo.png" alt="策略模式结构"></p>
<p>策略（Strategy）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function">Hand <span class="title">nextHand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">boolean</span> win)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体策略（ConcreteStrategy）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WinningStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> won = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Hand preHand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WinningStrategy</span><span class="params">(<span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">        random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hand <span class="title">nextHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!won) &#123;</span><br><span class="line">            preHand = Hand.getHand(random.nextInt(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">boolean</span> win)</span> </span>&#123;</span><br><span class="line">        won = win;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProbStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> preHandValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentHandValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] history = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProbStrategy</span><span class="params">(<span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">        random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hand <span class="title">nextHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bet = random.nextInt(getSum(currentHandValue));</span><br><span class="line">        <span class="keyword">int</span> handValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (bet &lt; history[currentHandValue][<span class="number">0</span>]) &#123;</span><br><span class="line">            handValue = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bet &lt; history[currentHandValue][<span class="number">0</span>] + history[currentHandValue][<span class="number">1</span>]) &#123;</span><br><span class="line">            handValue = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handValue = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preHandValue = currentHandValue;</span><br><span class="line">        currentHandValue = handValue;</span><br><span class="line">        <span class="keyword">return</span> Hand.getHand(handValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">boolean</span> win)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (win) &#123;</span><br><span class="line">            history[preHandValue][currentHandValue]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            history[preHandValue][(currentHandValue + <span class="number">1</span>) % <span class="number">3</span>]++;</span><br><span class="line">            history[preHandValue][(currentHandValue + <span class="number">2</span>) % <span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> hv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            sum += history[hv][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上下文（Context）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> winCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loseCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gameCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name, Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hand <span class="title">nextHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.nextHand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">win</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.study(<span class="keyword">true</span>);</span><br><span class="line">        winCount++;</span><br><span class="line">        gameCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.study(<span class="keyword">false</span>);</span><br><span class="line">        loseCount++;</span><br><span class="line">        gameCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gameCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、策略模式有什么优缺点？"><a href="#四、策略模式有什么优缺点？" class="headerlink" title="四、策略模式有什么优缺点？"></a>四、策略模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>策略与客户端解耦，可扩展性好</li>
<li>策略独立扩展，符合单一职责原则</li>
<li>策略之间可相互替代，符合里斯替换原则</li>
<li>在一定程度上，策略模式可以减少客户端的if-else语句，避免代码错误</li>
</ul>
<p>缺点：</p>
<ul>
<li>策略类可能会很多，后期会比较难维护</li>
<li>客户端需要了解各种策略的区别（但不需要了解实现细节），才能选择合适的策略</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/design_pattern/bridge/</url>
    <content><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="一、什么是桥接模式？"><a href="#一、什么是桥接模式？" class="headerlink" title="一、什么是桥接模式？"></a>一、什么是桥接模式？</h2><p>桥接模式（Bridge Design Pattern）:将抽象与实现解耦，让他们能够独立变化。</p>
<p>或者，桥接模式就是将类的功能层次结构和类的实现层次结构分离开来，降低它们的耦合度。</p>
<p>抽象，即类的功能层次结构，采用的是继承的方式。</p>
<p>实现，即类的实现层次结构，采用的是组合的方式。</p>
<span id="more"></span>

<h3 id="1-1-多用组合少用继承"><a href="#1-1-多用组合少用继承" class="headerlink" title="1.1 多用组合少用继承"></a>1.1 多用组合少用继承</h3><p>桥接模式，还有通俗一些的解释：一个类存在多个独立变化的维度时，可以通过组合方式让这些维度独立扩展。</p>
<p>比如说，汽车 Car 是一种抽象类型。</p>
<p>它的品牌类型，可以是奔驰、宝马、奥迪等；</p>
<p>而每辆车，它可能有好几个挡位，比如自动档、手动挡、手自一体等。</p>
<p>假设有m种品牌，n种挡位，那么它既可以形成成 m * n 种组合。</p>
<p>如果只采用继承来实现这些组合的话，那就需要有 m * n 个类，如果还有其他维度，那么组合数量会更多。</p>
<p>但是通过桥接模式，将品牌和挡位分离，采用组合的方式的话，就只需要 m + n 个类，大大减少了类的数量。</p>
<p>桥接模式，实际上就是利用组合来避免继承爆炸。</p>
<h3 id="1-2-基于接口编程"><a href="#1-2-基于接口编程" class="headerlink" title="1.2 基于接口编程"></a>1.2 基于接口编程</h3><p>如果从结构上来说的话，继承就相当于是一棵树，组合就相当于在树与树之间的连接，它们构成了森林。</p>
<p>每棵树，都是一个维度，都有自己的抽象功能层次结构；</p>
<p>而每个维度之间，又存在着联系，这种联系就是一种实现层次。</p>
<p>树与树之间的联系，一般都是通过顶层的接口抽象来关联的，互相之间是基于接口连接。</p>
<p>桥接模式，实际上是通过接口来进行交互。</p>
<h2 id="二、为什么要用桥接模式？"><a href="#二、为什么要用桥接模式？" class="headerlink" title="二、为什么要用桥接模式？"></a>二、为什么要用桥接模式？</h2><p>桥接模式的主要作用有几个：</p>
<ul>
<li>将类的功能层次和实现层次分离，降低耦合度</li>
<li>使用组合替代继承，避免组合爆炸的问题</li>
<li>把各个维度独立出来，方便进行扩展</li>
</ul>
<p>使用桥接模式，最主要的就是避免类继承层次过深，而采用组合的方式来避免这种情况。</p>
<p>比如说，有m个维度，每个维度有n种变化，每种变化又包含k种情况，采用继承来做，就需要 m * n * k 个类。</p>
<p>如果将各个维度独立开来，采用组合的方式，就只需要 m + n + k 个类。</p>
<p>而且各个维度可以单独变化扩展，可维护性也会增强。</p>
<p>桥接模式适用于类层次和类关联比较复杂的情况，如果类层次结构很简单，使用桥接模式反而过于复杂。</p>
<h2 id="三、怎么用桥接模式？"><a href="#三、怎么用桥接模式？" class="headerlink" title="三、怎么用桥接模式？"></a>三、怎么用桥接模式？</h2><p>桥接模式中的几个角色：</p>
<ul>
<li>抽象化（Abstraction）：类功能层次的抽象类，里面包含了一个实现者的引用</li>
<li>扩展后的抽象化（Refined Abstraction）：在抽象化的基础上扩展了新功能</li>
<li>实现者（Implementor）：类实现层次的抽象类，被抽象化角色包含在内</li>
<li>具体实现者（ConcreteImplememtor）：是实现者的具体实现</li>
</ul>
<p>桥接模式结构：</p>
<p><img src="/images/assets/designpattern/bridge.png" alt="桥接模式结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/bridge-demo.png" alt="桥接模式结构"></p>
<p>抽象化（Abstraction）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DisplayImpl impl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Display</span><span class="params">(DisplayImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl.rawOpen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl.rawPrint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl.rawClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        open();</span><br><span class="line">        print();</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展后的抽象化（Refined Abstraction）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDisplay</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDisplay</span><span class="params">(DisplayImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiDisplay</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">        open();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现者（Implementor）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现者（ConcreteImplememtor）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplayImpl</span> <span class="keyword">extends</span> <span class="title">DisplayImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringDisplayImpl</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">        <span class="keyword">this</span>.width = string.getBytes().length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;|&quot;</span> + string + <span class="string">&quot;|&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、桥接模式有什么优缺点？"><a href="#四、桥接模式有什么优缺点？" class="headerlink" title="四、桥接模式有什么优缺点？"></a>四、桥接模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>将类的功能层次和实现层次分离，降低耦合度</li>
<li>使用组合替代继承，避免组合爆炸的问题</li>
<li>把各个维度独立出来，方便进行扩展</li>
</ul>
<p>缺点：</p>
<ul>
<li>结构变得复杂了，可读性变差了</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/design_pattern/proxy/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="一、什么代理模式？"><a href="#一、什么代理模式？" class="headerlink" title="一、什么代理模式？"></a>一、什么代理模式？</h2><p>代理模式（Proxy Design Pattern）：在不改变原始类（被代理类）的情况下，对它进行功能的增强。</p>
<p>代理模式有几个特点：</p>
<ul>
<li>不会改变原始类（被代理类）</li>
<li>核心功能还是由原始类（被代理类）实现</li>
<li>代理类只负责增强的那部分功能</li>
</ul>
<p>代理，就是帮别人做事情，核心工作还是由被代理人做，但是其他琐碎的事则可以交给代理人。</p>
<span id="more"></span>

<p>比如租房时，我们可以找中介帮忙找房子、等一系列事，减少自己的工作量。</p>
<p>这里的中介就是一个代理，我们自己就是被代理人。</p>
<h2 id="二、为什么要用代理模式？"><a href="#二、为什么要用代理模式？" class="headerlink" title="二、为什么要用代理模式？"></a>二、为什么要用代理模式？</h2><p>使用代理模式主要有几个目的：</p>
<ul>
<li>保护目标对象</li>
<li>增强目标对象</li>
<li>隔离功能</li>
</ul>
<p>保护对象，就是利用代理对象，隔离原始对象的数据，以达到保护对象的目的。</p>
<p>比如说，通过代理类去验证权限，有权限时才可以访问原始对象的数据。</p>
<p>增强对象，就是原始对象功能比较简单，可以通过代理类为其增加额外功能。</p>
<p>比如说，通过代理类去增加缓存，来提高接口的访问速度。</p>
<p>隔离功能，比如隔离业务功能和非业务功能，把非业务功能的代码放在代理类实现。</p>
<p>比如，接口监控、统计、鉴权、限流、事务、幂等、日志等。</p>
<h2 id="三、代理模式怎么用？"><a href="#三、代理模式怎么用？" class="headerlink" title="三、代理模式怎么用？"></a>三、代理模式怎么用？</h2><h3 id="3-1-静态代理"><a href="#3-1-静态代理" class="headerlink" title="3.1 静态代理"></a>3.1 静态代理</h3><p>静态代理，就是每个被代理对象，都需要编写一个代理类。</p>
<p>这就是说，编写原始类时，必须同时编写一个代理类，否则就没有办法实现代理模式了。</p>
<p>比如说，有100个原始类：<code>Base1</code>、<code>Base2</code> …… <code>Base100</code>。</p>
<p>那么，静态代理实现，就需要同时编写 100 个代理类：<code>Proxy1</code>、<code>Proxy2</code> …… <code>Proxy100</code>。</p>
<p>（真要这么写，手都得废了~~~~~）</p>
<h3 id="3-2-动态代理"><a href="#3-2-动态代理" class="headerlink" title="3.2 动态代理"></a>3.2 动态代理</h3><p>动态代理，就是解决静态代理的问题，改成由程序动态生成代理类，无需自己编写代理类。</p>
<p>比如说，静态代理需要编写100个代理类：<code>Proxy1</code>、<code>Proxy2</code> …… <code>Proxy100</code>。</p>
<p>如果是动态代理，只需1个代理生成类即可：<code>ProxyCreator</code>，用来生成不同的代理类。</p>
<p>动态代理，实际就是搞了一个工厂类，专门用于生成代理类，减少手动编写的工作量。</p>
<p>动态代理，虽然不需要自己写代理类，但是一般都需要编写生成动态代理类的代码。</p>
<p>不过像生成动态代理类这种代码，实际上有很多框架都实现了，比如Spring、CgLib等，直接用即可。</p>
<h3 id="3-3-模型结构"><a href="#3-3-模型结构" class="headerlink" title="3.3 模型结构"></a>3.3 模型结构</h3><p>代理模型中的角色包括：</p>
<ul>
<li>抽象主题（SUbject）：被代理的目标类接口，或者抽象类</li>
<li>真实主题（RealSubject）：被代理目标的实现类</li>
<li>代理角色：代理的实现类，实现了抽象主题接口，内部蕴含真实主题的引用</li>
</ul>
<p>模型结构：</p>
<p><img src="/images/assets/designpattern/proxy.png" alt="代理模型结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/proxy-demo.png" alt="代理模型结构"></p>
<p>抽象主题（Subject）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getPrinterName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印输出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 输出字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实主题（RealSubject）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        heavyJob(<span class="string">&quot;Printer 的实例生成中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        heavyJob(<span class="string">&quot;Printer 的实例生成中（&quot;</span> + name + <span class="string">&quot;）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heavyJob</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理角色（Proxy）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPrinter</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Printer real;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyPrinter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyPrinter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (real != <span class="keyword">null</span>) &#123;</span><br><span class="line">            real.setPrinterName(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        realize();</span><br><span class="line">        real.print(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">realize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (real == <span class="keyword">null</span>) &#123;</span><br><span class="line">            real = <span class="keyword">new</span> Printer(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四、代理模式有什么优缺点？"><a href="#四、代理模式有什么优缺点？" class="headerlink" title="四、代理模式有什么优缺点？"></a>四、代理模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>代理对象对原始对象起到了保护作用</li>
<li>代理对象可以对原始对象进行扩展</li>
</ul>
<p>缺点：</p>
<ul>
<li>每个原始对象都需要有自己的代理类</li>
<li>代理类相当于多了一层中介，而且还增加了功能，接口的访问速度变慢了</li>
<li>系统的复杂度增加了，代码调试变得更麻烦</li>
</ul>
<h2 id="五、代理模式的形式"><a href="#五、代理模式的形式" class="headerlink" title="五、代理模式的形式"></a>五、代理模式的形式</h2><ul>
<li>远程代理：隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，JAVA 中的 RMI（RemoteMethodInvocation：远程方法调用），调用远程方法接口，就像是在本地调用一样。</li>
<li>虚拟代理：当创建的目标对象开销很大时，只有当真正需要实例时，才会生成和初始化实例。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li>安全代理：控制不同种类客户对真实对象的访问权限，比如不同客户允许调用的接口不一样。</li>
<li>智能指引：附加一些额外的处理功能。例如，计算接口的访问次数，可以在代理类中处理。</li>
<li>延迟加载：指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li>
</ul>
<h2 id="六、和其他模式的对比"><a href="#六、和其他模式的对比" class="headerlink" title="六、和其他模式的对比"></a>六、和其他模式的对比</h2><h3 id="6-1-代理-vs-装饰器"><a href="#6-1-代理-vs-装饰器" class="headerlink" title="6.1 代理 vs. 装饰器"></a>6.1 代理 vs. 装饰器</h3><p>装饰器模式和代理模式的模式结构上很类似，但是它们的使用目的不同：</p>
<ul>
<li>装饰器模式：偏向于给原始对象增加新的业务功能</li>
<li>代理模式：偏向于给原始对象减轻负担，或者说增加非业务功能</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/design_pattern/visitor/</url>
    <content><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="一、什么是访问者模式？"><a href="#一、什么是访问者模式？" class="headerlink" title="一、什么是访问者模式？"></a>一、什么是访问者模式？</h2><p>访问者模式（Visitor Design Patten）：将作用于数据结构中的操作分离出来，形成单独的操作类，这样就可以在不改变数据结构的情况下，扩展出新的操作。</p>
<p>它将数据结构与数据处理分离开来，保持数据结构不变，而允许扩展新的处理。</p>
<span id="more"></span>

<h2 id="二、访问者模式的应用场景是什么？"><a href="#二、访问者模式的应用场景是什么？" class="headerlink" title="二、访问者模式的应用场景是什么？"></a>二、访问者模式的应用场景是什么？</h2><ul>
<li>被处理的数据结构相对稳定</li>
<li>被处理的数据结构要求保持不变，尽量避免数据处理影响到数据结构</li>
<li>数据处理类型比较多，相对复杂，并且数据处理数量是可变化的，可扩展的</li>
</ul>
<p>就比如说文件，文件类型虽然多，但是常用的也就那几种文件，如PPT、Word、Pdf等。</p>
<p>总的来说，文件数据类型相对来说比较稳定，不容易变动。</p>
<p>但是对文件的操作就比较频繁了，比如对文件内容搜索、分页、调整样式等，有各种各样的操作，是变化的。</p>
<p>这种情况下，使用访问者模式将文件和操作分离，很容易就能添加新的操作行为。</p>
<h2 id="三、访问者模式的结构是怎么样的？"><a href="#三、访问者模式的结构是怎么样的？" class="headerlink" title="三、访问者模式的结构是怎么样的？"></a>三、访问者模式的结构是怎么样的？</h2><p>访问者模式中的登场角色：</p>
<ul>
<li>访问者（Visitor）：负责对数据结构中的每个具体元素（ConcreteElement）声明访问接口，表示访问该元素</li>
<li>具体的访问者（ConcreteVisitor）：负责实现Visitor接口</li>
<li>元素（Element）：表示被Visitor访问的对象，声明了接受Visitor访问的接口</li>
<li>具体元素（ConcreteElement）：负责实现Element接口</li>
<li>对象结构（ObjectStructure）：负责处理Element角色的集合</li>
</ul>
<p><img src="/images/assets/designpattern/visitor.png" alt="访问者模式结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/visitor-demo.png" alt="访问者模式结构"></p>
<p>Viitor 和 Element：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">addEntry</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileTreatmentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileTreatmentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getName() + <span class="string">&quot; (&quot;</span> + getSize() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Entry&gt; dir = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">addEntry</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        dir.add(entry);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dir.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        Iterator&lt;Entry&gt; it = dir.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Entry entry = it.next();</span><br><span class="line">            size += entry.getSize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ListVisitor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String currentDir = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        System.out.println(currentDir + <span class="string">&quot;/&quot;</span> + file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span> </span>&#123;</span><br><span class="line">        System.out.println(currentDir + <span class="string">&quot;/&quot;</span> + directory);</span><br><span class="line">        String saveDir = currentDir;</span><br><span class="line">        currentDir = currentDir + <span class="string">&quot;/&quot;</span> + directory.getName();</span><br><span class="line">        Iterator it = directory.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Entry entry = (Entry) it.next();</span><br><span class="line">            entry.accept(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        currentDir = saveDir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="四、访问者模式有什么优缺点？"><a href="#四、访问者模式有什么优缺点？" class="headerlink" title="四、访问者模式有什么优缺点？"></a>四、访问者模式有什么优缺点？</h2><p>优点</p>
<ul>
<li>可扩展性好。将数据与处理分离，方便增加新的处理</li>
<li>符合单一职责原则。每种操作都被封装成同一类的访问者，功能都比较单一</li>
</ul>
<p>缺点：</p>
<ul>
<li>可读性略差：访问者模式的代码结构是略微有点绕的，可读性和可理解性有点差</li>
<li>破坏依赖倒置原则。访问者依赖了具体的数据结构类型，而不是抽象数据结构</li>
<li>增加新的数据结构类麻烦。访问者是依赖了具体的数据结构的，增加一种新的数据结构，需要在访问者种增加新的处理接口</li>
</ul>
<h2 id="五、关于访问者的一些问题"><a href="#五、关于访问者的一些问题" class="headerlink" title="五、关于访问者的一些问题"></a>五、关于访问者的一些问题</h2><h3 id="5-1-访问者模式将数据与操作分离，是否违背面向对象设计原则？"><a href="#5-1-访问者模式将数据与操作分离，是否违背面向对象设计原则？" class="headerlink" title="5.1 访问者模式将数据与操作分离，是否违背面向对象设计原则？"></a>5.1 访问者模式将数据与操作分离，是否违背面向对象设计原则？</h3><ul>
<li>从表面上看，分离数据和操作，是违背了面向对象设计原则的</li>
<li>从另一角度看，操作也可以认为是对象，访问者模式只是将数据对象和操作对象组合起来了</li>
<li>访问者结构中，数据是属于变化比较少的，而操作则是属于变化比较多的</li>
<li>访问者模式，将不变部分（数据）和可变部分（操作）分离，使用组合方式关联，是符合面向对象设计的</li>
</ul>
<h3 id="5-2-访问者模式的替代方案？"><a href="#5-2-访问者模式的替代方案？" class="headerlink" title="5.2 访问者模式的替代方案？"></a>5.2 访问者模式的替代方案？</h3><ul>
<li>可使用工厂方法模式替代</li>
<li>每种操作类型，对应一个操作工厂类，为不同的数据类型生成不同的操作对象</li>
<li>比如文件Word、Pdf，抽取操作对应一个工厂ExtractFactory，为不同数据类型提供不同的实现WordExtractor、PdfExtractor</li>
<li>新增压缩操作Comoress，定义一个工厂CompressFactory，提供不同的操作实现WordCompressor、PdfCompressor</li>
</ul>
<h3 id="5-3-什么时候用访问者模式？什么时候用工厂方法模式？"><a href="#5-3-什么时候用访问者模式？什么时候用工厂方法模式？" class="headerlink" title="5.3 什么时候用访问者模式？什么时候用工厂方法模式？"></a>5.3 什么时候用访问者模式？什么时候用工厂方法模式？</h3><p>具体的使用场景参考：</p>
<ul>
<li>垂直扩展较多，即数据类型可变时，使用工厂模式比较合适</li>
<li>水平扩展较多，即操作类型可变时，使用访问者模式比较合适</li>
<li>垂直、水平扩展都比较多，即数据和操作都可变时，可使用模板模式 + 工厂模式/访问者模式</li>
</ul>
<p>(1) 操作变化少，而数据类型经常变动，如添加新文件类型Txt、Excel等</p>
<ul>
<li>使用访问者模式，就需要修改已有的每种操作类型，不符合开闭原则</li>
<li>使用工厂模式，只需要增加新的工厂类和操作类，无需修改原来的代码，符合开闭原则</li>
</ul>
<p>(2) 数据类型基本不变，但是操作变化多，如为文件添加搜索、过滤、样式等操作</p>
<ul>
<li>使用工厂模式，就需要为每种操作都添加工厂类和操作实现类，虽然符合开闭原则，但是类结构变得很复杂了，类数量也增多了</li>
<li>使用访问者模式，只需要添加新的操作类即可，符合开闭原则，而且可以避免增加很多类</li>
</ul>
<p>(3) 数据类型和操作类型都可变，如文件可扩展Txt、Excel，操作也可扩展搜索、过滤等</p>
<ul>
<li>在数据类型垂直扩展上，可以使用模板模式抽取公共的代码到父类中，避免重复代码</li>
<li>在操作类型水平扩展上，如果操作数量不多，类数量不多，可使用工厂模式实现</li>
<li>在操作类型水平扩展上，如果操作数量很多，可使用访问者模式实现，避免类数量过多</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/design_pattern/state/</url>
    <content><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="一、什么是状态模式？"><a href="#一、什么是状态模式？" class="headerlink" title="一、什么是状态模式？"></a>一、什么是状态模式？</h2><p>状态模式（State Design Pattern）：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<p>通常情况下，状态只作为数据，而不是对象，它只在对象之间进行流转，是对象之间数据交流的一种方式。</p>
<p>状态模式，则是将状态也当成是一个对象，赋予它数据和行为动作，它的数据就是状态，行为动作就是状态转换。</p>
<span id="more"></span>

<h2 id="二、为什么要用状态模式？"><a href="#二、为什么要用状态模式？" class="headerlink" title="二、为什么要用状态模式？"></a>二、为什么要用状态模式？</h2><ul>
<li>对象存在多种状态，在不同状态下，对象会做出不同的行为</li>
<li>对象的状态，会被外部的事件影响，从而导致对象的状态发生变化</li>
</ul>
<p>应对这种情况，一般有几种方法解决。</p>
<h3 id="2-1-分支逻辑法"><a href="#2-1-分支逻辑法" class="headerlink" title="2.1 分支逻辑法"></a>2.1 分支逻辑法</h3><ul>
<li>传统的解决方案是：对不同的状态、事件、动作都考虑到，使用 <code>if-else</code> 加以判断，处理不同的情况</li>
<li><code>if-else</code> 这种方式，代码逻辑复杂，判断条件臃肿，可读性差，可扩展性差，容易遗漏情况</li>
</ul>
<h3 id="2-2-查表法"><a href="#2-2-查表法" class="headerlink" title="2.2 查表法"></a>2.2 查表法</h3><ul>
<li>对分支逻辑法的一种优化是，把 <code>if-else</code> 的判断逻辑迁移到一张表中，比如二维表</li>
<li>通过 <code>key-value</code> 的形式，将状态转换和状态动作都映射成一张二维表，根据状态和事件能直接查到下一步的转换和动作</li>
<li>这种方式，比起 <code>if-else</code> 要优雅一些，代码结构清晰，可读性和可扩展性较好</li>
</ul>
<h3 id="2-3-状态模式"><a href="#2-3-状态模式" class="headerlink" title="2.3 状态模式"></a>2.3 状态模式</h3><ul>
<li>分支逻辑和查表，都是一种正向的逻辑判断，即所有的状态转换和动作执行，都是由外部事件触发和外部处理的</li>
<li>状态模式，则是一种反向思维，事件触发依旧是外部的，但是改成了由状态自己本身进行状态转换和动作执行</li>
<li>状态模式，就是把之前由上下文处理的状态转换和动作，都迁移到了状态对象里面，隔离了不同状态的代码逻辑</li>
<li>优点是，符合“单一职责”，代码可读性好，结构清晰，可读性和可维护性好</li>
<li>缺点是，会引入较多的状态类，代码可维护性变差了一些</li>
</ul>
<h2 id="三、怎么实现状态模式？"><a href="#三、怎么实现状态模式？" class="headerlink" title="三、怎么实现状态模式？"></a>三、怎么实现状态模式？</h2><p>状态模式包括以下几个角色：</p>
<ul>
<li>上下文环境（Context）：用于内部维护一个当前状态，并负责具体状态的切换</li>
<li>抽象状态（State）：定义的状态接口，用以抽象对象的状态行为</li>
<li>具体状态（ConcreteState）：抽象状态的实现类，主要实现是状态的行为以及转换</li>
</ul>
<p>状态模式结构：</p>
<p><img src="/images/assets/designpattern/state.png" alt="状态模式结构"></p>
<p>示例代码结构：</p>
<p><img src="/images/assets/designpattern/state-demo.png" alt="状态模式示例结构"></p>
<p>状态和上下文接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doClock</span><span class="params">(Context context, <span class="keyword">int</span> hour)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doUse</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPhone</span><span class="params">(Context context)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setClock</span><span class="params">(<span class="keyword">int</span> hour)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeState</span><span class="params">(State state)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callSecurityCenter</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordLog</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同状态类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DayState singleton = <span class="keyword">new</span> DayState();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DayState</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DayState <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClock</span><span class="params">(Context context, <span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hour &lt; <span class="number">9</span> || <span class="number">17</span> &lt;= hour) &#123;</span><br><span class="line">            context.changeState(NightState.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUse</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.recordLog(<span class="string">&quot;使用金库（白天）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.callSecurityCenter(<span class="string">&quot;按下警铃（白天）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPhone</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.callSecurityCenter(<span class="string">&quot;正常通话（白天）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;白天&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NightState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NightState singleton = <span class="keyword">new</span> NightState();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NightState</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NightState <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClock</span><span class="params">(Context context, <span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">9</span> &lt;= hour &amp;&amp; hour &lt; <span class="number">17</span>) &#123;</span><br><span class="line">            context.changeState(DayState.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUse</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.callSecurityCenter(<span class="string">&quot;紧急，晚上使用金库！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.callSecurityCenter(<span class="string">&quot;按下警铃（晚上）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPhone</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.callSecurityCenter(<span class="string">&quot;晚上的通话记录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;晚上&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上下文实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span>, <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextField textClock = <span class="keyword">new</span> TextField(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">private</span> TextArea textScreen = <span class="keyword">new</span> TextArea(<span class="number">10</span>, <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">private</span> Button buttonUse = <span class="keyword">new</span> Button(<span class="string">&quot;使用金库&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Button buttonAlarm = <span class="keyword">new</span> Button(<span class="string">&quot;按下警铃&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Button buttonPhone = <span class="keyword">new</span> Button(<span class="string">&quot;正常通话&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Button buttonExit = <span class="keyword">new</span> Button(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state = DayState.getInstance();</span><br><span class="line">    <span class="keyword">private</span> ActionEvent e;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeFrame</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">        setBackground(Color.lightGray);</span><br><span class="line">        setLayout(<span class="keyword">new</span> BorderLayout());</span><br><span class="line"></span><br><span class="line">        add(textClock, BorderLayout.NORTH);</span><br><span class="line">        textClock.setEditable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        add(textScreen, BorderLayout.CENTER);</span><br><span class="line">        textScreen.setEditable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Panel panel = <span class="keyword">new</span> Panel();</span><br><span class="line">        panel.add(buttonUse);</span><br><span class="line">        panel.add(buttonAlarm);</span><br><span class="line">        panel.add(buttonPhone);</span><br><span class="line">        panel.add(buttonExit);</span><br><span class="line"></span><br><span class="line">        add(panel, BorderLayout.SOUTH);</span><br><span class="line"></span><br><span class="line">        pack();</span><br><span class="line">        show();</span><br><span class="line"></span><br><span class="line">        buttonUse.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonAlarm.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonPhone.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonExit.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">        <span class="keyword">if</span> (e.getSource() == buttonUse) &#123;</span><br><span class="line">            state.doUse(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getSource() == buttonAlarm) &#123;</span><br><span class="line">            state.doAlarm(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == buttonPhone) &#123;</span><br><span class="line">            state.doPhone(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == buttonExit) &#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClock</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">        String clockString = <span class="string">&quot;现在时间是 &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (hour &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            clockString += <span class="string">&quot;0&quot;</span> + hour + <span class="string">&quot;:00&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clockString += hour + <span class="string">&quot;:00&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(clockString);</span><br><span class="line">        textClock.setText(clockString);</span><br><span class="line">        state.doClock(<span class="keyword">this</span>, hour);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从 &quot;</span> + <span class="keyword">this</span>.state + <span class="string">&quot; 状态变为了 &quot;</span> + state + <span class="string">&quot; 状态。&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callSecurityCenter</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        textScreen.append(<span class="string">&quot;呼叫： &quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        textScreen.append(<span class="string">&quot;记录 ... &quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、状态模式有什么优缺点？"><a href="#四、状态模式有什么优缺点？" class="headerlink" title="四、状态模式有什么优缺点？"></a>四、状态模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>结构清晰。将状态相关的转换和动作都局部化分割到状态对象中，符合“单一职责”原则</li>
<li>可扩展性强。很容易就能扩展一种新状态，不过可能要修改其他状态类的转换代码</li>
</ul>
<p>缺点：</p>
<ul>
<li>类数据增多。每个状态都是一个类，必然会导致状态类增多</li>
<li>状态转换结构不清晰。状态转换写在每个单独的状态类里面，而没有一个完整的转换图，在代码可读性上不是那么好</li>
</ul>
<h2 id="五、与其他模式的对比"><a href="#五、与其他模式的对比" class="headerlink" title="五、与其他模式的对比"></a>五、与其他模式的对比</h2><h3 id="5-1-职责链模式"><a href="#5-1-职责链模式" class="headerlink" title="5.1 职责链模式"></a>5.1 职责链模式</h3><ul>
<li>职责链模式和状态模式，都能处理过多 <code>if-else</code> 的问题</li>
<li>职责链模式，强调的是对象间状态的转移，不同对象之间并不知道对方的存在，只是由外部按照职责链顺序执行</li>
<li>状态模式，更强调的是对象内状态的转换，对象之间互相知道对方的存在，便于进行状态转换</li>
</ul>
<h3 id="5-2-策略模式"><a href="#5-2-策略模式" class="headerlink" title="5.2 策略模式"></a>5.2 策略模式</h3><ul>
<li>策略模式，对象之间是以一种可互相替换的方式存在</li>
<li>状态模式，对象是以不同状态的形式存在，是一种互相转换的关系，但不是可替换的</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/design_pattern/observer/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="一、什么是观察者模式？"><a href="#一、什么是观察者模式？" class="headerlink" title="一、什么是观察者模式？"></a>一、什么是观察者模式？</h2><p>观察者模式（Observer Design Pattern）：多个对象之间存在一对多的关系，当一个对象的状态发生改变时，所有其他依赖的对象都会收到通知。</p>
<p>观察者模式也被称为发布-订阅模式。</p>
<p>负责通知其他依赖对象称为被观察者，被通知的对象称为观察者。</p>
<p>在现实中，对象之间总是存在依赖关系的，一个对象的状态改变，往往会影响到其他的依赖对象。</p>
<span id="more"></span>

<p>观察者模式主要用于一对多的关系的情况，当某个对象状态发生改变时，需要通知其他所有的依赖对象。</p>
<p>比如说公众号订阅、天气预报通知等，都属于观察者模式。</p>
<h2 id="二、为什么要用观察者模式？"><a href="#二、为什么要用观察者模式？" class="headerlink" title="二、为什么要用观察者模式？"></a>二、为什么要用观察者模式？</h2><p>为什么要用观察者模式？</p>
<p>假如不用观察者模式，那按照正常的逻辑，一对多的影响关系应该如何做呢？</p>
<p>没办法，只能把所有依赖对象都放在状态对象里面，当状态改变后，逐个调用依赖对象的接口去通知变更。</p>
<ul>
<li>状态对象必须知道各个依赖对象的存在以及它们的类型，才能准确地调用它们的接口</li>
<li>一旦要新增依赖对象，只能去修改状态对象的代码</li>
<li>没办法很好做到动态添加和删除依赖对象，灵活性不够</li>
<li>状态对象和依赖对象都放在一起，代码耦合性高，而且扩展性很差</li>
</ul>
<p>观察者模式，目的就是为了将依赖对象解耦，并且实现动态添加和删除依赖对象。</p>
<h2 id="三、观察者模式怎么用？"><a href="#三、观察者模式怎么用？" class="headerlink" title="三、观察者模式怎么用？"></a>三、观察者模式怎么用？</h2><p>观察者模式中的几个角色：</p>
<ul>
<li>抽象被观察者（Subject）：表示被观察的对象，定义了注册、删除、通知观察者的方法。</li>
<li>具体被观察者（ConcreteSubject）：具体被观察对象的实现，主要是状态变化后，通知所有观察者的实现</li>
<li>抽象观察者（Observer）：抽象观察者，定义了被通知的接口回调方法</li>
<li>具体观察者（ConcreteObserver）：实现了抽象观察者的通知方法，执行具体的行为</li>
</ul>
<p>观察者模式结构：</p>
<p><img src="/images/assets/designpattern/observer.png" alt="观察者模式结构结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/observer-demo.png" alt="示例程序结构"></p>
<p>示例程序代码：</p>
<p>观察者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 观察者被通知的回调接口 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator generator)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigitObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator generator)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DigitObserver: &quot;</span> + generator.getNumber());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator generator)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GraphObserver: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> count = generator.getNumber();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被观察者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberGenerator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 观察者集合 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 添加观察者 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 移除观察者 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通知所有观察者 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 被观察者状态改变的接口方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomNumberGenerator</span> <span class="keyword">extends</span> <span class="title">NumberGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            number = random.nextInt(<span class="number">50</span>);</span><br><span class="line">            notifyObservers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、观察者模式有什么优缺点？"><a href="#四、观察者模式有什么优缺点？" class="headerlink" title="四、观察者模式有什么优缺点？"></a>四、观察者模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>降低了被观察者与观察者的耦合度</li>
<li>提高了灵活性，方便新增和删除观察者对象</li>
</ul>
<p>缺点：</p>
<ul>
<li>在多对多的情况下，观察者之间可能会比较混乱，容易出现循环</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/design_pattern/interpreter/</url>
    <content><![CDATA[<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><h2 id="一、什么是解释器模式？"><a href="#一、什么是解释器模式？" class="headerlink" title="一、什么是解释器模式？"></a>一、什么是解释器模式？</h2><p>解释器模式（Interpreter Design Pattern）：对具有某种语法规则的语言表示，定义一个解释器来处理这个语法</p>
<blockquote>
<p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p>
</blockquote>
<p>解释器模式的一些特点：</p>
<ul>
<li>存在某种语法规则，比如算术运算表达式，中英文翻译等</li>
<li>语法规则可能会出现循环、递归</li>
<li>解释器模式就是根据语法规则去解读“句子”</li>
</ul>
<span id="more"></span>

<h2 id="二、为什么要用解释器模式？"><a href="#二、为什么要用解释器模式？" class="headerlink" title="二、为什么要用解释器模式？"></a>二、为什么要用解释器模式？</h2><p>场景：</p>
<ul>
<li>一些重复出现的问题可以用一种简单的语言来表达</li>
<li>当有一个语言中的句子可以表示为一个抽象语法树时</li>
</ul>
<p>原理：</p>
<ul>
<li>简单的语法规则，可以不用解释器模式，防止过度设计</li>
<li>复杂的语法规则解析，逻辑复杂，代码量多</li>
<li>复杂语法解析代码都写在一个类中，代码的耦合度会很高，并且不易维护和扩展</li>
<li>将语法规则拆分成多条细则，拆分到各个小类中，避免解析类过于膨胀</li>
<li>每条细则，都是单独的单元，只负责对这部分语法规则进行解析</li>
</ul>
<h2 id="三、解释器的结构是怎么样的？"><a href="#三、解释器的结构是怎么样的？" class="headerlink" title="三、解释器的结构是怎么样的？"></a>三、解释器的结构是怎么样的？</h2><p>解释器中包含的角色有：</p>
<ul>
<li>抽象表达式（AbstrctExpression）：定义了语法树节点的共同接口</li>
<li>终结符表达式（TerminalExpression）：负责语法树中的叶子节点</li>
<li>非终结符表达式（NoterminalExpression）：负责语法树中的非叶子节点</li>
<li>上下文环境（Context）：提供必要信息或者公共的方法</li>
</ul>
<p><img src="/images/assets/designpattern/interpreter.png" alt="解释器结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/interpreter-demo.png" alt="示例程序结构"></p>
<p>抽象表达式（AbstrctExpression）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终结符表达式（TerminalExpression）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveCommandNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;primitive command&gt; ::= go | right | left</span></span><br><span class="line">        name = context.currentToken();</span><br><span class="line">        context.skipToken(name);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;go&quot;</span>.equals(name) &amp;&amp; !<span class="string">&quot;right&quot;</span>.equals(name) &amp;&amp; !<span class="string">&quot;left&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(name + <span class="string">&quot; is undefined&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非终结符表达式（NoterminalExpression）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node commandListNode;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;program&gt; ::= program &lt;command list&gt;</span></span><br><span class="line">        context.skipToken(<span class="string">&quot;program&quot;</span>);</span><br><span class="line">        commandListNode = <span class="keyword">new</span> CommandListNode();</span><br><span class="line">        commandListNode.parse(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + <span class="string">&quot;program=&quot;</span> + commandListNode + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandListNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Node&gt; commandNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;command list&gt; ::= &lt;command&gt;* end</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.currentToken() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">&quot;Missing end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;end&quot;</span>.equals(context.currentToken())) &#123;</span><br><span class="line">                context.skipToken(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node commandNode = <span class="keyword">new</span> CommandNode();</span><br><span class="line">            commandNode.parse(context);</span><br><span class="line">            commandNodes.add(commandNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commandNodes.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node node;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;repeat&quot;</span>.equals(context.currentToken())) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> RepeatCommandNode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = <span class="keyword">new</span> PrimitiveCommandNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node.parse(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatCommandNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> Node commandListNode;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt;</span></span><br><span class="line">        context.skipToken(<span class="string">&quot;repeat&quot;</span>);</span><br><span class="line">        number = context.currentNumber();</span><br><span class="line">        context.nextToken();</span><br><span class="line">        commandListNode = <span class="keyword">new</span> CommandListNode();</span><br><span class="line">        commandListNode.parse(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[repeat &quot;</span> + number +  <span class="string">&quot; &quot;</span> + commandListNode + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上下文环境（Context）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringTokenizer tokenizer;</span><br><span class="line">    <span class="keyword">private</span> String currentToken;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        tokenizer = <span class="keyword">new</span> StringTokenizer(text);</span><br><span class="line">        nextToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">nextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">            currentToken = tokenizer.nextToken();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentToken = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">currentToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipToken</span><span class="params">(String token)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!token.equals(currentToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">&quot;Warning: &quot;</span> + token + <span class="string">&quot; is expected, but &quot;</span> + currentToken + <span class="string">&quot; is found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        nextToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">currentNumber</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            number = Integer.parseInt(currentToken);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">&quot;Warning: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、解释器模式有什么优缺点？"><a href="#四、解释器模式有什么优缺点？" class="headerlink" title="四、解释器模式有什么优缺点？"></a>四、解释器模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>符合“单一职责”原则，每个语法细则都是一个类，只负责自己那部分的解析</li>
<li>可扩展性好，扩展新的语法规则简单，只需要新增类或者继承已有类即可</li>
</ul>
<p>缺点：</p>
<ul>
<li>引起类膨胀，每条规则都定义一个类，如果规则很多，就会出现大量的类</li>
<li>执行效率低，使用了大量的循环和递归，同时调试也很麻烦</li>
<li>应用场景少，简单的规则一般用不上解释器模式，复杂规则的场景比较少，一般用在语言解析比较多</li>
</ul>
<h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h2><ul>
<li>正则表达式</li>
<li>算术运算表达式</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/design_pattern/command/</url>
    <content><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="一、什么是命令模式？"><a href="#一、什么是命令模式？" class="headerlink" title="一、什么是命令模式？"></a>一、什么是命令模式？</h2><p>命令模式（Command Design Pattern）：将请求封装为一个对象，使得发出请求的责任和执行请求的责任分割开。</p>
<p>命令有时也可以称为事件，比如点击鼠标、按下键盘等事件，通常会将它们封装成一个事件对象，然后按顺序放入队列中，再逐个去处理它们。</p>
<span id="more"></span>

<h2 id="二、为什么要用命令模式？"><a href="#二、为什么要用命令模式？" class="headerlink" title="二、为什么要用命令模式？"></a>二、为什么要用命令模式？</h2><ul>
<li>大部分编程语言是无法将函数作为参数传递给其他函数的</li>
<li>利用命令模式，可以把函数封装成命令对象，模拟函数作为参数</li>
<li>命令模式，主要用来控制命令的执行，比如异步、延迟、排队等，同时还支持撤销、重做、存储、统计命令等</li>
</ul>
<h2 id="三、命令模式的结构是怎么样的？"><a href="#三、命令模式的结构是怎么样的？" class="headerlink" title="三、命令模式的结构是怎么样的？"></a>三、命令模式的结构是怎么样的？</h2><p>命令模式包含以下几个角色：</p>
<ul>
<li>抽象命令：负责定义命令接口</li>
<li>具体的命令：负责实现命令接口</li>
<li>命令接收者：执行命令时的目标对象</li>
<li>命令发动者：发动执行命令的角色，或者说持有命令，并开始执行命令的地方</li>
</ul>
<p><img src="/images/assets/designpattern/command.png" alt="命令模式结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/command-demo.png" alt="命令模式示例结构"></p>
<p>抽象命令接口（Command）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的命令（ConcreteCommand）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Drawable drawable;</span><br><span class="line">    <span class="keyword">private</span> Point position;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawCommand</span><span class="params">(Drawable drawable, Point position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawable = drawable;</span><br><span class="line">        <span class="keyword">this</span>.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawable.draw(position.x, position.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack commands = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator it = commands.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            ((Command)it.next()).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(Command cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd != <span class="keyword">this</span>) &#123;</span><br><span class="line">            commands.push(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!commands.isEmpty()) &#123;</span><br><span class="line">            commands.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commands.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令接收者（Receiver）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令发动者（Invoker）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawCanvas</span> <span class="keyword">extends</span> <span class="title">Canvas</span> <span class="keyword">implements</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 颜色 */</span></span><br><span class="line">    <span class="keyword">private</span> Color color = Color.red;</span><br><span class="line">    <span class="comment">/* 绘制的原点半径 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">/* 历史记录 */</span></span><br><span class="line">    <span class="keyword">private</span> MacroCommand history;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawCanvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, MacroCommand history)</span> </span>&#123;</span><br><span class="line">        setSize(width, height);</span><br><span class="line">        setBackground(Color.white);</span><br><span class="line">        <span class="keyword">this</span>.history = history;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;paint&quot;</span>);</span><br><span class="line">        history.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        Graphics g = getGraphics();</span><br><span class="line">        g.setColor(color);</span><br><span class="line">        g.fillOval(x - radius, y - radius, radius * <span class="number">2</span>, radius * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、命令模式有什么优缺点？"><a href="#四、命令模式有什么优缺点？" class="headerlink" title="四、命令模式有什么优缺点？"></a>四、命令模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>结构清晰，请求与接收解耦，命令之间相互隔离</li>
<li>扩展性好，很方便就能扩展新的命令</li>
</ul>
<p>缺点：</p>
<ul>
<li>容易产生大量的命令类，增加系统复杂度</li>
<li>请求和接收是分离的，可读性变差了，增加了代码理解上的难度</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/design_pattern/flyweight/</url>
    <content><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="一、享元模式是什么？"><a href="#一、享元模式是什么？" class="headerlink" title="一、享元模式是什么？"></a>一、享元模式是什么？</h2><p>享元设计模式（FlyWeight Design Pattern）：通过共享已有实例，来避免创建新的实例，减少空间消耗，提高资源利用率</p>
<p>享元，意思就是共享的对象、单元、元素等。</p>
<span id="more"></span>

<p>主要特点：</p>
<ul>
<li>相同实例对象只保留一份，即享元对象</li>
<li>需要某个实例时，尽量共用享元对象</li>
<li>享元对象可以减少对象的数量</li>
</ul>
<p>享元模式的本质就是缓存对象，减少资源消耗。</p>
<h2 id="二、为什么要用享元模式？"><a href="#二、为什么要用享元模式？" class="headerlink" title="二、为什么要用享元模式？"></a>二、为什么要用享元模式？</h2><p>享元模式，目的就是为了共享对象、减少资源的消耗。</p>
<p>使用享元模式，为的就是减少资源消耗、降低内存，提高资源利用率。</p>
<h2 id="三、该如何用享元模式？"><a href="#三、该如何用享元模式？" class="headerlink" title="三、该如何用享元模式？"></a>三、该如何用享元模式？</h2><p>使用享元模式，需要注意几点：</p>
<ul>
<li>享元对象应该是不可变的，即没有setter方法</li>
<li>享元对象会对所有地方都有影响</li>
<li>享元对象中不应该存在可变的信息，即有可能发生变化的内容</li>
<li>享元对象不应该被垃圾回收</li>
<li>享元对象的内部状态是不可变的，外部转台是可变的</li>
</ul>
<p>比如，数据库连接池，用户名、密码、url这些属于享元对象的内部状态，不可变；</p>
<p>连接可用标记等属性，属于外部状态，是可变的，比如回收连接后，可用标记会设为true。</p>
<p>享元模式的几个角色包括：</p>
<ul>
<li>抽象享元角色（FlyWeight）：表示享元类的接口</li>
<li>具体享元角色（ConcreteFlyWeight）：表示被共享的享元实例对象</li>
<li>非享元角色（Unsharable Flyweight）：表示外部状态，区别于享元对象的内部状态，以参数形式注入享元对象</li>
<li>享元工厂（FlyWeightFactory）：负责生成和管理享元对象的工厂</li>
</ul>
<p>享元模式结构：</p>
<p><img src="/images/assets/designpattern/flyweight.png" alt="享元模式结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/flyweight-demo.png" alt="享元模式结构"></p>
<p>享元类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigChar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符名称 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> charName;</span><br><span class="line">    <span class="comment">/* 字体字符串 */</span></span><br><span class="line">    <span class="keyword">private</span> String fontData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigChar</span><span class="params">(<span class="keyword">char</span> charName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charName = charName;</span><br><span class="line">        loadCharData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadCharData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String fileDir = <span class="string">&quot;src/com/pattern/flyweight/numbers/&quot;</span>;</span><br><span class="line">        String fileName = fileDir + <span class="string">&quot;big&quot;</span> + charName + <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buf.append(line).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fontData = buf.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>享元工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigCharFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BigCharFactory instance = <span class="keyword">new</span> BigCharFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 享元对象池 */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BigChar&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BigCharFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigCharFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取享元对象接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigChar <span class="title">getChar</span><span class="params">(<span class="keyword">char</span> charName)</span> </span>&#123;</span><br><span class="line">        BigChar bigChar = pool.get(<span class="string">&quot;&quot;</span> + charName);</span><br><span class="line">        <span class="keyword">if</span> (bigChar == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bigChar = <span class="keyword">new</span> BigChar(charName);</span><br><span class="line">            pool.put(<span class="string">&quot;&quot;</span> + charName, bigChar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bigChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>享元使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigChar[] chars;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        loadString(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        chars = <span class="keyword">new</span> BigChar[string.length()];</span><br><span class="line">        BigCharFactory factory = BigCharFactory.getInstance();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> charName = string.charAt(i);</span><br><span class="line">            chars[i] = factory.getChar(charName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、享元模式有什么优缺点？"><a href="#四、享元模式有什么优缺点？" class="headerlink" title="四、享元模式有什么优缺点？"></a>四、享元模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>共享相同对象，资源消耗低、利用率高</li>
<li>对象数量少，方便管理享元对象</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要将共享对象分离出来，可能会使得程序变得复杂</li>
</ul>
<h2 id="五、享元和单例、缓存、对象池的区别"><a href="#五、享元和单例、缓存、对象池的区别" class="headerlink" title="五、享元和单例、缓存、对象池的区别"></a>五、享元和单例、缓存、对象池的区别</h2><h3 id="5-1-享元-vs-单例"><a href="#5-1-享元-vs-单例" class="headerlink" title="5.1 享元 vs. 单例"></a>5.1 享元 vs. 单例</h3><ul>
<li><p>单例本质是为了控制实例的数量，重点在于数量。</p>
</li>
<li><p>享元关注的点是实例共享，重点在于共享，数量不是主要矛盾。</p>
</li>
</ul>
<h3 id="5-2-享元-vs-缓存"><a href="#5-2-享元-vs-缓存" class="headerlink" title="5.2 享元 vs. 缓存"></a>5.2 享元 vs. 缓存</h3><ul>
<li><p>缓存的作用是为了提高查询速度，目的在于提高效率。</p>
</li>
<li><p>享元的目标是为了降低资源消耗，主要关注点是资源的利用率。</p>
</li>
</ul>
<h3 id="5-3-享元-vs-对象池"><a href="#5-3-享元-vs-对象池" class="headerlink" title="5.3 享元 vs. 对象池"></a>5.3 享元 vs. 对象池</h3><ul>
<li><p>对象池主要用于管理对象，重点在于对一批对象进行管理分配回收。</p>
</li>
<li><p>享元主要还是为了对象的复用，在管理方面不是特别关注。</p>
</li>
</ul>
<h3 id="六、享元模式的实际应用"><a href="#六、享元模式的实际应用" class="headerlink" title="六、享元模式的实际应用"></a>六、享元模式的实际应用</h3><p>Integer：</p>
<ul>
<li>Java 中 Integer 默认缓存 -128 ~ 127 之间的数字对象</li>
<li>Integer 的缓存对象是一开始就创建好的</li>
</ul>
<p>String：</p>
<ul>
<li>Java 中 String 对象会缓存到字符串常量池中，其他地方可以直接引用</li>
<li>String 的常量池对象是动态创建的</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>门面模式</title>
    <url>/design_pattern/facade/</url>
    <content><![CDATA[<h1 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h1><h2 id="一、什么门面模式？"><a href="#一、什么门面模式？" class="headerlink" title="一、什么门面模式？"></a>一、什么门面模式？</h2><p>门面模式（Facade Design Pattern）：为子系统提供一组统一的接口，定义一组高层接口让系统更加易用。</p>
<h2 id="二、接口设计存在什么问题？"><a href="#二、接口设计存在什么问题？" class="headerlink" title="二、接口设计存在什么问题？"></a>二、接口设计存在什么问题？</h2><ul>
<li><p>接口粒度过小时，接口的易用性就会变低，需要调用多个接口才能完成一件事</p>
</li>
<li><p>接口粒度过大时，可复用性就会变低，需要针对不同业务需求实现不同的接口，导致接口无限膨胀</p>
</li>
<li><p>当一个系统的功能越来越强，子系统会越来越多，对子系统的访问也变得越来越复杂</p>
</li>
</ul>
<span id="more"></span>

<h2 id="二、门面模式有什么用处？"><a href="#二、门面模式有什么用处？" class="headerlink" title="二、门面模式有什么用处？"></a>二、门面模式有什么用处？</h2><h3 id="2-1-设计原理"><a href="#2-1-设计原理" class="headerlink" title="2.1 设计原理"></a>2.1 设计原理</h3><ul>
<li>把粒度小的接口封装统一的门面接口，提高接口的易用性</li>
<li>可以针对不同的业务需求，组装复用接口，形成不同的门面接口</li>
<li>通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问</li>
<li>对外有统一的接口，外部程序无需知道内部子系统的实现，提高了易用性和可维护性</li>
</ul>
<h3 id="2-2-实际应用场景"><a href="#2-2-实际应用场景" class="headerlink" title="2.2 实际应用场景"></a>2.2 实际应用场景</h3><ul>
<li>在日常编码工作中，我们都在有意无意的大量使用外观模式。比如，高层模块要调度多个模块的类（2个以上的类对象），我们就会创建一个新的类封装它们，并提供精简的接口给高层模块用</li>
<li>各种第三方SDK、开源类库，很大概率都会使用外观模式</li>
<li>移动端通过门面模式可以把很多个请求合并成一个，减少发送的请求数量，提高移动端的加载速度</li>
</ul>
<h2 id="三、门面模式怎么用？"><a href="#三、门面模式怎么用？" class="headerlink" title="三、门面模式怎么用？"></a>三、门面模式怎么用？</h2><p>门面模式不是增加功能接口，实际上只是通过对已有接口进行组合封装，形成一个对外的统一接口。</p>
<p>由门面接口把原始接口组装起来，控制接口的调用顺序，这样外部调用时就不需要自己去实现流程控制了。</p>
<h3 id="3-1-模式结构"><a href="#3-1-模式结构" class="headerlink" title="3.1 模式结构"></a>3.1 模式结构</h3><p><img src="/images/assets/designpattern/facade.png" alt="门面结构"></p>
<h3 id="3-2-示例程序"><a href="#3-2-示例程序" class="headerlink" title="3.2 示例程序"></a>3.2 示例程序</h3><p><img src="/images/assets/designpattern/facade-demo.png" alt="门面示例程序结构"></p>
<p>子系统1（<code>Database</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Database</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">getProperties</span><span class="params">(String dbname)</span> </span>&#123;</span><br><span class="line">        String filename = <span class="string">&quot;src/com/pattern/facade/&quot;</span> + dbname + <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prop.load(<span class="keyword">new</span> FileInputStream(filename));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Warning: &quot;</span> + filename + <span class="string">&quot; is not found&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子系统2（<code>HtmlWriter</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlWriter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Writer writer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HtmlWriter</span><span class="params">(Writer writer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.writer = writer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">title</span><span class="params">(String title)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;title&quot;</span> + title + <span class="string">&quot;&lt;/title&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;body&gt;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;h1&gt;&quot;</span> + title + <span class="string">&quot;&lt;/h1&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paragraph</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;p&gt;&quot;</span> + msg + <span class="string">&quot;&lt;/p&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(String href, String caption)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        paragraph(<span class="string">&quot;&lt;a href=\&quot;&quot;</span> + href + <span class="string">&quot;\&quot;&gt;&quot;</span> + caption + <span class="string">&quot;&lt;/a&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailto</span><span class="params">(String mailAddr, String username)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        link(<span class="string">&quot;mailto: &quot;</span> + mailAddr, username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;/html&gt;\n&quot;</span>);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>门面接口（<code>PageMaker</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageMaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PageMaker</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeWelcomePage</span><span class="params">(String mailAddr, String filename)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties mailProp = Database.getProperties(<span class="string">&quot;maildata&quot;</span>);</span><br><span class="line">            String username = mailProp.getProperty(mailAddr);</span><br><span class="line">            HtmlWriter writer = <span class="keyword">new</span> HtmlWriter(<span class="keyword">new</span> FileWriter(filename));</span><br><span class="line">            writer.title(<span class="string">&quot;Welcome to &quot;</span> + username + <span class="string">&quot;&#x27;s page!&quot;</span>);</span><br><span class="line">            writer.paragraph(username + <span class="string">&quot; 欢迎来到 &quot;</span> + username + <span class="string">&quot; 的主页。&quot;</span>);</span><br><span class="line">            writer.paragraph(<span class="string">&quot;等待你的邮件哦！&quot;</span>);</span><br><span class="line">            writer.mailto(mailAddr, username);</span><br><span class="line">            writer.close();</span><br><span class="line">            System.out.println(filename + <span class="string">&quot; is created for &quot;</span> + mailAddr + <span class="string">&quot; (&quot;</span> + username + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四、门面模式的优缺点是什么？"><a href="#四、门面模式的优缺点是什么？" class="headerlink" title="四、门面模式的优缺点是什么？"></a>四、门面模式的优缺点是什么？</h2><p>优点：</p>
<ul>
<li>把粒度小的接口封装统一的门面接口，提高接口的易用性</li>
<li>可以针对不同的业务需求，组装复用接口，形成不同的门面接口</li>
</ul>
<p>缺点：</p>
<ul>
<li>违反“开闭原则”，增加新的子系统，可能需要修改门面类的代码</li>
<li>代码的冗余，门面模式实际只是对接口进行组装，并不包含业务功能代码</li>
<li>不可复用性，门面接口一般是针对特定的业务需求组合封装而成，所以复用性不好</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/design_pattern/decorator/</url>
    <content><![CDATA[<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="一、什么是装饰器模式？"><a href="#一、什么是装饰器模式？" class="headerlink" title="一、什么是装饰器模式？"></a>一、什么是装饰器模式？</h2><p>装饰器（Decorator）模式：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p>
<p>在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。</p>
<span id="more"></span>

<h2 id="二、为什么要用装饰器模式？"><a href="#二、为什么要用装饰器模式？" class="headerlink" title="二、为什么要用装饰器模式？"></a>二、为什么要用装饰器模式？</h2><h3 id="2-1-装饰和代理"><a href="#2-1-装饰和代理" class="headerlink" title="2.1 装饰和代理"></a>2.1 装饰和代理</h3><p>装饰器模式和代理模式，都可以用于增强原始类现有功能，但它们的使用还是有一点区别的：</p>
<ul>
<li>代理模式中，增加的功能是与原始类核心功能无关的</li>
<li>装饰器模式中，增加的功能是与原始类核心功能相关的</li>
<li>装饰器模式中，装饰器和原始类都是继承于同一个父类，因而可以实现嵌套装饰</li>
</ul>
<h3 id="2-2-装饰和继承"><a href="#2-2-装饰和继承" class="headerlink" title="2.2 装饰和继承"></a>2.2 装饰和继承</h3><p>继承也可以实现功能增强，装饰和继承的区别在于：</p>
<ul>
<li>继承可能会导致类组合爆炸，类结构异常复杂，代码不易维护和扩展</li>
<li>装饰器模式使用组合替代继承，而且继承于同一父类，代码易于扩展</li>
</ul>
<h2 id="三、怎么用装饰器模式？"><a href="#三、怎么用装饰器模式？" class="headerlink" title="三、怎么用装饰器模式？"></a>三、怎么用装饰器模式？</h2><h3 id="3-1-模式的结构是怎么样的？"><a href="#3-1-模式的结构是怎么样的？" class="headerlink" title="3.1 模式的结构是怎么样的？"></a>3.1 模式的结构是怎么样的？</h3><p>装饰器模式的主要角色包括：</p>
<ol>
<li>抽象构件角色（Component）：定义的抽象接口，用于规范被附加功能的对象</li>
<li>具体构件角色（ConcreteComponet）：实现抽象构件，实现它自己的核心功能</li>
<li>抽象装饰角色（Decorator）：定义的抽象装饰接口，继承于抽象构件，并包含具体构件的实例</li>
<li>具体装饰角色（ConcreteDecorator）：实现抽象装饰接口，为具体构件对象添加额外的功能</li>
</ol>
<p><img src="/images/assets/designpattern/decorator.png" alt="装饰器结构"></p>
<h3 id="3-2-装饰器模式示例"><a href="#3-2-装饰器模式示例" class="headerlink" title="3.2 装饰器模式示例"></a>3.2 装饰器模式示例</h3><p>示例程序的类结构图：</p>
<p><img src="/images/assets/designpattern/decorator-display.png" alt="装饰器结构"></p>
<p>抽象构件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getRows(); i++) &#123;</span><br><span class="line">            System.out.println(getRowText(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体构件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplay</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringDisplay</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string.getBytes().length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象装饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Border</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Display display;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Border</span><span class="params">(Display display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> display.getColumns();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> display.getRows();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> display.getRowText(row);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体装饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SideBorder</span> <span class="keyword">extends</span> <span class="title">Border</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> borderChar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SideBorder</span><span class="params">(Display display, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(display);</span><br><span class="line">        <span class="keyword">this</span>.borderChar = ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右两边加上装饰符后，长度需要加2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + display.getColumns() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给左右两边加上装饰符</span></span><br><span class="line">        <span class="keyword">return</span> borderChar + display.getRowText(row) + borderChar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullBorder</span> <span class="keyword">extends</span> <span class="title">Border</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FullBorder</span><span class="params">(Display display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(display);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + display.getColumns() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + display.getRows() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上边框</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;+&quot;</span> + makeLine(<span class="string">&#x27;-&#x27;</span>, display.getColumns()) + <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row == display.getRows() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 下边框</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;+&quot;</span> + makeLine(<span class="string">&#x27;-&#x27;</span>, display.getColumns()) + <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;|&quot;</span> + display.getRowText(row - <span class="number">1</span>) + <span class="string">&quot;|&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">makeLine</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四、装饰器模式有什么优缺点？"><a href="#四、装饰器模式有什么优缺点？" class="headerlink" title="四、装饰器模式有什么优缺点？"></a>四、装饰器模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>使用组合代替继承，可以灵活地扩展功能，即插即用</li>
<li>不同装饰者的组合，可以实现不同的功能效果</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用装饰器模式会增加很多子类，使用起来可能会比较麻烦</li>
<li>如果过度使用装饰器，可能会导致类嵌套过深，增加了程序的复杂性</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/design_pattern/composite/</url>
    <content><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="一、组合模式是什么？"><a href="#一、组合模式是什么？" class="headerlink" title="一、组合模式是什么？"></a>一、组合模式是什么？</h2><p><code>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</code></p>
<p>组合模式（Composite Design Pattern）：将一组对象组织成树形结构，以表示一种“部分 - 整体”的层次结构。</p>
<p>也可以这么说，组合模式就是把容器与内容看成同一种对象，并将它们组合成树状结构，创造一种递归的形式。</p>
<p>比如文件和目录，虽然直观上是不同的对象，但是如果使用组合模式来实现它们的话，可以将文件和目录都看成是继承于同一种条目类，因此算是属于同一类对象。</p>
<span id="more"></span>

<p>其次，目录中又可以继续放文件和目录，形成了递归，最终是一种树状的层次结构。</p>
<h2 id="二、为什么要用组合模式？"><a href="#二、为什么要用组合模式？" class="headerlink" title="二、为什么要用组合模式？"></a>二、为什么要用组合模式？</h2><p>组合模式使用的场景有限，对数据格式比较严格：</p>
<ul>
<li>数据必须是一种树形结构，类似文件和目录</li>
</ul>
<p>尽管场景少，但是数据满足递归结构时，组合模式还是能发挥比较大的作用的：</p>
<ul>
<li>组合模式可以让客户端以统一的方式访问数据节点，因为它们是同一种对象</li>
</ul>
<h2 id="三、组合模式的结构是怎么样的？"><a href="#三、组合模式的结构是怎么样的？" class="headerlink" title="三、组合模式的结构是怎么样的？"></a>三、组合模式的结构是怎么样的？</h2><p>组合模式包含的角色有以下几个：</p>
<ul>
<li>抽象组件（Component）：为树叶组件和复合组件提供一致性的抽象接口，并实现它们的默认行为</li>
<li>树叶组件（Leaf）：表示内容，不能再放其他抽象组件对象，在结构中属于最小对象</li>
<li>复合组件（Composite）：表示容器，可以放入其他抽象组件对象，包括树叶组件和复合组件</li>
</ul>
<p><img src="/images/assets/designpattern/composite.png" alt="组合模式结构"></p>
<p>示例程序结构：</p>
<p><img src="/images/assets/designpattern/composite-demo.png" alt="组合模式结构"></p>
<p>抽象组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> FileTreatmentException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileTreatmentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printList(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getName() + <span class="string">&quot; (&quot;</span> + getSize() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树叶组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        System.out.println(prefix + <span class="string">&quot;/&quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复合组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Entry&gt; directory = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : directory) &#123;</span><br><span class="line">            size += entry.getSize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> FileTreatmentException </span>&#123;</span><br><span class="line">        directory.add(entry);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        System.out.println(prefix + <span class="string">&quot;/&quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : directory) &#123;</span><br><span class="line">            entry.printList(prefix + <span class="string">&quot;/&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Making root entries...&quot;</span>);</span><br><span class="line">        Directory rootDir = <span class="keyword">new</span> Directory(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        Directory binDir = <span class="keyword">new</span> Directory(<span class="string">&quot;bin&quot;</span>);</span><br><span class="line">        Directory tmpDir = <span class="keyword">new</span> Directory(<span class="string">&quot;tmp&quot;</span>);</span><br><span class="line">        Directory usrDir = <span class="keyword">new</span> Directory(<span class="string">&quot;usr&quot;</span>);</span><br><span class="line">        rootDir.add(binDir);</span><br><span class="line">        rootDir.add(tmpDir);</span><br><span class="line">        rootDir.add(usrDir);</span><br><span class="line">        binDir.add(<span class="keyword">new</span> File(<span class="string">&quot;vi&quot;</span>, <span class="number">10000</span>));</span><br><span class="line">        binDir.add(<span class="keyword">new</span> File(<span class="string">&quot;latex&quot;</span>, <span class="number">20000</span>));</span><br><span class="line">        rootDir.printList();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Making user entries...&quot;</span>);</span><br><span class="line">        Directory yuki = <span class="keyword">new</span> Directory(<span class="string">&quot;yuki&quot;</span>);</span><br><span class="line">        Directory hanako = <span class="keyword">new</span> Directory(<span class="string">&quot;hanako&quot;</span>);</span><br><span class="line">        Directory tomura = <span class="keyword">new</span> Directory(<span class="string">&quot;tomura&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        usrDir.add(yuki);</span><br><span class="line">        usrDir.add(hanako);</span><br><span class="line">        usrDir.add(tomura);</span><br><span class="line">        yuki.add(<span class="keyword">new</span> File(<span class="string">&quot;diary.html&quot;</span>, <span class="number">100</span>));</span><br><span class="line">        yuki.add(<span class="keyword">new</span> File(<span class="string">&quot;Composite.java&quot;</span>, <span class="number">300</span>));</span><br><span class="line">        hanako.add(<span class="keyword">new</span> File(<span class="string">&quot;memo.text&quot;</span>, <span class="number">400</span>));</span><br><span class="line">        tomura.add(<span class="keyword">new</span> File(<span class="string">&quot;game.doc&quot;</span>, <span class="number">500</span>));</span><br><span class="line">        tomura.add(<span class="keyword">new</span> File(<span class="string">&quot;junk.maik&quot;</span>, <span class="number">600</span>));</span><br><span class="line">        rootDir.printList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四、组合模式有什么优缺点？"><a href="#四、组合模式有什么优缺点？" class="headerlink" title="四、组合模式有什么优缺点？"></a>四、组合模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>可以统一地对待内容组件和复合组件，使用简单</li>
<li>添加新的组件，不会影响客户端调用，满足“开闭原则”</li>
</ul>
<p>缺点：</p>
<ul>
<li>不容易识别组件对象的类型</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/design_pattern/adapter/</url>
    <content><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="一、什么是适配器模式？"><a href="#一、什么是适配器模式？" class="headerlink" title="一、什么是适配器模式？"></a>一、什么是适配器模式？</h2><p>适配器模式（Adapter Design Pattern）：将一个类的接口转换成希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p>适配者模式的几个特点：</p>
<ul>
<li>已存在旧接口实现</li>
<li>希望使用新接口，但是又不想重新实现，想要复用已有的旧接口实现类</li>
</ul>
<p>适配器模式，就是将旧接口实现适配为新接口。</p>
<span id="more"></span>

<h2 id="二、适配器模式用来做什么？"><a href="#二、适配器模式用来做什么？" class="headerlink" title="二、适配器模式用来做什么？"></a>二、适配器模式用来做什么？</h2><h3 id="2-1-模式原理"><a href="#2-1-模式原理" class="headerlink" title="2.1 模式原理"></a>2.1 模式原理</h3><ul>
<li><p>将现有的业务功能旧接口重新封装，改用新接口调用</p>
</li>
<li><p>统一多个实现类的接口设计，为外部提供统一的接口调用</p>
</li>
<li><p>替换外部依赖的接口，改成自己系统的接口</p>
</li>
<li><p>本质上，就是在不改变旧接口实现的情况下，将旧接口转为为新接口</p>
</li>
<li><p>比如说，系统一开始没有设计接口规范，先实现的业务功能，后来才想起要定接口规范，但同时希望能够保留原有的实现代码</p>
</li>
</ul>
<h3 id="2-2-实际场景"><a href="#2-2-实际场景" class="headerlink" title="2.2 实际场景"></a>2.2 实际场景</h3><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。</p>
<p>其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</p>
<p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。</p>
<p>这时候，Slf4j 就出现了，提供了统一的接口定义，但它是在 JUL、JCL、log4j 等日志框架出现后才设计的。</p>
<p>然而，日志框架也不可能牺牲掉版本兼容性，将原本的接口改造成符合 Slf4j 接口规范。</p>
<p>所以 Slf4j 不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。</p>
<p>最后，在开发时，统一使用 Slf4j 提供的接口来打印日志，具体使用哪种日志框架实现（log4j、logback……），可以动态地指定。</p>
<h2 id="三、适配器模式的结构是怎么样的？"><a href="#三、适配器模式的结构是怎么样的？" class="headerlink" title="三、适配器模式的结构是怎么样的？"></a>三、适配器模式的结构是怎么样的？</h2><p>适配器模式可以分为2种：</p>
<ul>
<li>类适配器：适配以类继承的形式实现</li>
<li>对象适配器：适配以类组合的形式实现</li>
</ul>
<p>这2种实现方式的区别：</p>
<ul>
<li>类适配器采用继承来实现，同时拥有旧接口和新接口的功能</li>
<li>对象适配器采用组合实现，只实现了新接口</li>
<li>类适配器的代码耦合度较高</li>
</ul>
<p><img src="/images/assets/designpattern/adapter.png" alt="适配器结构"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧接口实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类适配器: 基于继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器：基于组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四、怎么实现一个适配器？"><a href="#四、怎么实现一个适配器？" class="headerlink" title="四、怎么实现一个适配器？"></a>四、怎么实现一个适配器？</h2><h3 id="4-1-类适配器"><a href="#4-1-类适配器" class="headerlink" title="4.1 类适配器"></a>4.1 类适配器</h3><ul>
<li>可采用多重继承方式实现</li>
<li>C++ 可定义一个适配器类，来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口</li>
<li>Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类适配器: 基于继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-对象适配器"><a href="#4-2-对象适配器" class="headerlink" title="4.2 对象适配器"></a>4.2 对象适配器</h3><ul>
<li>采用组合的方式</li>
<li>适配类实现新接口，同时将旧接口实现类注入适配类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象适配器：基于组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、适配器有什么优缺点？"><a href="#五、适配器有什么优缺点？" class="headerlink" title="五、适配器有什么优缺点？"></a>五、适配器有什么优缺点？</h2><p>优点：</p>
<ul>
<li>复用了现有的类，不需要修改原有代码</li>
<li>通过适配类来解耦，新接口和原有接口耦合性较低</li>
</ul>
<p>缺点：</p>
<ul>
<li>类结构变得复杂</li>
<li>代码可读性降低</li>
</ul>
<h2 id="六、模式扩展"><a href="#六、模式扩展" class="headerlink" title="六、模式扩展"></a>六、模式扩展</h2><p>适配器模式，可扩展为双向适配器模式。</p>
<p>既可以把适配者（Adaptee）转换为新接口（Target），也可以把新接口（Target）转换为适配者接口（Adaptee）。</p>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/design_pattern/prototype/</url>
    <content><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="一、什么是原型模式？"><a href="#一、什么是原型模式？" class="headerlink" title="一、什么是原型模式？"></a>一、什么是原型模式？</h2><p>原型设计模式（Prototype Design Pattern），是指根据实例原型、实例模型来生成新的实例对象。</p>
<p>也就是用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。</p>
<p>重点在于新实例对象，不是创建出来的，而是基于已有的原型对象复制的。</p>
<span id="more"></span>

<h2 id="二、为什么要用原型模式？"><a href="#二、为什么要用原型模式？" class="headerlink" title="二、为什么要用原型模式？"></a>二、为什么要用原型模式？</h2><ul>
<li>对象之间相同或相似，即只是个别的几个属性不同的时候</li>
<li>有些对象的创建过程较为复杂，而且有时候需要频繁创建，创建新对象还不如复制已有对象来得快<ul>
<li>对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值）</li>
<li>对象中的数据需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取</li>
</ul>
</li>
<li>想要复制当前的对象，但是对象内部的数据异常复杂，通过构造函数创建难以实现<ul>
<li>比如一个图形，之前做了很多处理，比一开始创建的时候变动了很多，此时想要复制它，通过构造函数新建是难以实现的</li>
</ul>
</li>
<li>想要让生成的实例的框架不依赖于具体的类<ul>
<li>框架中不能指定类名来生成实例，所以会先“注册”一个“原型实例”，然后通过复制该“原型”来生成新实例</li>
</ul>
</li>
</ul>
<h2 id="三、模型的结构是怎么样的？"><a href="#三、模型的结构是怎么样的？" class="headerlink" title="三、模型的结构是怎么样的？"></a>三、模型的结构是怎么样的？</h2><p>原型模式主要包含以下几种角色：</p>
<ol>
<li>抽象原型类(Prototype)：负责定义用于复制现有实例来生成新实例的方法</li>
<li>具体原型类(ConcretePrototype)：负责实现复制现有实例并生成新实例的方法</li>
<li>访问类(Client)：负责使用复制实例的方法生成新的实例</li>
</ol>
<p><img src="/images/assets/designpattern/propotype.png" alt="原型结构"></p>
<h2 id="四、怎么实现原型模式？"><a href="#四、怎么实现原型模式？" class="headerlink" title="四、怎么实现原型模式？"></a>四、怎么实现原型模式？</h2><p>原型模式有两种实现方法：深拷贝和浅拷贝。</p>
<ul>
<li>浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……</li>
<li>深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间</li>
</ul>
<p>深拷贝和浅拷贝的一些注意事项：</p>
<ul>
<li>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的</li>
<li>但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了</li>
<li>没有充分的理由，不要为了一点点的性能提升而使用浅拷贝</li>
</ul>
<p>示例程序的类结构图：</p>
<p><img src="/images/assets/designpattern/product_propotype.png" alt="示例程序类结构图"></p>
<p>其中 Product 代表的是原型结构中的 Propotype，UnderlinePen 和 MessageBox 代表的是原型结构中的 ConcretePrototype，而 ProductManager 代表的是原型结构中的 Client。</p>
<h3 id="4-1-Product-接口"><a href="#4-1-Product-接口" class="headerlink" title="4.1 Product 接口"></a>4.1 Product 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品使用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品克隆的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 克隆出来的新对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Product <span class="title">createClone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-UnderlinePen-和-MessageBox-具现类"><a href="#4-2-UnderlinePen-和-MessageBox-具现类" class="headerlink" title="4.2 UnderlinePen 和 MessageBox 具现类"></a>4.2 UnderlinePen 和 MessageBox 具现类</h3><p>UnderlinePen 是为输出字符串在左右两端添加双引号，并在下边添加下划符号。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为输出字符串添加下划线，例如：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;Strong message product&quot;</span></span><br><span class="line"><span class="comment"> * ~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnderlinePen</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下划符号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnderlinePen</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出字符串左右添加双引号，下边添加下划符号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输出字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.getBytes().length;</span><br><span class="line">        System.out.println(<span class="string">&quot;\&quot;&quot;</span> + s + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">2</span>; i++) &#123;</span><br><span class="line">            System.out.print(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p = (Product) clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageBox 是为输出字符串添加一个输出框。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 为输出字符串添加输出框，例如：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ***********************</span></span><br><span class="line"><span class="comment"> * * Warning box product *</span></span><br><span class="line"><span class="comment"> * ***********************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBox</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出框符号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageBox</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为输出字符串添加一个输出框</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输出字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.getBytes().length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">4</span>; i++) &#123;</span><br><span class="line">            System.out.print(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(ch + <span class="string">&quot; &quot;</span> + s + <span class="string">&quot; &quot;</span> + ch);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">4</span>; i++) &#123;</span><br><span class="line">            System.out.print(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p = (Product) clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-ProductManager-访问类"><a href="#4-3-ProductManager-访问类" class="headerlink" title="4.3 ProductManager 访问类"></a>4.3 ProductManager 访问类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存产品原型实例</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Product&gt; products = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册产品原型实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 原型名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> product 原型实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, Product product)</span> </span>&#123;</span><br><span class="line">        products.put(name, product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过原型名称获取产品新实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 产品原型名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 产品新实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Product product = products.get(name);</span><br><span class="line">        <span class="keyword">return</span> product.createClone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="五、原型模式有什么优缺点？"><a href="#五、原型模式有什么优缺点？" class="headerlink" title="五、原型模式有什么优缺点？"></a>五、原型模式有什么优缺点？</h2><p>原型模式的优点：</p>
<ul>
<li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率</li>
<li>原型模式提供了简化的创建结构，可以使用深克隆方式保存对象的状态，以便在需要的时候使用（例如恢复到历史某一状态）</li>
</ul>
<p>原型模式的缺点：</p>
<ul>
<li>需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，必须修改其源代码，违背了“开闭原则”</li>
<li>当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦</li>
<li>深克隆、浅克隆需要运用得当</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li>Java 中提供了用于复制实例的方法 <code>clone()</code></li>
<li><code>clone()</code> 方法定义在 <code>java.lang.Object</code> 中，也就是说，所有 Java 类都有 <code>clone()</code> 方法</li>
<li><code>clone()</code> 方法内部所执行的是基于内存二进制流的复制，复制了一份和原型对象一样的内存数据</li>
<li><code>clone()</code> 方法复制的只是对象的内存数据，所以 <code>clone()</code> 方法是浅复制</li>
<li><code>clone()</code> 方法只会进行复制，不会调用实例的构造函数</li>
<li>重写 <code>clone()</code> 方法时，记得调用父类的 <code>super.clone()</code> 方法</li>
</ul>
<ul>
<li>类使用 <code>clone()</code> 方法，这个类必须实现 <code>java.lang.Clonable</code> 接口（自己实现或者父类实现都行）</li>
<li><code>Clonable</code> 是一个标记接口，用于标记该类可以执行 <code>clone()</code> 方法，自身没有声明任何方法</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/design_pattern/builder/</url>
    <content><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="一、什么是建造者模式？"><a href="#一、什么是建造者模式？" class="headerlink" title="一、什么是建造者模式？"></a>一、什么是建造者模式？</h2><p>建造者设计模式（Builder Design Pattern），是指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。</p>
<ul>
<li>使用建造者模式的目的，就是为了解决复杂对象的构建</li>
</ul>
<p>它将一个复杂的对象分解为多个简单的对象，然后一步一步构建起来。</p>
<span id="more"></span>

<h2 id="二、为什么要用建造者模式？"><a href="#二、为什么要用建造者模式？" class="headerlink" title="二、为什么要用建造者模式？"></a>二、为什么要用建造者模式？</h2><ul>
<li>初始化对象时，过程比较复杂，参数很多，而且还需要校验参数的有效性</li>
<li>初始化对象时，参数之间有一定的依赖关系或约束条件，必须对参数的关系进行校验</li>
<li>创建不可变对象，就不能用构造函数 + <code>set</code> 方法来对属性设值</li>
<li>为了保证对象初始化赋值过程中的有效性</li>
</ul>
<h2 id="三、模型的结构是怎么样的？"><a href="#三、模型的结构是怎么样的？" class="headerlink" title="三、模型的结构是怎么样的？"></a>三、模型的结构是怎么样的？</h2><p>建造者模型的主要角色如下：</p>
<ol>
<li>抽象建造者（Builder）：负责定义用于生成实例的接口</li>
<li>具体建造者（Concrete Builder）：负责实现 Builder 角色的实现类</li>
<li>指挥者（Director）：负责使用 Builder 角色的接口来生成实例</li>
</ol>
<p><img src="/images/assets/designpattern/builder.png" alt="原型结构"></p>
<h2 id="四、如何实现建造者模式？"><a href="#四、如何实现建造者模式？" class="headerlink" title="四、如何实现建造者模式？"></a>四、如何实现建造者模式？</h2><p>示例程序的类结构图：</p>
<p><img src="/images/assets/designpattern/builder-demo.png" alt="示例程序类结构图"></p>
<p>其中 <code>TextBuilder</code> 和 <code>HtmlBuilder</code> 代表的是建造者结构中的 ConcreteBuilder。</p>
<p>建造者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> title 标题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeTitle</span><span class="params">(String title)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String string)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写条目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> items 条目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeItems</span><span class="params">(String[] items)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指挥者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.makeTitle(<span class="string">&quot;Greeting&quot;</span>);</span><br><span class="line">        builder.makeString(<span class="string">&quot;从早上至下午&quot;</span>);</span><br><span class="line">        builder.makeItems(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">                <span class="string">&quot;早上好&quot;</span>,</span><br><span class="line">                <span class="string">&quot;下午好&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        builder.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文本建造者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;=====================================\n&quot;</span>);</span><br><span class="line">        buffer.append(<span class="string">&quot;[&quot;</span> + title + <span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        buffer.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;#&quot;</span> + string);</span><br><span class="line">        buffer.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeItems</span><span class="params">(String[] items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            buffer.append(<span class="string">&quot; .&quot;</span> + items[i] + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;=====================================\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTML建造者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        filename = title + <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(filename));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="string">&quot;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;h1&gt;&quot;</span> + title + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;p&gt;&quot;</span> + string + <span class="string">&quot;&lt;/p&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeItems</span><span class="params">(String[] items)</span> </span>&#123;</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;ul&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            writer.println(<span class="string">&quot;&lt;li&gt;&quot;</span> + items[i] + <span class="string">&quot;&lt;/li&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;/ul&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filename;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="五、建造者模式有什么优缺点？"><a href="#五、建造者模式有什么优缺点？" class="headerlink" title="五、建造者模式有什么优缺点？"></a>五、建造者模式有什么优缺点？</h2><p>优点：</p>
<ul>
<li>封装性好，构建与表示分离，构建由建造者完成</li>
<li>扩展性好，各个具体的建造者相互独立，有利于系统解耦</li>
<li>建造者可对内部的构建过程进行细化，而不影响外部模块</li>
</ul>
<p>缺点：</p>
<ul>
<li>建造者必须和被构建目标相同，限制了使用范围，只能用于指定的类型</li>
<li>建造者必须和被构建目标保持一致，目标发生变更时，需要同时修改建造者</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/design_pattern/abstract_factory/</url>
    <content><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="一、什么是抽象工厂模式"><a href="#一、什么是抽象工厂模式" class="headerlink" title="一、什么是抽象工厂模式"></a>一、什么是抽象工厂模式</h2><p>抽象工厂（AbstractFactory）是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产“一个等级”的产品，而抽象工厂模式可生产“多个等级”的产品。</p>
<span id="more"></span>

<h2 id="二、为什么要用抽象工厂模式？"><a href="#二、为什么要用抽象工厂模式？" class="headerlink" title="二、为什么要用抽象工厂模式？"></a>二、为什么要用抽象工厂模式？</h2><p>使用抽象工厂模式一般要满足以下条件：</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用</li>
</ul>
<h2 id="三、抽象工厂结构是怎么样的？"><a href="#三、抽象工厂结构是怎么样的？" class="headerlink" title="三、抽象工厂结构是怎么样的？"></a>三、抽象工厂结构是怎么样的？</h2><h3 id="3-1-产品等级结构和产品族"><a href="#3-1-产品等级结构和产品族" class="headerlink" title="3.1 产品等级结构和产品族"></a>3.1 产品等级结构和产品族</h3><p><strong>（1）产品等级结构</strong></p>
<p>即产品的继承结构。</p>
<p>如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p>
<p><strong>（2）产品族</strong></p>
<p>在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。</p>
<p>比如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</p>
<h3 id="3-2-模型结构"><a href="#3-2-模型结构" class="headerlink" title="3.2 模型结构"></a>3.2 模型结构</h3><p>抽象工厂方法模式的主要角色如下：</p>
<ol>
<li>抽象工厂（AbstractFactory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p><img src="/images/assets/designpattern/abstractfactory.png" alt="抽象工厂方法模型结构"></p>
<p>示例程序的类结构图：</p>
<p><img src="/images/assets/designpattern/company_abstractfactory.png" alt="示例程序类结构图"></p>
<p>其中 AbstractCompany，AbstractMobilePhone 是抽象工厂方法模式中的 Product，HuaweiComputer, HuaweiMobilePhone, XiaomiComputer, XiaomiMobilePhone 是抽象工厂方法模式中的 ConcreteProduct，AbsractCompany 是抽象工厂方法模式中的 AbstractFactory<br>HuaweiCompany 和 XiaomiCompany 是抽象工厂方法模式中的 ConcreteFactory。</p>
<h3 id="3-1-AbsractCompany-抽象工厂类"><a href="#3-1-AbsractCompany-抽象工厂类" class="headerlink" title="3.1 AbsractCompany 抽象工厂类"></a>3.1 AbsractCompany 抽象工厂类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCompany</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产电脑产品</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 电脑产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractComputer <span class="title">createComputer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产手机产品</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 手机产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractMobilePhone <span class="title">createMobilePhone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-HuaweiCompany-和-XiaomiCompany-具体工厂类"><a href="#3-2-HuaweiCompany-和-XiaomiCompany-具体工厂类" class="headerlink" title="3.2 HuaweiCompany 和 XiaomiCompany 具体工厂类"></a>3.2 HuaweiCompany 和 XiaomiCompany 具体工厂类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiCompany</span> <span class="keyword">extends</span> <span class="title">AbstractCompany</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HuaweiComputer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiComputer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HuaweiMobilePhone <span class="title">createMobilePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiMobilePhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiCompany</span> <span class="keyword">extends</span> <span class="title">AbstractCompany</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XiaomiComputer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiComputer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XiaomiMobilePhone <span class="title">createMobilePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiMobilePhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-AbstractCompany-和-AbstractMobilePhone-抽象产品类"><a href="#3-3-AbstractCompany-和-AbstractMobilePhone-抽象产品类" class="headerlink" title="3.3 AbstractCompany 和 AbstractMobilePhone 抽象产品类"></a>3.3 AbstractCompany 和 AbstractMobilePhone 抽象产品类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Double price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMobilePhone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Double price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-具体产品类"><a href="#3-4-具体产品类" class="headerlink" title="3.4 具体产品类"></a>3.4 具体产品类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiComputer</span> <span class="keyword">extends</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiComputer</span> <span class="keyword">extends</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiMobilePhone</span> <span class="keyword">extends</span> <span class="title">AbstractMobilePhone</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiMobilePhone</span> <span class="keyword">extends</span> <span class="title">AbstractMobilePhone</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四、抽象工厂模式有什么优缺点？"><a href="#四、抽象工厂模式有什么优缺点？" class="headerlink" title="四、抽象工厂模式有什么优缺点？"></a>四、抽象工厂模式有什么优缺点？</h2><p>抽象工厂模式的优点：</p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理</li>
<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则</li>
</ul>
<p>抽象工厂模式的缺点：</p>
<ul>
<li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/design_pattern/factory_method/</url>
    <content><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="一、什么是工厂方法模式？"><a href="#一、什么是工厂方法模式？" class="headerlink" title="一、什么是工厂方法模式？"></a>一、什么是工厂方法模式？</h2><p>又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。</p>
<p>即将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，由子类来决定应该实例化（创建）哪一个类。</p>
<p>被创建的对象称为“产品”，把创建产品的对象称为“工厂”。</p>
<span id="more"></span>

<h2 id="二、为什么要用工厂方法模式？"><a href="#二、为什么要用工厂方法模式？" class="headerlink" title="二、为什么要用工厂方法模式？"></a>二、为什么要用工厂方法模式？</h2><p>工厂方法模式通常用于以下场景：</p>
<ul>
<li>对于某个产品，调用者清楚地知道应该使用哪个具体工厂服务，实例化该具体工厂，生产出具体的产品</li>
<li>只是需要一种产品，而不想知道也不需要知道究竟是哪个工厂为生产的，即最终选用哪个具体工厂的决定权在生产者一方，它们根据当前系统的情况来实例化一个具体的工厂返回给使用者，而这个决策过程这对于使用者来说是透明的</li>
</ul>
<h2 id="三、工厂方法结构是怎么样的？"><a href="#三、工厂方法结构是怎么样的？" class="headerlink" title="三、工厂方法结构是怎么样的？"></a>三、工厂方法结构是怎么样的？</h2><p>工厂方法模式的主要角色如下：</p>
<ol>
<li>抽象工厂（AbstractFactory）：提供了创建产品的接口，通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p><img src="/images/assets/designpattern/factorymethod.png" alt="工厂方法模型结构"></p>
<p>示例程序的类结构图：</p>
<p><img src="/images/assets/designpattern/shape_factorymethod.png" alt="示例程序类结构图"></p>
<p>其中 <code>Shape</code> 是工厂方法模式中的 Product，<code>Circle</code> 和 <code>Square</code> 是工厂方法模式中的 ConcreteProduct，<code>ShapeFactory</code> 是工厂方法模式中的 Factory<br>，<code>CircleFactory</code> 和 <code>SquareFactory</code> 是工厂方法模式中的 ConcreteFactory。</p>
<h3 id="3-1-Shape-抽象产品类"><a href="#3-1-Shape-抽象产品类" class="headerlink" title="3.1 Shape 抽象产品类"></a>3.1 Shape 抽象产品类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-Circle-和-Square-具体产品类"><a href="#3-2-Circle-和-Square-具体产品类" class="headerlink" title="3.2 Circle 和 Square 具体产品类"></a>3.2 Circle 和 Square 具体产品类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a circle shape!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a square shape!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-ShapeFactory-抽象工厂方法接口"><a href="#3-3-ShapeFactory-抽象工厂方法接口" class="headerlink" title="3.3 ShapeFactory 抽象工厂方法接口"></a>3.3 ShapeFactory 抽象工厂方法接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品工厂方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Shape <span class="title">createShape</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-CirCleFactory-和-SquareFactory-具体产品工厂类"><a href="#3-4-CirCleFactory-和-SquareFactory-具体产品工厂类" class="headerlink" title="3.4 CirCleFactory 和 SquareFactory 具体产品工厂类"></a>3.4 CirCleFactory 和 SquareFactory 具体产品工厂类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleFactory</span> <span class="keyword">implements</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Circle <span class="title">createShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareFactory</span> <span class="keyword">implements</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Square <span class="title">createShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、工厂方法模式有什么优缺点？"><a href="#四、工厂方法模式有什么优缺点？" class="headerlink" title="四、工厂方法模式有什么优缺点？"></a>四、工厂方法模式有什么优缺点？</h2><p>工厂方法模式的优点：</p>
<ul>
<li>只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则</li>
</ul>
<p>工厂方法的缺点：</p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/design_pattern/singleton/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="一、什么是单例模式？"><a href="#一、什么是单例模式？" class="headerlink" title="一、什么是单例模式？"></a>一、什么是单例模式？</h2><p>单例设计模式（Singleton Design Pattern）：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p>
<p>这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<p>单例模式有 3 个特点：</p>
<ol>
<li>单例类只有一个实例对象</li>
<li>该单例对象必须由单例类自行创建</li>
<li>单例类对外提供一个访问该单例的全局访问点</li>
</ol>
<span id="more"></span>

<h2 id="二、为什么要使用单例？"><a href="#二、为什么要使用单例？" class="headerlink" title="二、为什么要使用单例？"></a>二、为什么要使用单例？</h2><p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。</p>
<ul>
<li>表示全局唯一类，比如系统配置类</li>
<li>处理资源访问冲突，比如打印日志类</li>
</ul>
<h2 id="三、如何实现一个单例？"><a href="#三、如何实现一个单例？" class="headerlink" title="三、如何实现一个单例？"></a>三、如何实现一个单例？</h2><p>单例需要考虑以下几点：</p>
<ul>
<li>单例的构造函数必须是 <code>private</code> 访问权限的，避免外部创建对象</li>
<li>考虑线程并发创建单例对象的情况，多线程同时创建单例对象时，是否能够保证只有一个单例生成</li>
<li>考虑是否要延迟加载的情况，比如单例对象是否要等到第一次获取的时候才生成，还是一开始就存在</li>
<li>考虑获取单例对象的性能问题，比如对方法加锁会导致性能变差</li>
</ul>
<p>单例创建的几种方式：</p>
<h3 id="3-1-饿汉式"><a href="#3-1-饿汉式" class="headerlink" title="3.1 饿汉式"></a>3.1 饿汉式</h3><ul>
<li>在类加载期间，就已经把单例对象初始化好了</li>
<li>不存在线程安全问题</li>
<li>缺点是不支持延迟加载，没有用到该单例就已经初始化好对象了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载的时候初始化，因此不需要同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接获取单例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-懒汉式"><a href="#3-2-懒汉式" class="headerlink" title="3.2 懒汉式"></a>3.2 懒汉式</h3><ul>
<li>用到时才初始化单例对象</li>
<li>获取单例对象的方法加有锁 <code>synchronized</code>，获取单例时需要加锁、解锁，性能低并且并发度也低</li>
<li>优点是支持延迟加载</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证在所有线程中保持同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步获取单例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要在判断之前同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-3-双重检测"><a href="#3-3-双重检测" class="headerlink" title="3.3 双重检测"></a>3.3 双重检测</h3><ul>
<li>用到时才初始化单例对象</li>
<li>加锁 <code>synchronized</code> 创建单例，同时单例对象还需要加上关键字 <code>volatile</code>，避免指令重排和同步内存对象</li>
<li>优点是支持延迟加载，除了第一次需要加锁以外，其他情况下都不需要加锁，所以性能也比价高，并发度也高</li>
<li>缺点是，<code>volatile</code> 修饰的变量是到主存读取数据，不走缓存，这个稍微消耗点性能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重校验锁单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证在所有线程中保持同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckLockSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLockSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查两次，一次不加锁，一次加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLockSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查，不加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLockSingleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查，加锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckLockSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-4-静态内部类"><a href="#3-4-静态内部类" class="headerlink" title="3.4 静态内部类"></a>3.4 静态内部类</h3><ul>
<li>用到时才加载单例对象</li>
<li>是在静态内部类加载时初始化好单例对象的</li>
<li>不存在线程安全问题</li>
<li>优点是支持延迟加载，不需要加锁，性能高，并发度高。总体上比双重检测上要好</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类级的内部类，也就是静态的成员式内部类，</span></span><br><span class="line"><span class="comment">     * 该内部类的实例与外部类的实例没有绑定关系，</span></span><br><span class="line"><span class="comment">     * 而且只有被调用到才会装载，从而实现了延迟加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerSingleton instance = <span class="keyword">new</span> StaticInnerSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接获取单例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-5-枚举类"><a href="#3-5-枚举类" class="headerlink" title="3.5 枚举类"></a>3.5 枚举类</h3><ul>
<li>类加载时就初始化好单例了</li>
<li>不支持延迟加载</li>
<li>优点是创建单例对象简单，只需定义枚举对象即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举模式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四、单例存在哪些问题？"><a href="#四、单例存在哪些问题？" class="headerlink" title="四、单例存在哪些问题？"></a>四、单例存在哪些问题？</h2><h3 id="4-1-单例对-OOP-特性的支持不友好"><a href="#4-1-单例对-OOP-特性的支持不友好" class="headerlink" title="4.1 单例对 OOP 特性的支持不友好"></a>4.1 单例对 OOP 特性的支持不友好</h3><ul>
<li>单例对于抽象、继承、多态这几个特性的支持不太好</li>
<li>单例对象的使用，是直接调用的，没有用依赖注入、基于接口调用的形式，因此在抽象方面支持的不是很好</li>
<li>单例类，一般也不会继承，所以继承和多态，基本上是用不到的</li>
</ul>
<h3 id="4-2-单例会隐藏类之间的依赖关系"><a href="#4-2-单例会隐藏类之间的依赖关系" class="headerlink" title="4.2 单例会隐藏类之间的依赖关系"></a>4.2 单例会隐藏类之间的依赖关系</h3><ul>
<li>一般通过构造函数、参数传递等方式声明的类之间的依赖关系，就能明确知道类的依赖关系</li>
<li>单例的调用，不是通过依赖注入、参数传递来调用的</li>
<li>单例对象一般都是在代码中直接调用，想要知道类的依赖关系，还需要看代码实现，不够明显</li>
</ul>
<h3 id="4-3-单例对代码的扩展性不友好"><a href="#4-3-单例对代码的扩展性不友好" class="headerlink" title="4.3 单例对代码的扩展性不友好"></a>4.3 单例对代码的扩展性不友好</h3><ul>
<li>单例类，只有一个单例对象，一般也不会继承</li>
<li>单例类，想要添加功能，只能修改单例类的代码，对于可扩展性来说不太友好</li>
</ul>
<h3 id="4-4-单例对代码的可测试性不友好"><a href="#4-4-单例对代码的可测试性不友好" class="headerlink" title="4.4 单例对代码的可测试性不友好"></a>4.4 单例对代码的可测试性不友好</h3><ul>
<li>单例类这种硬编码式的使用方式（在代码里直接调用），无法实现 mock 替换，可测试性不强</li>
<li>单例对象相当于一个全局对象，在单元测试时，还需要注意各个测试用例之间有没有影响到单例对象的数据，必须测试时受到影响。</li>
</ul>
<h3 id="4-5-单例不支持有参数的构造函数"><a href="#4-5-单例不支持有参数的构造函数" class="headerlink" title="4.5 单例不支持有参数的构造函数"></a>4.5 单例不支持有参数的构造函数</h3><ul>
<li>单例一般是无参的</li>
<li>想要支持参数，就需要考虑每次传不同参数，以及参数什么时候传进去等情况，比较麻烦</li>
<li>最好的办法是，单例初始化时，自己去读取配置文件来初始化，无需外部传参</li>
</ul>
<h2 id="五、单例有何替代解决方案？"><a href="#五、单例有何替代解决方案？" class="headerlink" title="五、单例有何替代解决方案？"></a>五、单例有何替代解决方案？</h2><ul>
<li><p>使用静态方法，缺点是静态方法不够灵活，也不支持延迟加载</p>
</li>
<li><p>可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）</p>
</li>
<li><p>如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/lang/java/source/jdk8/collection/HashMap/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>HashMap 的底层数据存储结构是“数组 + 链表 + 红黑树”，红黑树结构是 JDK8 之后进行的优化。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实际结构大概是这样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0    1    2    3    4    5    6    7 </span><br><span class="line"> ____ ____ ____ ____ ____ ____ ____ ____</span><br><span class="line">|    |    | 42 |    |    | 21 | 14 | 15 |</span><br><span class="line">           /  \                 |    |</span><br><span class="line">         26    58               22   7</span><br><span class="line">        / \    / \              |</span><br><span class="line">       10 34  50 66             6</span><br><span class="line">      / \</span><br><span class="line">     2  18</span><br></pre></td></tr></table></figure>

<p>整个数组长度为8，而2那里放的就是红黑树，6、7那边则放的是链表。</p>
<p>实际上<code>HashMap</code>的数组长度这么短时，是不会有红黑树的，这里只是做个例子展示。</p>
<h3 id="2-2-集合操作"><a href="#2-2-集合操作" class="headerlink" title="2.2 集合操作"></a>2.2 集合操作</h3><p><strong>1）查找元素</strong></p>
<p><code>HashMap</code>底层就是“数组 + 链表 + 红黑树”，所以查找也不是很麻烦，只要遍历数组的每一个链表或树就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 找到指定hash对应的数组位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是否是查找的元素，是则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个节点不是，就遍历后面的元素查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果是红黑树结构，按照树的查找来找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果是链表，就逐个遍历查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找的话，可以分为几步：</p>
<ol>
<li>计算hash对应到table的位置<code>first = table[(n - 1) &amp; hash]</code>，如果<code>first</code>不为null，则进行下一步；</li>
<li>如果<code>first</code>就是所要寻找的元素，那么就直接返回；</li>
<li>如果<code>first</code>是一个树节点（<code>TreeNode</code>），那么就按照树的查找来找目标元素；</li>
<li>如果<code>first</code>是普通节点，就按照链表的顺序，从头到尾寻找目标元素。</li>
</ol>
<p>理论上来说，只要知道了数据的结构，遍历寻找还是比较简单的。</p>
<p><strong>2）删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 查找删除节点和它的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">// 表头或树根节点，即放在数组中的节点</span></span><br><span class="line">            node = p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                <span class="comment">// 红黑树结构</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 链表结构</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 找到指定节点的话就删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                <span class="comment">// 红黑树结构</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == p) &#123;</span><br><span class="line">                <span class="comment">// 链表表头，即放在数组中的节点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 链表中的非表头节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除的处理逻辑也不复杂，就是源码写的花里胡哨：</p>
<ol>
<li>先找到要删除的节点，以及它的父节点，查找过程和上面的类似；</li>
<li>如果是红黑树结构，就按照树结构来删除；</li>
<li>如果是链表结构，直接按照链表结构删除节点，即父节点指向孙子节点。</li>
</ol>
<p><strong>3）添加元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 数组还未初始化，新建数组</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. hash对应的数组位置还未初始化，直接插入新节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. hash对应的数组位置已经初始化，即已存在链表或红黑树</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">// 3.1 表头或树根节点，即放在数组中的节点（用于性能优化）</span></span><br><span class="line">            e = p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">            <span class="comment">// 3.2 红黑树结构</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.3 链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入节点不存在，找到链表尾部插入新节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果达到阈值，需要把链表转化成红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入节点已存在，则不插入新节点，而是更新值就行</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果插入节点已存在，就更新值，而不是插入新节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) &#123;</span><br><span class="line">        <span class="comment">// 超过阈值，扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加的话，可以分为几步：</p>
<ol>
<li>table未初始化时，先初始化table</li>
<li>hash所在的table位置未初始化。计算hash对应到table的位置<code>p = table[(n - 1) &amp; hash]</code>，如果<code>p</code>为null，则直接插入新节点到数组上</li>
<li>添加节点已存在时。如果<code>p</code>在table中已存在，不会新建节点，而是直接更新值</li>
<li>添加节点不存在时，分2种情况：</li>
</ol>
<ul>
<li>插入结构是红黑树，如果<code>p</code>是一个树节点（<code>TreeNode</code>），也就是红黑树结构，那么就按照树结构来添加节点</li>
<li>插入结构是链表，如果<code>p</code>是普通节点，也就是链表结构，把新节点添加到链表末尾。另外如果此时超过了阈值，链表会转化为红黑树</li>
</ul>
<p>需要说明的一点就是，如果添加的元素在<code>HashMap</code>中已存在，那么就会更新对应节点的值，而不是插入新节点。</p>
<p>总的来说，集合的几个操作并不算复杂，复杂的是这些操作引起的扩容问题以及同hash值节点的数据结构变更（链表变树，树变链表）。</p>
<h3 id="2-3-扩容机制"><a href="#2-3-扩容机制" class="headerlink" title="2.3 扩容机制"></a>2.3 扩容机制</h3><p><strong>1）初始容量</strong></p>
<p><code>HashMap</code>的初始容量是指数组的长度，它要求数组的长度始终是“2的倍数”，和<code>ArrayDueue</code>的要求一样。 </p>
<p>所以当传入的参数不符合要求时，就会对它进行修正：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，如果传入的初始化容量不是“2的倍数”，会自动被修正为“2的倍数”。</p>
<p>比如，<code>new HashMap(3)</code>实际上底层的数组长度的初始长度会是 4，<code>new HashMap(14)</code>实际上底层的数组长度的初始长度会是 16。</p>
<p>至于为什么要取“2的倍数”，应该和<code>ArrayDueue</code>的一样，其实就是计算从hash值映射到数组时可以更高效：</p>
<ol>
<li>计算机对于2倍数计算是很快的，直接通过移位操作（<code>n &lt;&lt; 1</code>）就可以实现；</li>
<li>计算hash对应的数组位置时，一般需要取模，但如果容量是2的倍数，那么取模就可以用掩码（<code>table[i = (n - 1) &amp; hash])</code>）来实现，会更高效一些。</li>
</ol>
<p><strong>2）负载因子</strong></p>
<p>对于扩容，有一个问题，就是什么时候才需要重新调整数组容量？</p>
<p>因为理论上来说，“数组 + 链表 + 红黑树”是可以放置无数个节点的，是不是一直都不需要调整呢？</p>
<p>实际上不是，一旦数据多了起来，不论是链表，还是红黑树，它的节点都会变得越来越多，查找也会越来越慢，这个时候就需要减短它的节点数量，来提高性能。</p>
<p>在 <code>HashMap</code> 中，使用了负载因子来表示需要数组扩容的时机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>为了了解负载因子的作用，先解释一下负载的意义。举个例子说明，比如当前结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0    1    2    3    4    5    6    7 </span><br><span class="line"> ____ ____ ____ ____ ____ ____ ____ ____</span><br><span class="line">| 0  | 1  | 42 | 11 |    | 21 | 14 | 15 |</span><br><span class="line">                                |    |</span><br><span class="line">                                22   7</span><br><span class="line">                                |</span><br><span class="line">                                6</span><br></pre></td></tr></table></figure>

<p>此时的元素数量是 10，数组长度是 8，那么实际负载就是 <code>10 / 8 = 1.25</code>。</p>
<p><em><strong>负载因子在一定意义上，代表了当前数据结构的饱满程度</strong></em></p>
<p>假设<code>HashMap</code>的负载因子是0.75，那么对于上面的例子而已，它的负载值 <code>1.25 &gt; 0.75</code>，实际上早就已经需要扩容了。</p>
<p>也就是说，在设定好指定的负载因子后，如果不断添加元素，实际负载也会不断增大，直到大于负载因子时，就需要进行扩容。</p>
<p>另外，<code>HashMap</code>为了减少负载的计算，一般都用阈值<code>threshold</code>来提前计算好会超过负载因子的最大元素数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threshold = table.length * loadFactor;</span><br></pre></td></tr></table></figure>

<p>当元素的数量<code>size &gt; threshold</code>时，就是实际负载超过负载因子的时候，这个时候就要进行扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &gt; threshold) &#123;</span><br><span class="line">    <span class="comment">// 超过阈值，扩容</span></span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，阈值<code>threshold</code>并不是一个必要的变量，只是为了提高性能，减少负载的计算（除法计算），而添加的。</p>
<p><strong>3）扩容容量</strong></p>
<p><code>HashMap</code> 为了保持“2的倍数”容量，每次扩容都是之前的2倍。也就是 “新容量 = 旧容量 * 2”。</p>
<p>直接看一下扩容代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组不是第一次初始化时，对旧容量进行扩容</span></span><br><span class="line">        <span class="comment">// 如果旧容量已经是最大容量了，就不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常情况下，新容量 = 旧容量 * 2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组第一次初始化时，如果初始化容量大于0，就用初始化容量，它也是2的倍数</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数组第一次初始化时，如果初始化容量为0，就用默认的初始化容量DEFAULT_INITIAL_CAPACITY</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略掉后面的代码，在后面的4）中贴有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容容量的计算还算简单，主要可以分为几步：</p>
<ol>
<li>如果不是第一次初始化数组，就对旧容量进行扩容，在没有达到最大容量的情况下，新容量 = 旧容量 * 2</li>
<li>如果是第一次初始化数组，并且初始化容量大于0，那么就用初始化容量作为新容量</li>
<li>如果是第一次初始化数组，并且初始化容量为0，那么就用默认初始化容量作为新容量</li>
</ol>
<p>当然，代码中间还加上了一些溢出边界的判断，但是总体逻辑差不多就是这样。</p>
<p><strong>4）数据迁移</strong></p>
<p>扩容数组之后，还需要把旧数组的数据迁移到新数组中。先看它的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 略掉前面的代码，在前面的3）中贴有</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 只有一个节点的时候</span></span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                <span class="comment">// 红黑树结构</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 链表结构</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="comment">// 把旧的链表拆分成2条新链表，同时保留旧链表的顺序</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 分配到低位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 分配到高位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迁移过程可以分为几个步骤：</p>
<ol>
<li>遍历旧数组的所有元素，重新计算里面每个元素在新数组中的位置，并把它移动到新数组中</li>
<li>因为是扩容了2倍，所以在旧数组中同位置的元素，映射到新数组上面时，会映射到2个位置</li>
<li>如果是红黑树结构，映射到新数组时，也会被拆分成2部分</li>
<li>如果是链表结构，映射到新数组时，也会被拆分成2条链表</li>
</ol>
<p>举个例子说明一下，假设旧的数据结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0    1    2    3    4    5    6    7 </span><br><span class="line"> ____ ____ ____ ____ ____ ____ ____ ____ </span><br><span class="line">|    | 9  |    | 11 |    | 21 | 14 | 15 |</span><br><span class="line">       |                        |    |</span><br><span class="line">       1                        22   7</span><br><span class="line">                                |</span><br><span class="line">                                6</span><br></pre></td></tr></table></figure>

<p>当前的数组大小是 8，那么按照前面的规则，扩容后的新数组长度应该是 16，重新分配后的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0    1    2    3    4    5    6    7 </span><br><span class="line"> ____ ____ ____ ____ ____ ____ ____ ____ </span><br><span class="line">|    | 9  |    | 11 |    | 21 | 14 | 15 |</span><br><span class="line">       |                        |    |</span><br><span class="line">       1                        22   7</span><br><span class="line">                                |</span><br><span class="line">                                6</span><br><span class="line"></span><br><span class="line">                    |</span><br><span class="line">                    v</span><br><span class="line"></span><br><span class="line">  0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15 </span><br><span class="line"> ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____</span><br><span class="line">|    | 1  |    |    |    | 21 | 22 | 7  |    |  9 |    | 11 |    |    | 14 | 15 |</span><br><span class="line">                                                                        |</span><br><span class="line">                                                                        6</span><br></pre></td></tr></table></figure>

<p>其实重新hash的计算也很简单，因为是2倍扩容，实际上重新分配时，一部分节点还是在原来的位置，而另一部分会被分出去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 原来的索引位置 i</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 扩容后的索引位置 i + oldCap.length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，<code>HashMap</code> 重新分配后的链表顺序还是和之前一样的。</p>
<p>这一点 <code>HashMap</code> 和 <code>HashTable</code> 不一样，<code>HashTable</code> 扩容后链表结构会反过来。</p>
<p>这是链表的重分配，实际上红黑树的重分配也是一样的，只不过调整树结构稍微麻烦一些，毕竟是有顺序的红黑树。</p>
<h3 id="2-4-树转化"><a href="#2-4-树转化" class="headerlink" title="2.4 树转化"></a>2.4 树转化</h3><p>除了加上“红黑树”结构以外，<code>HashMap</code> 和 <code>HashTable</code> 的结构都差不多，一般情况下都是“数组 + 链表”。</p>
<p>而 <code>HashMap</code> 为了提高效率，增加了“红黑树”的功能，当然也给代码加了很多复杂操作~~</p>
<p>什么时候需要红黑树呢？这里先说明一下相关的几个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转化树的数组长度阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转树的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树转链表的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>这里有3个变量和链表与树转化有关。</p>
<p>其中 <code>MIN_TREEIFY_CAPACITY</code> 和 <code>TREEIFY_THRESHOLD</code> 是链表转红黑树用到的，<code>UNTREEIFY_THRESHOLD</code> 是红黑树转回链表时用到的。</p>
<h4 id="2-4-1-链表转到红黑树"><a href="#2-4-1-链表转到红黑树" class="headerlink" title="2.4.1 链表转到红黑树"></a>2.4.1 链表转到红黑树</h4><p>HashMap 不是随便就把链表转到红黑树的，而是需要满足某些条件：</p>
<ul>
<li>数组长度达到阈值 <code>MIN_TREEIFY_CAPACITY</code>，即64</li>
<li>链表长度达到阈值 <code>TREEIFY_THRESHOLD</code>，即8</li>
</ul>
<p>注意，要同时满足这2个条件，才会将链表转成红黑树。</p>
<p><code>MIN_TREEIFY_CAPACITY</code> 是转化树需要的数组长度阈值，这是用来干嘛的？</p>
<p>其实就是当 <code>table</code> 数组太小时，<code>HashMap</code> 宁愿进行扩容，也不愿意把链表转成树。</p>
<p>这个可能是考虑到性能问题，数组比较小时，维护红黑树反而比扩容的性能低。</p>
<p>下面是链表转成红黑树的逻辑判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个部分的源码上面添加元素写有备注了，就不重复写了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略部分代码</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 忽略部分代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">// 忽略部分代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">            <span class="comment">// 忽略部分代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果达到阈值，需要把链表转化成红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 忽略部分代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 忽略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果table很小时，先直接扩容table，而不要把链表转成树</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 先把链表节点转成树节点，但此时还是链表结构，只是节点类型变了</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里才真正把链表转成红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就比如说，当前数组长度是 16，然后其中某个位置的链表很长了，需要转成红黑树。</p>
<p>但此时数组长度还比较小 <code>16 &lt; 64</code>，所以它就不转化成红黑树了，而是直接把数组扩容为 32，然后把长链表拆分，并重新分配到不同位置。</p>
<h4 id="2-4-2-红黑树转回链表"><a href="#2-4-2-红黑树转回链表" class="headerlink" title="2.4.2 红黑树转回链表"></a>2.4.2 红黑树转回链表</h4><p>当红黑树的节点数量变少了，把它转成链表来维护，反而性能会更好。不过，这个转换回来也要满足某些条件才行：</p>
<ol>
<li>删除节点后，如果此时红黑树节点数量已经很少了，红黑树将会转回链表</li>
<li>进行扩容时，此时红黑树会拆分成2棵子树，如果拆分后的2棵子树的节点数量低于某个阈值，即 <code>UNTREEIFY_THRESHOLD</code>，红黑树将会转会链表</li>
</ol>
<p>注意，满足其中1个条件，就会将红黑树转成链表。</p>
<p>首先是“红黑树的节点数量很少”的情况。</p>
<p>这种情况只会出现在删除节点的时候，具体看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略部分代码</span></span><br><span class="line">    <span class="comment">// 移除节点...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当红黑树的节点数量很少时，将会转回链表</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 忽略后面很多代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点数量很少，究竟多少算少呢？按照代码的判断，它有几种情况：</p>
<ol>
<li>红黑树节点完全没有了</li>
<li>红黑树右子树没有了</li>
<li>红黑树左子树没有了</li>
<li>红黑树的左子树的左子树没有了</li>
</ol>
<p>这几种情况下，就认定为红黑树的节点数量很少了。</p>
<p>这是为什么？红黑树本质上是一棵平衡树，如果某棵子树没了，另一边的子树肯定没几个节点，那就意味着整棵树就没几个节点了（至于更深层的原因，可以去深入了解红黑树的结构）。</p>
<p>其次是“进行扩容时，如果红黑树节点数量低于 <code>UNTREEIFY_THRESHOLD</code>”。</p>
<p>这种情况只会出现在增加节点导致扩容的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略部分代码</span></span><br><span class="line">    <span class="comment">// 重新分配节点，分成2部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">// 如果红黑树的节点数量低于UNTREEIFY_THRESHOLD，就会将其转回链表</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">// 如果红黑树的节点数量低于UNTREEIFY_THRESHOLD，就会将其转回链表</span></span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，扩容后，会将之前的节点拆分成2部分，如果某部分的节点数量不大于阈值 <code>UNTREEIFY_THRESHOLD</code>，就会将红黑树转回链表。</p>
<h4 id="2-4-3-测试代码"><a href="#2-4-3-测试代码" class="headerlink" title="2.4.3 测试代码"></a>2.4.3 测试代码</h4><p>针对链表红黑树相互转换的几种情况，写个测试代码来测试一下。</p>
<p>测试的情况分为3种：</p>
<ol>
<li>添加节点时，链表转红黑树</li>
<li>删除节点时，红黑树节点很少，转回链表</li>
<li>扩容时，红黑树节点少于阈值，转回链表</li>
</ol>
<p>测试思路是这样的：</p>
<ol>
<li><p>明确链表转红黑树时，<code>table</code> 必须要达到阈值 <code>MIN_TREEIFY_CAPACITY</code>，即64。所以一开始就设定容量为64，这样是为了避免中间出现扩容的情况，一旦出现扩容情况就复杂了。</p>
</li>
<li><p>为了测试链表和红黑树的转换时机，需要一直在同一个位置进行增删数据，同时打印 HashMap 的结构。</p>
</li>
<li><p>第3种情况是必须要扩容的，所以为了在同一个位置添加可以快速扩容，把负载因子改小了。但是这个负载因子也不是随便写的，因为必须要使得扩容后红黑树的节点数量不大于阈值 <code>UNTREEIFY_THRESHOLD</code>，即6。同时为了看到红黑树转回链表和不转回链表的情况，最好就是一个大于6，一个小于6，所以这里取的是13，重新分配后刚好满足这样要求（7和6），然后这个负载因子就是根据 <code>13/64 --&gt; 0.2</code> 来算的。</p>
</li>
</ol>
<p>因为 HashMap 的很多属性外部都访问不到，比如 <code>table</code> 成员，然后测试时又需要用到，所以这里通过反射拿到它里面的 <code>table</code> 属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintHashMap</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;&#123;map size: &quot;</span>).append(size());</span><br><span class="line">        Object[] table = getTable();</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;, table size: &quot;</span>).append(table.length);</span><br><span class="line">        <span class="keyword">if</span> (table.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;, nodes: &#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> hasNotNullNode = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            Object node = table[i];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasNotNullNode) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hasNotNullNode = <span class="keyword">true</span>;</span><br><span class="line">            sb.append(i).append(<span class="string">&quot;: &quot;</span>).append(getNodeTypeStr(node));</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] getTable() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field tableField = HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">            tableField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Object[]) tableField.get(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getNodeTypeStr</span><span class="params">(Object node)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String nodeType = node.getClass().getName();</span><br><span class="line">        sb.append(<span class="string">&quot;&#123;type: &quot;</span>).append(nodeType).append(<span class="string">&quot;, value: &quot;</span>).append(node).append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后下面是具体的测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试添加节点时，链表转红黑树&quot;</span>);</span><br><span class="line">    PrintHashMap map = <span class="keyword">new</span> PrintHashMap(size, <span class="number">1</span>);</span><br><span class="line">    testPut(map, size, index, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试删除节点时，红黑树节点很少，转回链表&quot;</span>);</span><br><span class="line">    testRemove(map, size, index, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试扩容时，红黑树节点少于阈值，转回链表&quot;</span>);</span><br><span class="line">    map = <span class="keyword">new</span> PrintHashMap(size, <span class="number">0.20f</span>);</span><br><span class="line">    testPut(map, size, index, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPut</span><span class="params">(PrintHashMap map, <span class="keyword">int</span> size, <span class="keyword">int</span> index, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        map.put(index, index);</span><br><span class="line">        System.out.println(i + <span class="string">&quot; -&gt; put &quot;</span> + index);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        index += size;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRemove</span><span class="params">(PrintHashMap map, <span class="keyword">int</span> size, <span class="keyword">int</span> index, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    index = index + n * size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        index -= size;</span><br><span class="line">        map.remove(index);</span><br><span class="line">        System.out.println(i + <span class="string">&quot; -&gt; remove &quot;</span> + index);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后输出结果是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试添加节点时，链表转红黑树</span><br><span class="line">0 -&gt; put 1</span><br><span class="line">&#123;map size: 1, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">1 -&gt; put 65</span><br><span class="line">&#123;map size: 2, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">2 -&gt; put 129</span><br><span class="line">&#123;map size: 3, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">3 -&gt; put 193</span><br><span class="line">&#123;map size: 4, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">4 -&gt; put 257</span><br><span class="line">&#123;map size: 5, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">5 -&gt; put 321</span><br><span class="line">&#123;map size: 6, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">6 -&gt; put 385</span><br><span class="line">&#123;map size: 7, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">7 -&gt; put 449</span><br><span class="line">&#123;map size: 8, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">8 -&gt; put 513</span><br><span class="line">&#123;map size: 9, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">9 -&gt; put 577</span><br><span class="line">&#123;map size: 10, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">测试删除节点时，红黑树节点很少，转回链表</span><br><span class="line">0 -&gt; remove 577</span><br><span class="line">&#123;map size: 9, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">1 -&gt; remove 513</span><br><span class="line">&#123;map size: 8, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">2 -&gt; remove 449</span><br><span class="line">&#123;map size: 7, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">3 -&gt; remove 385</span><br><span class="line">&#123;map size: 6, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">4 -&gt; remove 321</span><br><span class="line">&#123;map size: 5, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">5 -&gt; remove 257</span><br><span class="line">&#123;map size: 4, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 65=65&#125;&#125;&#125;</span><br><span class="line">6 -&gt; remove 193</span><br><span class="line">&#123;map size: 3, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 65=65&#125;&#125;&#125;</span><br><span class="line">7 -&gt; remove 129</span><br><span class="line">&#123;map size: 2, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 65=65&#125;&#125;&#125;</span><br><span class="line">8 -&gt; remove 65</span><br><span class="line">&#123;map size: 1, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">9 -&gt; remove 1</span><br><span class="line">&#123;map size: 0, table size: 64, nodes: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">测试扩容时，红黑树节点少于阈值，转回链表</span><br><span class="line">0 -&gt; put 1</span><br><span class="line">&#123;map size: 1, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">1 -&gt; put 65</span><br><span class="line">&#123;map size: 2, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">2 -&gt; put 129</span><br><span class="line">&#123;map size: 3, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">3 -&gt; put 193</span><br><span class="line">&#123;map size: 4, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">4 -&gt; put 257</span><br><span class="line">&#123;map size: 5, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">5 -&gt; put 321</span><br><span class="line">&#123;map size: 6, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">6 -&gt; put 385</span><br><span class="line">&#123;map size: 7, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">7 -&gt; put 449</span><br><span class="line">&#123;map size: 8, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$Node, value: 1=1&#125;&#125;&#125;</span><br><span class="line">8 -&gt; put 513</span><br><span class="line">&#123;map size: 9, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">9 -&gt; put 577</span><br><span class="line">&#123;map size: 10, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">10 -&gt; put 641</span><br><span class="line">&#123;map size: 11, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">11 -&gt; put 705</span><br><span class="line">&#123;map size: 12, table size: 64, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 193=193&#125;&#125;&#125;</span><br><span class="line">12 -&gt; put 769</span><br><span class="line">&#123;map size: 13, table size: 128, nodes: &#123;1: &#123;type: java.util.HashMap$TreeNode, value: 129=129&#125;, 65: &#123;type: java.util.HashMap$Node, value: 193=193&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果基本和上面的源码分析一致：</p>
<ul>
<li><p>增加节点，直到节点数量大于阈值 <code>TREEIFY_THRESHOLD</code> 时，即8时，链表就会转成红黑树。</p>
</li>
<li><p>删除节点，直到节点数量很少时，这里是3，红黑树就会转回链表。</p>
</li>
<li><p>扩容时，重新分配得节点数量不大于阈值 <code>UNTREEIFY_THRESHOLD</code> 时，即6时，红黑树就会转回链表。</p>
</li>
</ul>
<p>从这里可以看出了，实际上添加第9个元素时，即节点数量 <code>&gt; 8</code> 时，链表才会转为红黑树。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>链表转到红黑树需要满足的条件：</p>
<ul>
<li>添加节点后，数组长度达到阈值 <code>MIN_TREEIFY_CAPACITY</code>，即64</li>
<li>添加节点后，链表长度达到阈值 <code>TREEIFY_THRESHOLD</code>，即8</li>
<li>注意，要同时满足这2个条件，才会将链表转成红黑树</li>
</ul>
<p>红黑树转回链表需要满足的条件：</p>
<ul>
<li>删除节点后，红黑树节点数量很少时，红黑树就会转回链表</li>
<li>扩容时，重新分配得节点数量不大于阈值 <code>UNTREEIFY_THRESHOLD</code> 时，即6时</li>
<li>注意，满足其中1个条件，就会将红黑树转回链表</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据结构</p>
<ul>
<li>数据结构是“数组 + 链表 + 红黑树” </li>
</ul>
<p>扩容机制</p>
<ul>
<li>负载因子负责控制扩容的时机</li>
<li>当满足“大小 &gt; 容量 * 负载因子”时，才触发扩容</li>
<li>每次扩容是2倍，这是为了维持hash的快速定位</li>
<li>扩容时的重新分配位置，倒序插入</li>
</ul>
<p>树转化机制</p>
<ul>
<li>链表转到红黑树<ul>
<li>添加节点后，数组长度达到阈值 <code>MIN_TREEIFY_CAPACITY</code>，即64</li>
<li>添加节点后，链表长度达到阈值 <code>TREEIFY_THRESHOLD</code>，即8，但是实际上是下一次再添加时才会转为红黑树，即长度为9时</li>
<li>注意，要同时满足这2个条件，才会将链表转成红黑树</li>
</ul>
</li>
<li>红黑树转回链表<ul>
<li>删除节点后，红黑树节点数量很少时，红黑树就会转回链表<ol>
<li>红黑树节点完全没有了</li>
<li>红黑树右子树没有了</li>
<li>红黑树左子树没有了</li>
<li>红黑树的左子树的左子树没有了</li>
</ol>
</li>
<li>扩容后，重新分配得节点数量不大于阈值 <code>UNTREEIFY_THRESHOLD</code> 时，即6时</li>
<li>注意，满足其中1个条件，就会将红黑树转回链表</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>关键字native</title>
    <url>/lang/java/core/native/</url>
    <content><![CDATA[<h1 id="native"><a href="#native" class="headerlink" title="native"></a>native</h1><h2 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h2><p>在 JDK 源代码中，有一些方法是被关键字 native 修饰的，就比如 <code>Object</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>那 <code>native</code> 的作用是什么呢？</p>
<span id="more"></span>

<p><code>native</code> 修饰的方法表示这个方法是原生函数，其具体实现由非 Java 语言实现，比如 C 语言，其代码定义不在 Java 类中，而是在外部文件中（一般是动态链接库 .dll 文件）。</p>
<ul>
<li><code>native</code> 修饰的方法称为本地方法，当在 Java 代码中调用该方法时，JVM 会到外部定义中寻找它的实现代码</li>
</ul>
<p>在 Java 平台中，与本地代码进行互操作的 API，称为 Java Native Interface (Java 本地接口)。</p>
<h2 id="2-native-方法实现"><a href="#2-native-方法实现" class="headerlink" title="2. native 方法实现"></a>2. native 方法实现</h2><h3 id="2-1-方法声明"><a href="#2-1-方法声明" class="headerlink" title="2.1 方法声明"></a>2.1 方法声明</h3><p>要实现 native 方法，首先要声明一个 native 方法。</p>
<p>比如下面的这个类 <code>HelloNative</code>，它声明了一个本地方法 <code>sayHello</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloNative</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时，JVM 会寻找本地方法 <code>sayHello</code> 的外部定义实现（一般是 C/C++ 实现），如果 JVM 没有找到并加载进去，执行 <code>sayHello</code>  方法时就会出现和以下类似的错误信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.HelloNative;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloNative helloNative = <span class="keyword">new</span> HelloNative();</span><br><span class="line">        helloNative.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误信息日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsatisfiedLinkError: com.demo.HelloNative.sayHello()V</span><br><span class="line">	at com.demo.HelloNative.sayHello(Native Method)</span><br><span class="line">	at com.Main.main(Main.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>在这里，<code>sayHello</code> 方法并没有外部实现，找不到肯定会报错。</p>
<p>可以自己手写一个外部实现代码，并让 JVM 加载它，然后就可以正常调用 <code>sayHello</code> 了。</p>
<h3 id="2-2-外部定义实现"><a href="#2-2-外部定义实现" class="headerlink" title="2.2 外部定义实现"></a>2.2 外部定义实现</h3><p>Java 对于 JNI 接口方法定义格式有一定的要求，所以不是随便写就行的。</p>
<ul>
<li>按照一般的 C/C++ 的文件格式可能无法正常加载到 JVM 中</li>
<li>JDK 中提供了一个 <code>javah</code> 命令，可以用来生成符合 JNI 样式的标头文件</li>
</ul>
<p>在类 <code>HelloNative</code> 所在包的“根目录”执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 JNI 标头文件</span></span><br><span class="line">javah -d com/demo com.demo.HelloNative</span><br></pre></td></tr></table></figure>

<p>这样会在源文件 <code>HelloNative.java</code> 所在目录生成 JNI 标头文件 <code>com_demo_HelloNative.h</code>。</p>
<ul>
<li><code>javah</code> 命令默认生成的标头文件名是“<code>包名\_类名</code>”</li>
</ul>
<p>生成的 <code>com_demo_HelloNative.h</code> 头文件的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_demo_HelloNative */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_demo_HelloNative</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_demo_HelloNative</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_demo_HelloNative</span></span><br><span class="line"><span class="comment"> * Method:    sayHello</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_demo_HelloNative_sayHello</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从头文件可以看到，<code>javah</code> 命令生成的标头文件是使用 C 语言声明定义的（<code>extern &quot;C&quot;</code>）：</p>
<ul>
<li>JNI 接口方法名称是“<code>Java\_包名\_类名\_方法名</code>”，该方法和 Java 中的 native 方法是一一对应的</li>
</ul>
<p>有了头文件的接口方法声明，就可以开始实现具体的代码了。</p>
<p>创建一个文件 <code>com_demo_HelloNative.c</code>，并引入上面生成的头文件 <code>com_demo_HelloNative.h</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;com_demo_HelloNative.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_demo_HelloNative_sayHello</span><span class="params">(JNIEnv *env, jobject object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello，world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 native 方法后，还不能直接在 Java 中用，接下来还需要：</p>
<ul>
<li>将头文件（.h）和实现文件（.c）结合生成动态链接库文件（DLL），然后才能在 Java<br>中使用</li>
</ul>
<p>不同编译软件的生成命令可能不太一样，比如利用 MinGW GCC 的命令生成：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -m64 是指编译成64位的库</span></span><br><span class="line"><span class="comment"># 需要注意给路径添加双引号，因为路径上有可能存在空格</span></span><br><span class="line">gcc -m64 -Wl,--add-stdcall-alias -I <span class="string">&quot;%JAVA_HOME%\include&quot;</span> -I <span class="string">&quot;%JAVA_HOME%\include\win32&quot;</span> -shared -o HelloNative.dll .\com_demo_HelloNative.c</span><br></pre></td></tr></table></figure>

<p>参数 <code>-I</code> 是用于指定头文件（.h，例如 <code>jni.h</code>）的寻找路径。</p>
<p>编译完成后，就可以生成一个实现了 <code>sayHello</code> 接口的 <code>HelloNative.dll</code> 动态链接库文件了。</p>
<h3 id="2-3-加载外部定义"><a href="#2-3-加载外部定义" class="headerlink" title="2.3 加载外部定义"></a>2.3 加载外部定义</h3><p>生成 dll 后，还要把它加载到 JVM 中后才能使用，所以需要 JVM 能找到 dll 文件：</p>
<ul>
<li>dll 文件需要放到 JVM 能够找到的位置，它才能被正确加载</li>
<li>JVM 默认的加载路径是程序当前目录，或者 <code>System.getProperty(&quot;java.library.path&quot;)</code></li>
</ul>
<p>所以只要把 dll 文件放到这些路径中的其中一个，JVM 就能够正常加载到 dll 文件。</p>
<p>加载好 dll 文件后，就可以调用 native 方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.HelloNative;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// &quot;HelloNative&quot; 是 dll 文件名称</span></span><br><span class="line">        <span class="comment">// 默认查找路径是程序当前目录 </span></span><br><span class="line">        <span class="comment">// 或者 System.getProperty(&quot;java.library.path&quot;)</span></span><br><span class="line">        System.loadLibrary(<span class="string">&quot;HelloNative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloNative helloNative = <span class="keyword">new</span> HelloNative();</span><br><span class="line">        helloNative.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello，world!</span><br></pre></td></tr></table></figure>

<h2 id="3-流程图"><a href="#3-流程图" class="headerlink" title="3. 流程图"></a>3. 流程图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">源文件(.java源文件) --&gt; javac</span><br><span class="line">javac --&gt; 类文件(.class类文件)</span><br><span class="line">类文件(.class类文件) --&gt; JVM</span><br><span class="line">JVM -- 加载 --&gt; 共享库</span><br><span class="line">源文件(.java源文件) -. native方法 .-&gt; javah</span><br><span class="line">javah --&gt; 头文件(.h头文件)</span><br><span class="line">头文件(.h头文件) --&gt; 编译链接</span><br><span class="line">实现文件(.c文件) --&gt; 编译链接</span><br><span class="line">编译链接 --&gt; 共享库</span><br></pre></td></tr></table></figure>

<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ol>
<li>native 方法不是由 java 语言实现的，而是由 C/C++ 语言实现的</li>
<li>native 的外部定义实现一般是编译成 dll 文件后，再被 JVM 加载</li>
<li>native 方法的主要作用是为了跨平台、速度快、隐藏敏感代码</li>
<li>native 方法可以提供 java 访问操作系统底层的需求</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>native</tag>
        <tag>本地方法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序的一些总结</title>
    <url>/algorithm/quicksort/</url>
    <content><![CDATA[<blockquote>
<p>前言：最近又写到了有关快速排序的代码，结果半天写不对。从代码的整体上来说，代码结构是没问题的，就是在边界问题上出现了错误，经过一番思考以及查询资料，终于完美解决了，因此特地小记一下。</p>
</blockquote>
<h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h3><p>快速排序算法，它的基本原理是：</p>
<ol>
<li>通过一趟排序将数据分割成两部分</li>
<li>一份数据小，一份数据大</li>
<li>然后再对这两部分数据分别进行快速排序</li>
</ol>
<span id="more"></span>

<p>以此达到数据的排序，其基本逻辑代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partSort(a, left, right);</span><br><span class="line">        quickSort(a, left, mid - <span class="number">1</span>);</span><br><span class="line">        quickSort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二-排序原理"><a href="#二-排序原理" class="headerlink" title="二. 排序原理"></a>二. 排序原理</h3><p>快速排序最关键的部分就是如何将大小两部分数据分离，也就是上述代码中的 <code>partSort</code> 的实现。</p>
<p>下面我用一个例子来介绍一下 <code>partSort</code> 的基本原理，假设要对数组进行从小到大的排序：</p>
<p>(1) 首先给定需要排序的数组：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-01.png" alt="初始数组"></p>
<p>(2) 选定一个基准值，这里暂时使用最左端的值（也就是5）：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-02.png" alt="选定基准值"></p>
<p>(3) 接着利用两个指针分别从数组左端和右端去遍历数据</p>
<p>从左端出发的指针找到比基准值大（&gt; 5）的值时则停止，从右端出发的指针找到比基准值小（&lt; 5）的值时则停止：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-03.png" alt="开始遍历"></p>
<p>此时两个指针都停在了对应的值的位置，左指针指向7，右指针指向1：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-04.png" alt="遍历完成"></p>
<p>(4) 然后将这两个位置的数据进行交换：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-05.png" alt="指针相遇"></p>
<p>(5) 交换完成之后再执行第3步，直到两个指针相遇（也就是指向同一个位置）时结束交换：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-06.png" alt="继续下一轮"></p>
<p>(6) 最后一步就是将指针相遇点的值与基准点的值进行交换：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-07.png" alt="交换基准点"></p>
<p>至此，按照基准值为标准，<code>partSort</code> 已经将大小两部分数据分离，完成了快速排序的一次排序过程。</p>
<p>而基准值（就是5）也放在了最终排序结果中它应该放置的地方。</p>
<p><strong><font color="red">也就是说，快速排序的每一轮 <code>partSort</code> 排序结果，都会将基准值放在它最终排序序列的正确位置。</font></strong></p>
<hr>
<h3 id="三-基准点以及指针移动顺序"><a href="#三-基准点以及指针移动顺序" class="headerlink" title="三. 基准点以及指针移动顺序"></a>三. 基准点以及指针移动顺序</h3><p>前面已经简单介绍了排序的过程，其中有几个比较关键的地方：</p>
<ul>
<li><font color="red">基准值的选取</font></li>
<li><font color="red">基准点</font></li>
<li><font color="red">指针的先后移动顺序</font></li>
</ul>
<p><strong>基准值的选取</strong></p>
<p>其实基准值的选取没什么好说的，一般都是取最左端或者最右端的值。</p>
<p>当然了，如果有时候对排序要求比较高的话，还可以随机取值或者三元取值（最左端，中点，最右端）等各种取值方法。</p>
<p><strong>基准点</strong></p>
<p>什么是基准点，也就是在进行 <code>partSort</code> 排序前，一般都会将基准值放在数组的最左端或者最右端，这两个位置就是基准点。</p>
<p><strong>指针的先后移动顺序</strong></p>
<p>因为排序时需要两个指针分别在两端往中间移动，移动顺序指的就是谁先移动，谁后移动。</p>
<hr>
<p>很明显，基准值只会影响排序的速度，而不会影响最终的排序结果，因此此处不讨论。</p>
<p>那<font color="red">基准点和指针先后顺序是否会影响排序的正确性呢？</font></p>
<p>下面我就用例子验证一下这个问题。</p>
<p>根据基准点和指针先后顺序，可以分为四种情况：</p>
<ol>
<li>基准点左端，指针移动先右后左</li>
<li>基准点左端，指针移动先左后右</li>
<li>基准点左端，指针移动先右后左</li>
<li>基准点右端，指针移动先左后右</li>
</ol>
<p>在验证这几种情况之前，先给出需要排序的数组，假设要将数组按<strong>从小到大排序，并选取5为基准值</strong>：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-01.png" alt="初始数组"></p>
<h4 id="3-1-例子演示"><a href="#3-1-例子演示" class="headerlink" title="3.1 例子演示"></a>3.1 例子演示</h4><p>(1) <strong><font color="red">基准点左端，指针移动先右后左</font></strong></p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-08.png" alt="开始遍历"></p>
<p>那么按照之前 <code>partSort</code> 的排序，最终两指针相遇的位置如下：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-06.png" alt="指针相遇"></p>
<p>最后交换基准值与指针相遇点的值：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-07.png" alt="交换基准值"></p>
<p>好的，这里得到的结果没问题，后续执行也没有问题，这里就不贴图了。</p>
<p>(2) <strong><font color="red">基准点左端，指针移动先左后右</font></strong></p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-09.png" alt="开始遍历"></p>
<p>那么按照之前 <code>partSort</code> 的排序，最终两指针相遇的位置如下：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-10.png" alt="指针相遇"></p>
<p>最后交换基准值和相遇点的值（注意，这里两指针相遇的位置变化了，<font color="red">之前是3，现在是6</font>）：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-11.png" alt="交换基准值"></p>
<p>到这里就已经可以知道结果了，排序已经出错了。</p>
<p>再对另外两种情况（基准点在最右端时）进行分析的时候，也会发现：</p>
<p>也是有一种情况结果正确，另一种情况却会失败。</p>
<p>测试是一样的，这里我就不再贴图分析了，下面我们来分析一下为什么会出现这种问题。</p>
<h4 id="3-2-分析总结"><a href="#3-2-分析总结" class="headerlink" title="3.2 分析总结"></a>3.2 分析总结</h4><p>要分析出现问题的原因，首先必须要明确以下2点：</p>
<ol>
<li><strong>基准值在经过一轮排序之后，它所在的位置必定是它在最终排序序列的正确位置；</strong></li>
<li><strong>与基准值交换的值（也就是指针相遇的值）必须属于基准点所在的这一边。</strong></li>
</ol>
<p>根据这两条规则，可以知道情况2中出现问题的原因正是指针相遇的位置不正确（也就是指针相遇的值不属于基准点所在这一边），导致与基准值交换之后出现排序错误。</p>
<p>那怎么保证最后指针能指向正确的位置呢？下面先给出结论：</p>
<ol>
<li><strong><font color="red">基准点在最左端时，指针移动先右后左；</font></strong></li>
<li><strong><font color="red">基准点在最右端时，指针移动先左后右。</font></strong></li>
</ol>
<p>下面举例论证。</p>
<p>假设要对一个数组进行<strong>从小到大</strong>的排序，并且<font color="red">选取基准点为最左端</font>。</p>
<p>那如何保证指针相遇值和基准值是属于同一侧，也就是都属于左端呢？</p>
<p><strong>(1) 如果是先移动右指针，再移动左指针</strong></p>
<p>先右移，那肯定会是右指针先停止移动，左指针再停止移动。</p>
<p><font color="red">那么左右指针相遇时指向的值必然是满足右指针停止条件的值，而满足右指针停止的值必然<strong>不大于基准值</strong></font>。</p>
<p>也就是说，此时相遇值是属于左端的，可以和基准值交换。</p>
<p><strong>(2) 如果是先移动左指针，再移动右指针</strong></p>
<p>先右移，那肯定会是左指针先停止移动，右指针再停止移动。</p>
<p><font color="red">那么左右指针相遇时指向的值必然是满足左指针停止条件的值，而满足左指针停止的值必然<strong>大于基准值</strong></font>。</p>
<p>也就是说，此时相遇值是属于右端的，是错误的位置。</p>
<p>同理，当基准点在右端时，先移动左指针，再移动右指针，也能够保证排序的正确性。</p>
<p>因此，只要记住一点，**<font color="red">让基准点对面的的指针先走</font>**，这样就能够得到正确的排序结果。</p>
<hr>
<h3 id="四-基准值的问题"><a href="#四-基准值的问题" class="headerlink" title="四. 基准值的问题"></a>四. 基准值的问题</h3><p>这里讨论的基准值的问题指的是，当排序左右指针移动过程中，<font color="red">如果遇到与基准值相等的值，此时是应该跳过还是停止？</font></p>
<p>为了分析这个问题，首先给出一份 “partSort” 的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从小到大（一般方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partSortLeft</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左端基准值</span></span><br><span class="line">    <span class="keyword">int</span> x = a[left];</span><br><span class="line">    <span class="keyword">int</span> lp = left, rp = right;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先右遍历取小值</span></span><br><span class="line">        <span class="keyword">while</span> (lp &lt; rp &amp;&amp; a[rp] &gt;= x) &#123;</span><br><span class="line">            rp--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再左遍历取大值</span></span><br><span class="line">        <span class="keyword">while</span> (lp &lt; rp &amp;&amp; a[lp] &lt;= x) &#123;</span><br><span class="line">            lp++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lp &lt; rp) &#123;</span><br><span class="line">            a[lp] = a[lp] ^ a[rp];</span><br><span class="line">            a[rp] = a[lp] ^ a[rp];</span><br><span class="line">            a[lp] = a[lp] ^ a[rp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换基准值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; lp) &#123;</span><br><span class="line">        a[lp] = a[lp] ^ a[left];</span><br><span class="line">        a[left] = a[lp] ^ a[left];</span><br><span class="line">        a[lp] = a[lp] ^ a[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，上述代码是按从小到大排序，最左端为基准点，指针是先右后左。根据上面的讨论结果，这样的排序是没有问题的。</p>
<p>但是现在要讨论的不是这个，在上面的代码中，有两条关键语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先右遍历取小值</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt; rp &amp;&amp; a[rp] &gt;= x) &#123;</span><br><span class="line">    rp--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再左遍历取大值</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt; rp &amp;&amp; a[lp] &lt;= x) &#123;</span><br><span class="line">    lp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>a[rp] &gt;= x</code> 和 <code>a[lp] &lt;= x</code> 这两个地方，<font color="red">其中的 “&gt;=” 和 “&lt;=” 能不能换成其他的符号呢？例如换成 “&gt;” 和 “&lt;”？</font></p>
<p>一样地，根据不同的大小符号，可以分为四种情况：</p>
<ul>
<li>a[rp] &gt; x，a[lp] &lt; x</li>
<li>a[rp] &gt;= x，a[lp] &lt; x</li>
<li>a[rp] &gt;= x，a[lp] &lt;= x</li>
<li>a[rp] &gt; x，a[lp] &lt;= x</li>
</ul>
<p>下面用例子来对这几种情况进行说明。</p>
<hr>
<h4 id="4-1-例子演示"><a href="#4-1-例子演示" class="headerlink" title="4.1 例子演示"></a>4.1 例子演示</h4><p>下面分别对这几种情况进行分析，代码依旧参考前面给出的代码。</p>
<p>(1) <strong>a[rp] <font color="red">&gt;</font>  x</strong>，<strong>a[lp] <font color="red">&lt;</font>  x</strong></p>
<p>假如给出一个数组数据如下：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-12.png" alt="初始数组"></p>
<p>如果按照这个条件执行代码，<strong>这里的左右两个指针根本不会发生移动，导致排序陷入死循环</strong>，最终得不到排序结果。</p>
<p>(2) <strong>a[rp] <font color="red">&gt;=</font>  x</strong>，<strong>a[lp] <font color="red">&lt;</font>  x</strong></p>
<p>假如给出一个数组数据如下，并且左右指针已经完成一轮移动了，它们此时的位置如下：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-13.png" alt="初始数组"></p>
<p>接下来就是交换两个指针指向的值，交换后：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-14.png" alt="交换大小值"></p>
<p>由于排序还没完成，紧接着进行下一轮移动，先移动右指针：</p>
<p><img src="/images/assets/algorithm/quicksort/quick-sort-15.png" alt="基准值位置丢失"></p>
<p>到这里，问题已经出来了，<font color="red"><strong>基准值的位置丢失了!!!</strong></font>。</p>
<p>也就是说，后面不管怎么样，最终都无法确定基准值的位置了（也就是所在的数组索引）。</p>
<p>前面说过，**<code>partSort</code> 方法最终需要返回基准值的最终位置**，然后才能正确地分成一大一小的两部分进行递归排序。</p>
<p>但是此时却把基准值的位置给弄丢了，那最后也就无法拿到正确的分割点，排序肯定失败。</p>
<p>至于后面的两种情况，此处我就不分析了，这两种情况是可以得到正确结果的，至于怎么得到，大家可以试一试。</p>
<h4 id="4-2-分析总结"><a href="#4-2-分析总结" class="headerlink" title="4.2 分析总结"></a>4.2 分析总结</h4><p>根据上面讨论中出现的情况，需要注意两点：</p>
<ul>
<li>不能陷入死循环</li>
<li>不能丢失基准值的位置</li>
</ul>
<p>为了避免这两种情况，必须在代码中实现以下两点：</p>
<ol>
<li><strong><font color="red">有一边必须携带 “=”，才能够防止死循环；</font></strong></li>
<li><font color="red"><strong>带 “=” 这一边，必须属于基准点这一边的指针（因为该指针是从基准点出发，不能让它把基准点交换出去）。</strong></font></li>
</ol>
<p>为了减少麻烦和不必要的错误，以及保证分离的大小两部分数据的平衡性，<font color="red"><strong>最简单的方法就是两边都带 “=”</strong></font>。</p>
<hr>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h3><p>总的来说，写快速排序时，需要注意一下几点：</p>
<ol>
<li><strong>基准点在最左端时，指针移动先右后左；</strong></li>
<li><strong>基准点在最右端时，指针移动先左后右；</strong></li>
<li><strong>遇到等于基准值的位置，直接跳过（两边都带 “=”）。</strong></li>
</ol>
<p>总之一句话，<font color="red"><strong>基准点对面的指针先移动，移动时都带 “=”。</strong></font></p>
<hr>
<h3 id="问题排除"><a href="#问题排除" class="headerlink" title="问题排除"></a>问题排除</h3><p>暂无</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a href="http://www.cnblogs.com/ahalei/p/3568434.html">http://www.cnblogs.com/ahalei/p/3568434.html</a><br><a href="https://blog.csdn.net/lemon_tree12138/article/details/50622744">https://blog.csdn.net/lemon_tree12138/article/details/50622744</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>922. 按奇偶排序数组 II</title>
    <url>/practice/leetcode/array/922.SortArrayByParityII/</url>
    <content><![CDATA[<h1 id="922-按奇偶排序数组-II"><a href="#922-按奇偶排序数组-II" class="headerlink" title="922. 按奇偶排序数组 II"></a>922. 按奇偶排序数组 II</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非负整数数组A， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便：</p>
<ul>
<li>当A[i] 为奇数时，i也是奇数；</li>
<li>当A[i]为偶数时，i 也是偶数。</li>
</ul>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>利用双指针，偶数指针放偶数，奇数指针放奇数。</p>
<ul>
<li>左指针从 <code>1 ~ 2n - 1</code></li>
<li>右指针从 <code>0 ~ 2n</code></li>
</ul>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>空间 <code>O(n)</code></li>
<li>时间 <code>O(n)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奇偶数排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParityII(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> ep = <span class="number">0</span>, op = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n[ep] = num;</span><br><span class="line">            ep += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n[op] = num;</span><br><span class="line">            op += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>905. 按奇偶排序数组</title>
    <url>/practice/leetcode/array/905.SortArrayByParity/</url>
    <content><![CDATA[<h1 id="905-按奇偶排序数组"><a href="#905-按奇偶排序数组" class="headerlink" title="905. 按奇偶排序数组"></a>905. 按奇偶排序数组</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。</p>
<p>你可以返回满足此条件的任何数组作为答案。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>利用左右指针，左指针放偶数，右指针放奇数。</p>
<ul>
<li>左指针从 <code>0 ~ n</code></li>
<li>右指针从 <code>n ~ 0</code></li>
</ul>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(n)</code></li>
</ul>
<h2 id="三、提交代码"><a href="#三、提交代码" class="headerlink" title="三、提交代码"></a>三、提交代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奇偶数排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> lp = <span class="number">0</span>, rp = n.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; n.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[k] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n[lp++] = nums[k++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n[rp--] = nums[k++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>896. 单调数列</title>
    <url>/practice/leetcode/array/896.Monotonic/</url>
    <content><![CDATA[<h1 id="896-单调数列"><a href="#896-单调数列" class="headerlink" title="896. 单调数列"></a>896. 单调数列</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>如果数组是单调递增或单调递减的，那么它是单调的。</p>
<ul>
<li>如果对于所有 i &lt;= j，A[i] &lt;= A[j]，那么数组 A 是单调递增的。 </li>
<li>如果对于所有 i &lt;= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。</li>
</ul>
<p>当给定的数组 A是单调数组时返回 true，否则返回 false。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>先利用首尾2个元素判断递增还是递减。</p>
<p>然后遍历数组，如果发现和首尾元素的标记不一样，就说明不是单调的。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是单调数列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = nums[<span class="number">0</span>] &lt;= nums[nums.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>746. 使用最小花费爬楼梯</title>
    <url>/practice/leetcode/array/746.MinCostClimbingStairs/</url>
    <content><![CDATA[<h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值cost[i]（下标从 0 开始）。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<span id="more"></span>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：cost = [10, 15, 20]</span><br><span class="line">输出：15</span><br><span class="line">解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出：6</span><br><span class="line">解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</span><br></pre></td></tr></table></figure>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>假设此时要计算走到第i个阶梯的花费，那么有2种情况可以做到：</p>
<ol>
<li>此时站在 <code>i - 1</code> 阶梯上，迈1步走上第i个阶梯，需要花费 <code>cost[i - 1]</code>;</li>
<li>此时站在 <code>i - 2</code> 阶梯上，迈2步走上第i个阶梯，需要花费 <code>cost[i - 2]</code>。</li>
</ol>
<p>因此走到第i个阶梯的最小花费就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">minCost[i] = min(minCost[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], minCost[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>题目的要求是走过n个阶梯，并不是走到第n个阶梯。</p>
<p>也就是说，实际上应该是要走到第 n + 1 个阶梯上面，所以最终求的结果应该是 <code>minCost[n + 1]</code>。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 O(n)</li>
<li>空间 O(1)</li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用最小花费爬楼梯</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cost 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最小花费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 求走到第 n + 1 阶梯的花费</span></span><br><span class="line">    <span class="keyword">int</span>[] minCost = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minCost.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            minCost[i] = Math.min(minCost[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], minCost[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minCost[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost[minCost.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化空间，因为只用到了 <code>minCost[i - 1]</code> 和 <code>minCost[i - 2]</code>，所以直接用2个变量保存就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用最小花费爬楼梯</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cost 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最小花费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minCost = <span class="number">0</span>, minCost1 = <span class="number">0</span>, minCost2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; cost.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minCost = Math.min(minCost1 + cost[i - <span class="number">1</span>], minCost2 + cost[i - <span class="number">2</span>]);</span><br><span class="line">        minCost2 = minCost1;</span><br><span class="line">        minCost1 = minCost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>724. 寻找数组的中心下标</title>
    <url>/practice/leetcode/array/724.PivotIndex/</url>
    <content><![CDATA[<h1 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a>724. 寻找数组的中心下标</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个整数数组nums，请编写一个能够返回数组 “中心下标” 的方法。</p>
<p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<ul>
<li>如果数组不存在中心下标，返回 -1 。</li>
<li>如果数组有多个中心下标，应该返回最靠近左边的那一个。</li>
</ul>
<span id="more"></span>


<p>注意：中心下标可能出现在数组的两端。</p>
<ul>
<li>nums 的长度范围为 [0, 10000]。</li>
<li>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</li>
</ul>
<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>先算出整个数组的总和，然后利用一个指针，从左往右遍历数组。</p>
<p>在遍历的同时，计算左边的和 <code>leftSum += nums[p - 1]</code>，和右边的和 <code>rightSum -= nums[i]</code>。</p>
<p>当 <code>leftSum == rightSum</code> 时，就是中心下标。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找数组的中心下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 中心下标索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>, rightSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        rightSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            leftSum += nums[p - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        rightSum -= nums[p];</span><br><span class="line">        <span class="keyword">if</span> (leftSum == rightSum) &#123;</span><br><span class="line">            result = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>717. 1比特与2比特字符</title>
    <url>/practice/leetcode/array/717.OneBitCharacter/</url>
    <content><![CDATA[<h1 id="717-1比特与2比特字符"><a href="#717-1比特与2比特字符" class="headerlink" title="717. 1比特与2比特字符"></a>717. 1比特与2比特字符</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>有两种特殊字符。</p>
<ul>
<li>第一种字符可以用一比特0来表示。</li>
<li>第二种字符可以用两比特(10或11)来表示。</li>
</ul>
<p>现给一个由若干比特组成的字符串。</p>
<p>问最后一个字符是否必定为一个一比特字符。</p>
<p>给定的字符串总是由0结束。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>我的想法是，既然最后一个是0，而且要识别这个0是不是1bit，那么就从后面往前找，直到找到不符合2bit字符的情况为止。</p>
<ol>
<li>前一个数字是0，那么00在一起，最后的0肯定是1bit；</li>
<li>前一个数字是1，再前一个也是1，也就是110，那么无法判断，继续往前；</li>
<li>前一个数字是1，再前一个是0，也就是010，那么后面的0肯定是属于前面的1的，肯定是2bit。</li>
</ol>
<p>根据这样从后往前判断，就可以判断出来结果。</p>
<p>不过官方的解法更简洁，只要判断最后2个0之间的1的数量，就可以识别出最后一个0是不是1bit：</p>
<ol>
<li>如果最后2个0之间的1数量是偶数，说明这些1都是11组合的，所以最后1个0肯定是1bit；</li>
<li>如果最后2个0之间的1数量是奇数，说明除了最后1个1以外，其他都是11组合，最后一个则是10组合，所以是2bit。</li>
</ol>
<p>虽然原理上差不太多，不过官方解法确实简洁~~~</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后一个字符是否必定为一个一比特字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bits 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bits.length &lt;= <span class="number">0</span> || bits[bits.length - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rp = bits.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (rp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bits[rp] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是00，那后面的0肯定是单独的0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rp - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; bits[rp - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 前面是11，忽略它们并继续往前找</span></span><br><span class="line">            rp -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 前面是01，那么后面的0肯定属于前面的1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后一个字符是否必定为一个一比特字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bits 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = bits.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; bits[i] &gt; <span class="number">0</span>) i--;</span><br><span class="line">    <span class="keyword">return</span> (bits.length - i) % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>697. 数组的度</title>
    <url>/practice/leetcode/array/697.ShortestSubArray/</url>
    <content><![CDATA[<h1 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697. 数组的度"></a>697. 数组的度</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非空且只包含非负数的整数数组nums，数组的度的定义是指数组里任一元素出现频数的最大值。</p>
<p>你的任务是在 nums 中找到与nums拥有相同大小的度的最短连续子数组，返回其长度。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>需要计算数字的度，只能遍历一次数组来计算，可以用数组来保存次数，但是为了简单起见，还是直接用集合类吧。</p>
<p>得到数字的度数后，还需要知道最大度数，这个也顺便在计算数字的度数时一起更新了。</p>
<p>知道哪些数字有最大度数后，就剩下计算它们的最短子数组长度了：</p>
<ul>
<li>这个子数组，实际上就是这个数字第一次和最后一次出现之间的子数组</li>
</ul>
<p>所以还必须知道每个数字第一次和最后一次出现的位置，<code>len = lastPos - firstPos + 1</code>。</p>
<p>我一开始的思路是，得到最大度数和数字后，再逐个寻找这些数字的第一次和最后一次的位置，但是看了官方解答后，没想到可以在前面统计度数时，顺便吧前后出现的位置记录下来，有点意思啊~</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到与nums拥有相同大小的度的最短连续子数组，返回其长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算每个数的度数，以及最大度数</span></span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, <span class="keyword">int</span>[]&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = countMap.get(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">            count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">            count[<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        count[<span class="number">0</span>]++;</span><br><span class="line">        count[<span class="number">2</span>] = i;</span><br><span class="line">        countMap.put(nums[i], count);</span><br><span class="line">        <span class="keyword">if</span> (count[<span class="number">0</span>] &gt; maxCount) &#123;</span><br><span class="line">            maxCount = count[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最大度数数字的最短数组长度</span></span><br><span class="line">    <span class="keyword">int</span> minLen = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, <span class="keyword">int</span>[]&gt; entry : countMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (count[<span class="number">0</span>] == maxCount) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = count[<span class="number">2</span>] - count[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (len &lt; minLen) &#123;</span><br><span class="line">                minLen = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>665. 非递减数列</title>
    <url>/practice/leetcode/array/665.CheckPossibility/</url>
    <content><![CDATA[<h1 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a>665. 非递减数列</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个长度为n的整数数组，请你判断在 最多 改变1 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>我们是这样定义一个非递减数列的：对于数组中任意的i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>既然是非递减数列，那么就从左到右遍历数组，维护一个前面遍历过的最大值 <code>prev</code>，当前值 <code>nums[i]</code>，下一个值 <code>next</code>。</p>
<ol>
<li>若 <code>nums[i] &lt; prev</code>，因为要求是非递减的，那么 <code>nums[i]</code> 是一定要修正，至少要修正到 <code>nums[i] = prev</code>；</li>
<li>若 <code>prev &lt;= nums[i] &lt;= next</code>，属于正常情况，那么中值是不用修正的，直接更新 <code>prev = nums[i]</code>；</li>
<li>若 <code>prev &lt;= nums[i] &amp;&amp; nums[i] &gt; next</code>，也就是中值比两边值都大，这个时候就需要分成2种情况：一种是 <code>prev &lt;= next</code>，这时候只需要修正中值 <code>nums[i] = prev</code> 就行了；另一种是 <code>prev &gt; next</code>，这个时候修正中值是没办法满足非递减要求的，只能修正 <code>next</code> 的值。</li>
</ol>
<p>同时，为了保证 <code>prev</code> 和 <code>next</code> 一直存在，就给数组左右两边分别添加了额外的最小最大值，即整数的最小最大值。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 O(n)</li>
<li>空间 O(1)</li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查数组能否变成一个非递减数列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fixCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; fixCount &lt;= <span class="number">1</span> &amp;&amp; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = i + <span class="number">1</span> &lt; nums.length ? nums[i + <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 中值比前值小，肯定要修正</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; prev) &#123;</span><br><span class="line">            <span class="comment">// 修正为 nums[i] = prev</span></span><br><span class="line">            fixCount++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中值在前后值之间，不用修正</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= next) &#123;</span><br><span class="line">            prev = nums[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中值最大，前值后值都比中值小</span></span><br><span class="line">        <span class="keyword">if</span> (prev &lt;= next) &#123;</span><br><span class="line">            <span class="comment">// 前值比后值小，修正中值</span></span><br><span class="line">            <span class="comment">// 修正为 prev &lt;= nums[i] &lt;= next</span></span><br><span class="line">            fixCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 前值比后值大，修正后值</span></span><br><span class="line">            prev = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fixCount &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>643. 子数组最大平均数 I</title>
    <url>/practice/leetcode/array/643.MaxAverage/</url>
    <content><![CDATA[<h1 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a>643. 子数组最大平均数 I</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>因为是连续子数组，所以直接使用滑动窗口来计算就行。</p>
<p>下一个和 = 上一个和 - 窗口第1个元素 + 新元素</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大平均数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大平均数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        maxSum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k, sum = maxSum; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum = sum - nums[i - k] + nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; maxSum) &#123;</span><br><span class="line">            maxSum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum * <span class="number">1.0</span> / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>628. 三个数的最大乘积</title>
    <url>/practice/leetcode/array/628.MaximumProduct/</url>
    <content><![CDATA[<h1 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a>628. 三个数的最大乘积</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<ul>
<li>3 &lt;= nums.length &lt;= 104</li>
<li>-1000 &lt;= nums[i] &lt;= 1000</li>
</ul>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="2-1-思路1：排序"><a href="#2-1-思路1：排序" class="headerlink" title="2.1 思路1：排序"></a>2.1 思路1：排序</h3><p>先排序，然后再找最大值，可能的情况包括：</p>
<ol>
<li>都是非负数，或者非正数，此时最大值只能是最后3个值相乘；</li>
<li>正数负数都有，那么最大乘积就只可能是2种情况：3非负、1非负2非正。</li>
</ol>
<h3 id="2-2-思路2（官方解法）：直接遍历"><a href="#2-2-思路2（官方解法）：直接遍历" class="headerlink" title="2.2 思路2（官方解法）：直接遍历"></a>2.2 思路2（官方解法）：直接遍历</h3><p>思路1中实际用到的值包括：3个最大值和2个最小值。</p>
<p>直接遍历数组，拿到这些值，然后最大乘积就只能是2种情况：</p>
<ol>
<li>3个最大值（3正或3负）;</li>
<li>1个最大值2个最小值（1正2负）。</li>
</ol>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><p>1）思路1：排序</p>
<ul>
<li>时间 <code>O(nlogn)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<p>2）思路2（官方解法）：直接遍历</p>
<ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><p>1）思路1：排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三个数的最大乘积</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大乘积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maximumProduct2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt;= <span class="number">0</span> || nums[nums.length - <span class="number">1</span>] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 3非负，或3非正</span></span><br><span class="line">        result = nums[nums.length - <span class="number">1</span>] * nums[nums.length - <span class="number">2</span>] * nums[nums.length - <span class="number">3</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3非负，或1非负2非正</span></span><br><span class="line">        <span class="keyword">int</span> r1 = nums[nums.length - <span class="number">1</span>] * nums[nums.length - <span class="number">2</span>] * nums[nums.length - <span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 1非负2非正</span></span><br><span class="line">        <span class="keyword">int</span> r2 = nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[nums.length - <span class="number">1</span>];</span><br><span class="line">        result = Math.max(r1, r2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）思路2：直接遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三个数的最大乘积</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大乘积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line">        <span class="comment">// 最大值</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt; max1) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = max1;</span><br><span class="line">            max1 = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; max2) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; max3) &#123;</span><br><span class="line">            max3 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小值</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt; min1) &#123;</span><br><span class="line">            min2 = min1;</span><br><span class="line">            min1 = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; min2) &#123;</span><br><span class="line">            min2 = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(max1 * max2 * max3, max1 *  min1 * min2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>605. 种花问题</title>
    <url>/practice/leetcode/array/605.PlaceFlowers/</url>
    <content><![CDATA[<h1 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a>605. 种花问题</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。</p>
<p>可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。</p>
<p>另有一个数n ，能否在不打破种植规则的情况下种入n朵花？能则返回 true ，不能则返回 false。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>遍历数组，除了2端的元素以外，只要有连续的3个为0的地方，就可以在中间的0那里种花。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 种花问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flowerbed 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flowerbed.length &lt; <span class="number">2</span> * n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; k &gt; <span class="number">0</span> &amp;&amp; i &lt; flowerbed.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前不为空</span></span><br><span class="line">        <span class="keyword">if</span> (flowerbed[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左边不为空</span></span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右边不为空</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; flowerbed.length &amp;&amp; flowerbed[i + <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两边都为空，可以种花</span></span><br><span class="line">        k--;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>561. 数组拆分 I</title>
    <url>/practice/leetcode/array/561.ArrayPairSum/</url>
    <content><![CDATA[<h1 id="561-数组拆分-I"><a href="#561-数组拆分-I" class="headerlink" title="561. 数组拆分 I"></a>561. 数组拆分 I</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定长度为2n的整数数组 nums ，你的任务是将这些数分成 n 对。</p>
<p>例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到n 的 min(ai, bi) 总和最大。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>假设一个有序序列 <code>a1 &lt;= a2 &lt;= a3 &lt;= a4 ... &lt;= an</code>。</p>
<p>a1 是最小值，那它应该和谁一起组成数对呢？</p>
<p>由于计算总和时取的是数对中的小值 min(a1, x)，而此时 a1 是最小值，也就是说，无论 x 是哪个，实际上计算时都会被抛弃。</p>
<p>为了能够实现最大和，我们就选个最小和和 a1 组合，那剩下的元素里，最小的就是 a2 了，所以得到第一个数对 (a1, a2)。</p>
<p>以此类推，最终得到的优数对组合就是 <code>(a1, a2), (a3, a4), ... , (an-1, an)</code>。</p>
<p>而此时的最大总和就是 <code>a1 + a3 + a5 + ... + an-1</code>。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(nlogn)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数对最小值的最大和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>448. 找到所有数组中消失的数字</title>
    <url>/practice/leetcode/array/448.DisappearedNumbers/</url>
    <content><![CDATA[<h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。</p>
<p>请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>把数值 n 放到它应该在的位置 n - 1，最后再遍历一遍数组，如果 <code>nums[i] != i + 1</code>，就表明数字 <code>i + 1</code> 丢失了。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到所有数组中消失的数字</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 消失的数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> &lt;= t &amp;&amp; t &lt; n &amp;&amp; nums[t] != nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 循环交换到正确的位置</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[t];</span><br><span class="line">            nums[t] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">            t = nums[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">            result.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>167. 两数之和 II - 输入有序数组</title>
    <url>/practice/leetcode/binary/167.TwoSum2/</url>
    <content><![CDATA[<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个已按照 升序排列 的整数数组numbers ，请你从数组中找出两个数满足相加之和等于目标数target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>因为是升序数组，并且找2个数的和等于某个值，所以可以从数组2头分别开始遍历，找到符合的值。</p>
<p>比如目标值是 t，此时选中左边 l，右边 r。</p>
<ol>
<li><p>如果此时 l + r == t，直接满足条件；</p>
</li>
<li><p>如果 l + r &lt; t，需要增大2数之和，那就取 l 的下一个数；</p>
</li>
<li><p>如果 l + r &gt; t，需要减少2数之和，那就取 r 的前一个数。</p>
</li>
</ol>
<p>为什么这种方式可以找到和为 t 的值呢？</p>
<p>首先，如果发现此时 l + r &lt; t，那么就可以判定：</p>
<blockquote>
<p>l 左边的值 ll 比 l 小，所以 ll + r &lt; t，都不满足条件，排除.</p>
</blockquote>
<p>其次，如果发现此时 l + r &gt; t，那么就可以判定：</p>
<blockquote>
<p>r 右边的值 rr 比 r 大，所以 l + rr &gt; t，都不满足条件，排除。</p>
</blockquote>
<p>通过不断排除这2种情况的值，就能逐步找到和为指定值的2个数值。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 升序数组中，两个数满足相加之和等于目标数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numbers 升序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 两个数的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (numbers.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lp = <span class="number">0</span>, rp = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = numbers[lp] + numbers[rp];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = lp + <span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>] = rp + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            lp++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rp--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>36. 有效的数独</title>
    <url>/practice/leetcode/array/36.ValidSudoku/</url>
    <content><![CDATA[<h1 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请你判断一个9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<ul>
<li>数字1-9在每一行只能出现一次。</li>
<li>数字1-9在每一列只能出现一次。</li>
<li>数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。（请参考示例图）</li>
<li>数独部分空格内已填入了数字，空白格用’.’表示。</li>
</ul>
<span id="more"></span>


<p>注意：</p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
</ul>
<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>按照题目的要求，按行、按列、按方格分别验证各种情况是否符合要求。</p>
<p>这样做的话，需要遍历3遍二维数组。</p>
<p>官方解法，只用遍历一次二维数组，遍历同时校验各个位置的有效性，时间和空间效率比我想得要高。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n^2)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证是否是有效的9x9数独</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkRangeValid(board, i, <span class="number">0</span>, <span class="number">1</span>, board[i].length)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkRangeValid(board, <span class="number">0</span>, i, board.length, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验方格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j += <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!checkRangeValid(board, i, j, <span class="number">3</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证指定范围的有效性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkRangeValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line">    Arrays.fill(flags, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = board[x + i][y + j];</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (flags[index]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flags[index] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 官方解法，一次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku2</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span>[][] columns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span>[][][] subboxes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = c - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                rows[i][index]++;</span><br><span class="line">                columns[j][index]++;</span><br><span class="line">                subboxes[i / <span class="number">3</span>][j / <span class="number">3</span>][index]++;</span><br><span class="line">                <span class="keyword">if</span> (rows[i][index] &gt; <span class="number">1</span> || columns[j][index] &gt; <span class="number">1</span> || subboxes[i / <span class="number">3</span>][j / <span class="number">3</span>][index] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>268. 丢失的数字</title>
    <url>/practice/leetcode/array/268.MissingNumber/</url>
    <content><![CDATA[<h1 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a>268. 丢失的数字</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="2-1-思路1"><a href="#2-1-思路1" class="headerlink" title="2.1 思路1"></a>2.1 思路1</h3><p>既然数值是在 [0, n] 之间，也就是说可以把正确的数值设到数组 num[i] 上。</p>
<p>比如此时 <code>i = 0, nums[i] = 3</code></p>
<p>那么就知道了 3 是存在的，并把它交换到它应该在的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nums[<span class="number">0</span>] = nums[<span class="number">3</span>];</span><br><span class="line">nums[<span class="number">3</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>通过这样把值设到正确的位置。</p>
<p>最后再遍历一遍数组，如果索引和值不相等，表示当前索引的值丢失了。</p>
<h3 id="2-2-思路2（官方解法）"><a href="#2-2-思路2（官方解法）" class="headerlink" title="2.2 思路2（官方解法）"></a>2.2 思路2（官方解法）</h3><p>异或操作中，同一个数值异或1次，得到的结果为 0。</p>
<p>比如 <code>3 ^ 3 = 0</code>。</p>
<p>根据这种现象，可以通过异或数组中的所有值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 ^ nums[0] ^ 1 ^ nums[1] ... ^ (n - 1) ^ nums[n - 1] ^ n</span><br></pre></td></tr></table></figure>

<p>在这里面，正常值有2个，它们异或之后结果是 0，而丢失的数字只有一个，所以异或结果就是丢失的数字。</p>
<p>官方解法也太骚了，这还真想不到。。。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><p>1）思路1</p>
<ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<p>1）思路2</p>
<ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><p>1）解法1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 丢失的数字</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 丢失的数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> &lt;= t &amp;&amp; t &lt; n &amp;&amp; nums[t] != nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 一直交换到正确的位置</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[t];</span><br><span class="line">            nums[t] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">            t = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）解法2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 丢失的数字（官方解法）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 丢失的数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">missingNumber2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> missing = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        missing ^= i ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> missing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>204. 计数质数</title>
    <url>/practice/leetcode/array/204.PrimesCount/</url>
    <content><![CDATA[<h1 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>统计所有小于非负整数 n 的质数的数量。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>如果 x 是质数，那么大于 x 的 x 的倍数 <code>2x, 3x ,…</code> 一定不是质数。</p>
<p>不过实际上，对于一个质数 x，应该直接从 x⋅x 开始标记，因为 <code>2x, 3x, …</code> 这些数一定在 x⋅x 之前就被其他数的倍数标记过了。</p>
<p>例如 2x 已经被 2 标记了，3x 已经被 3 标记了。</p>
<h2 id="三、时间复杂度"><a href="#三、时间复杂度" class="headerlink" title="三、时间复杂度"></a>三、时间复杂度</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(n)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计所有小于非负整数 n 的质数的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 非负整数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 质数数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] bools = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    Arrays.fill(bools, <span class="keyword">true</span>);</span><br><span class="line">    bools[<span class="number">0</span>] = bools[<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; Math.sqrt(n); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bools[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sum = i * i; sum &lt; n; sum += i) &#123;</span><br><span class="line">            bools[sum] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bools[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>169. 多数元素</title>
    <url>/practice/leetcode/array/169.MajorityElement/</url>
    <content><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于⌊ n/2 ⌋的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>投票法，相同值 +1，不同值 -1。</p>
<p>因为有一半元素以上是同一个值，所以最终投票结果肯定是超过半数的那个元素。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找出现次数大于一半的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于一半数量的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 投票法，相同值+1，不同值-1</span></span><br><span class="line">    <span class="comment">// 因为有一半元素以上是同一个值，所以最终投票结果肯定是超过半数的那个元素</span></span><br><span class="line">    <span class="keyword">int</span> x = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            x = nums[i];</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == nums[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/practice/leetcode/binary/34.SearchRange/</url>
    <content><![CDATA[<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。</p>
<p>找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回[-1, -1]。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>既然是排序好的数组，那就用二分查找法来直接找到对应的位置。</p>
<p>需要定位开始的位置和结束的位置，因此我的想法是：</p>
<ul>
<li>分别找到 <code>nums[l] &gt;= target</code> 和 <code>nums[r] &gt;= target + 1</code> 的第一个索引位置</li>
</ul>
<p>它们的范围 <code>[l, r - 1]</code> 就是所求的结果。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(logn)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索指定目标值的范围</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引范围</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">0</span>] = result[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lp = findIndex(nums, target, <span class="number">0</span>, nums.length);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt;= lp &amp;&amp; lp &lt; nums.length &amp;&amp; nums[lp] == target) &#123;</span><br><span class="line">        result[<span class="number">0</span>] = lp;</span><br><span class="line">        result[<span class="number">1</span>] = findIndex(nums, target + <span class="number">1</span>, lp, nums.length) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找大于等于 target 的第一个位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 结束位置，不包括</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于等于target的第一个位置，或-1，或end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lp = start, rp = end;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = lp + ((rp - lp) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[m]) &#123;</span><br><span class="line">            rp = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lp = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>33.搜索旋转排序数组</title>
    <url>/practice/leetcode/binary/33.RotateSearch/</url>
    <content><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。</p>
<p>例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>循环数组可以分为2个有序的数组，所以可以利用二分搜索法查找。</p>
<p>首先取中值，那么中值左右两边的数组：</p>
<ul>
<li>肯定有一边是有序的，另一边可能是有序的，也可能是循环有序的</li>
</ul>
<p>如果是位于有序数组内，直接使用二分法查找即可；</p>
<p>如果是位于另外的数组，则按照之前的方式继续递归。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(logn)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索旋转排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 目标值的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 目标值索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; start) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mp = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mp] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mp] &gt;= nums[start]) &#123;</span><br><span class="line">        <span class="comment">// 中值在左边的升序序列中</span></span><br><span class="line">        <span class="keyword">if</span> (nums[start] &lt;= target &amp;&amp; target &lt; nums[mp]) &#123;</span><br><span class="line">            <span class="comment">// 左边</span></span><br><span class="line">            <span class="keyword">return</span> find(nums, target, start, mp - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右边</span></span><br><span class="line">            <span class="keyword">return</span> find(nums, target, mp + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 中值在右边的升序序列中</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mp] &lt; target &amp;&amp; target &lt;= nums[end]) &#123;</span><br><span class="line">            <span class="comment">// 右边</span></span><br><span class="line">            <span class="keyword">return</span> find(nums, target, mp + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左边</span></span><br><span class="line">            <span class="keyword">return</span> find(nums, target, start, mp - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>31. 下一个排列</title>
    <url>/practice/leetcode/array/31.NextPermutation/</url>
    <content><![CDATA[<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<ul>
<li>1 &lt;= nums.length &lt;= 100</li>
<li>0 &lt;= nums[i] &lt;= 100</li>
</ul>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="2-1-个人想法"><a href="#2-1-个人想法" class="headerlink" title="2.1 个人想法"></a>2.1 个人想法</h3><p>我自己的想法是，既然是下一个比它大的排序值，那肯定是改变值的位置越靠后越好。</p>
<p>比如 123，改变2的值变成132，肯定比改变1的值变成213更贴近原值。</p>
<ul>
<li>首先就是要找到最靠后的可以交换的值</li>
</ul>
<p>什么样的值是可以改变的？</p>
<ul>
<li>既然是求下一个大值，那么这个改变值的后续序列中，肯定要有比改变值大的</li>
</ul>
<p>比如 42531，改变值就是2，因为531的后面都没有比它们大的值，而2的后续值53比2大，这个时候改变2的值，就能获取比它更大的值。</p>
<p>后续序列中比改变值大的可能有多个，那应该改变哪个值呢？</p>
<ul>
<li>既然是下一个大值，那肯定是改变的越小越好</li>
</ul>
<p>比如前面的 42531，2换成3的改变是最小的，因为3比2大，并且2和3最接近。</p>
<p>交换之后就可以了吗？</p>
<p>实际还不行，交换后的值为 43521，但是可以发现，43125 &lt; 43521</p>
<ul>
<li>所以除了交换值以外，还需要对后续的序列进行升序排序</li>
</ul>
<p>总的步骤可以分为3步：</p>
<ol>
<li>找到要改变的值，它的后续值中有比它大的值，比如前面说的2；</li>
<li>找到后续值中比它大的最小值，作为改变值即将交换的值，比如前面说的2和3；</li>
<li>对后续的序列进行升序排序。</li>
</ol>
<h3 id="2-2-官方解法"><a href="#2-2-官方解法" class="headerlink" title="2.2 官方解法"></a>2.2 官方解法</h3><p>官方的思路其实和我的差不多，但是比我的更精妙，时间复杂度也比我的低得多。</p>
<ol>
<li><p>第一步，也是找出改变值，但是它不像我那样遍历寻找，而是倒序找到第一个逆序元素，也就是满足 nums[i] &lt; nums[i + 1]，num[i] 就是需要改变的值。为什么这样做？其实看前面的例子 42531，确实可以发现，2是满足 nums[i] &lt; nums[i + 1]，不得不说，官方的这个想法比我好多了~~</p>
</li>
<li><p>第二步，找出需要交换的值，也就是比改变值大的最小值。官方的更直接，前面第一步找的就是第一个逆序元素，也就意味着，改变值之后的序列，是一个降序序列，从我前面的例子可以看出，2的后续序列531确实是降序的，所以只要从后往前找到第一个比2大的值，就是要最小的比2大的值，也就是3。</p>
</li>
<li><p>第三步，排序，因为前面知道了改变值的后续序列是降序的，而且交换之后，实际上也是降序的，如交换后43521，521依旧是降序的。所以只要把降序的521倒过来变成125，就是升序了，无需做排序操作（官方牛逼~~）</p>
</li>
</ol>
<p>总之，虽然思路是差不多的，但是官方的精妙得多，时间复杂度比我低了整整一个等级~~~~</p>
<h2 id="三复杂度分析"><a href="#三复杂度分析" class="headerlink" title="三复杂度分析"></a>三复杂度分析</h2><p>1）个人解法</p>
<ul>
<li>时间 <code>O(n^2)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<p>2）官方解法</p>
<ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><p>1）个人代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 31. 下一个排列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findMinMax(nums, nums[i], i + <span class="number">1</span>, nums.length);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[index];</span><br><span class="line">            nums[index] = temp;</span><br><span class="line">            Arrays.sort(nums, i + <span class="number">1</span>, nums.length);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找比k大的最小值的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引，或-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMinMax</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxIndex == -<span class="number">1</span> || nums[maxIndex] &gt; nums[i]) &#123;</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）官方代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 31. 下一个排列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找第一个逆序值</span></span><br><span class="line">    <span class="keyword">int</span> index = nums.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; nums[index] &gt;= nums[index + <span class="number">1</span>]) &#123;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换比逆序值大的最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; index &gt;= <span class="number">0</span> &amp;&amp; i &gt; index; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[index]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[index];</span><br><span class="line">            nums[index] = temp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后面这部分是降序的，倒过来转成升序</span></span><br><span class="line">    <span class="keyword">int</span> lp = index + <span class="number">1</span>, rp = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[lp];</span><br><span class="line">        nums[lp++] = nums[rp];</span><br><span class="line">        nums[rp--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <url>/practice/leetcode/array/122.MaxProfit2/</url>
    <content><![CDATA[<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个数组 prices ，其中prices[i] 是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>想要获取最大收益，最好的情况就是在谷值买入，峰值卖出。</p>
<p>但是如果谷值和峰值都很多的情况下，这个时候该什么时候买入卖出呢？</p>
<ul>
<li>最优的情况是在相邻的谷值和峰值买入卖出，收益才能最大。</li>
</ul>
<p>验证过程：</p>
<p>比如谷值是 a，峰值 b（b &gt; a，否则收益为负数），此时收益就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b - a</span><br></pre></td></tr></table></figure>

<p>假设 a，b之间还存在另外的峰值 c, 谷值 d，其中有 d &lt; c。</p>
<p>那么相邻谷值峰值买入卖出的收益是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c - a + b - d = b - a + c - d &gt; b - a</span><br></pre></td></tr></table></figure>

<p>也就是说，如果在一对谷值峰值之间，还存在别的谷值峰值，那它们取得的收益就不是最大值。</p>
<p>因此，相邻谷值峰值买入卖出的情况下能够获取最大收益。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大收益</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prices 价格数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大收益</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sumVal = <span class="number">0</span>, n = prices.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rp = <span class="number">1</span>; rp &lt; n; rp++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[rp] &gt; prices[rp - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 谷值到峰值之间的上升值</span></span><br><span class="line">            sumVal += prices[rp] - prices[rp - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <url>/practice/leetcode/array/121.MaxProfit/</url>
    <content><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。</p>
<p>设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>1、找到一个小值，然后从这个小值开始往右查找大值，并更新这期间的最大差值<br>2、在查找大值的过程中，如果遇到一个更小值，则更新小值的位置，重新进行1步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> lp  rp</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___ </span><br><span class="line">| 2 | 2 | 3 | 1 | 4 | 5 | 6 |      =&gt; maxDiffVal = 2 - 2 = 0</span><br><span class="line"></span><br><span class="line"> lp      rp</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___ </span><br><span class="line">| 2 | 2 | 3 | 1 | 4 | 5 | 6 |      =&gt; maxDiffVal = 3 - 2 = 1</span><br><span class="line"></span><br><span class="line">            lp;rp</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___ </span><br><span class="line">| 2 | 2 | 3 | 1 | 4 | 5 | 6 |      =&gt; maxDiffVal = 1</span><br><span class="line"></span><br><span class="line">             lp  rp</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___ </span><br><span class="line">| 2 | 2 | 3 | 1 | 4 | 5 | 6 |      =&gt; maxDiffVal = 4 - 1 = 3</span><br><span class="line"></span><br><span class="line">             lp           rp</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___ </span><br><span class="line">| 2 | 2 | 3 | 1 | 4 | 5 | 6 |      =&gt; maxDiffVal = 6 - 1 = 5</span><br></pre></td></tr></table></figure>

<p>类似这种效果。</p>
<p>但是，后面的差值就不一定比前面的差值大。</p>
<p>举个例子，把上面的 3 改成 9：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> lp      rp</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___ </span><br><span class="line">| 2 | 2 | 9 | 1 | 4 | 5 | 6 |      =&gt; maxDiffVal = 9 - 2 = 7</span><br><span class="line"></span><br><span class="line">            lp;rp</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___ </span><br><span class="line">| 2 | 2 | 9 | 1 | 4 | 5 | 6 |      =&gt; maxDiffVal = 7</span><br><span class="line"></span><br><span class="line">             lp  rp</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___ </span><br><span class="line">| 2 | 2 | 9 | 1 | 4 | 5 | 6 |      =&gt; maxDiffVal = 7 &gt; 4 - 1 = 3</span><br><span class="line"></span><br><span class="line">             lp           rp</span><br><span class="line"> ___ ___ ___ ___ ___ ___ ___ </span><br><span class="line">| 2 | 2 | 9 | 1 | 4 | 5 | 6 |      =&gt; maxDiffVal = 7 &gt; 6 - 1 = 5</span><br></pre></td></tr></table></figure>

<p>这种情况下，最大值就是之前的差值，所以更新最大差值时需要和之前的比较过才行。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大收益</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prices 价格数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大收益</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxDiffVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lp = <span class="number">0</span>, n = prices.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rp = lp; rp &lt; n; rp++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[rp] &lt; prices[lp]) &#123;</span><br><span class="line">            <span class="comment">// 找到更小值，那后面的最大差值就和之前的最小值没关系了</span></span><br><span class="line">            <span class="comment">// 后面就用最新的最小值来计算差值</span></span><br><span class="line">            lp = rp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[rp] - prices[lp] &gt; maxDiffVal) &#123;</span><br><span class="line">            <span class="comment">// 找到更大值，更新最新的差值</span></span><br><span class="line">            maxDiffVal = prices[rp] - prices[lp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDiffVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 四数之和</title>
    <url>/practice/leetcode/array/18.FourSum/</url>
    <content><![CDATA[<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：答案中不可以包含重复的四元组。</p>
<ul>
<li>0 &lt;= nums.length &lt;= 200</li>
<li>-109 &lt;= nums[i] &lt;= 109</li>
<li>-109 &lt;= target &lt;= 109</li>
</ul>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>与三数之和类似，先排序，然后</p>
<ul>
<li>把 <code>a + b + c + d = target</code> 变成三数之和 <code>a + b + c = target - d</code></li>
</ul>
<p>最后按照三数之和求值即可。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n^3)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四数之和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 四元组列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;Integer&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        values.add(nums[i]);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; sumList = threeSum(nums, target - nums[i], i + <span class="number">1</span>, nums.length - <span class="number">1</span>, values);</span><br><span class="line">        <span class="keyword">if</span> (sumList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.addAll(sumList);</span><br><span class="line">        &#125;</span><br><span class="line">        values.remove(values.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三数之和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 所有三元组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;Integer&gt; values) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        values.add(nums[i]);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; sumList = twoSum(nums, target - nums[i], i + <span class="number">1</span>, nums.length - <span class="number">1</span>, values);</span><br><span class="line">        <span class="keyword">if</span> (sumList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.addAll(sumList);</span><br><span class="line">        &#125;</span><br><span class="line">        values.remove(values.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求2数之和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 升序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 两数和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 起始地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 结束地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 两数，或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;Integer&gt; values) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> lp = start, rp = end;</span><br><span class="line">    <span class="keyword">int</span> size = values.size() + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[lp] + nums[rp];</span><br><span class="line">        <span class="keyword">if</span> (temp == target) &#123;</span><br><span class="line">            List&lt;Integer&gt; sumList = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">            sumList.addAll(values);</span><br><span class="line">            sumList.add(nums[lp]);</span><br><span class="line">            sumList.add(nums[rp]);</span><br><span class="line">            result.add(sumList);</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">while</span> (lp &lt; rp &amp;&amp; nums[lp] == nums[++lp]);</span><br><span class="line">            <span class="keyword">while</span> (lp &lt; rp &amp;&amp; nums[rp] == nums[--rp]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; target) &#123;</span><br><span class="line">            lp++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rp--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 最接近的三数之和</title>
    <url>/practice/leetcode/array/16.ThreeSumClosest/</url>
    <content><![CDATA[<h1 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和</p>
<p>假定每组输入只存在唯一答案。</p>
<ul>
<li>3 &lt;= nums.length &lt;= 10^3</li>
<li>-10^3 &lt;= nums[i] &lt;= 10^3</li>
<li>-10^4 &lt;= target &lt;= 10^4</li>
</ul>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>原理和求3数之和一样，把它转换成找2数之和，问题就变得稍微容易一些。</p>
<ul>
<li><code>a + b + c = target</code> 可以转成 <code>b + c = target - a</code>，那么就相当于查找2数之和</li>
</ul>
<p>2数之和就快很多了。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n^2)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最近的3数之和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 3数之和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> closestSum = <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = twoSumClosest(nums, target - nums[i], i + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取最接近的值</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || Math.abs(sum - target) &lt; Math.abs(closestSum - target)) &#123;</span><br><span class="line">            closestSum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closestSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最近的2数之和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 终止索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 2数之和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">twoSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lp = start, rp = end;</span><br><span class="line">    <span class="keyword">int</span> sum = nums[lp] + nums[rp];</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[lp] + nums[rp];</span><br><span class="line">        <span class="keyword">if</span> (temp == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(temp - target) &lt; Math.abs(sum - target)) &#123;</span><br><span class="line">            sum = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; target) &#123;</span><br><span class="line">            lp++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rp--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 三数之和</title>
    <url>/practice/leetcode/array/15.ThreeSum/</url>
    <content><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<ul>
<li>0 &lt;= nums.length &lt;= 3000</li>
<li>-105 &lt;= nums[i] &lt;= 105</li>
</ul>
<span id="more"></span>


<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>3个数，如果直接使用3层循环的话，估计应该会超时，所以只能想其他办法。</p>
<ul>
<li><code>a + b + c = 0</code> 可以转成 <code>b + c = -a</code>，那么就相当于查找2数之和，这个就变得简单了</li>
</ul>
<p>3元组去重的问题：</p>
<ul>
<li>通过排序，保证每次的 a、b 不一样，那么 c 肯定不同，3元组也就不一样了</li>
</ul>
<p>至于进一步的优化：</p>
<ul>
<li>既然3个数相加等于0，那么肯定有一个数是非正数</li>
<li>对数组进行排序后，保证最小的那个数是非正数就行</li>
</ul>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n^2)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三数之和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 所有三元组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span> || nums[nums.length - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; sumList = twoSum(nums, -nums[i], i + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (sumList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.addAll(sumList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求2数之和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 升序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sum 两数和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 起始地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 结束地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 两数，或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> sum, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> lp = start, rp = end;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[lp] + nums[rp];</span><br><span class="line">        <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">            List&lt;Integer&gt; sumList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">            sumList.add(-sum);</span><br><span class="line">            sumList.add(nums[lp]);</span><br><span class="line">            sumList.add(nums[rp]);</span><br><span class="line">            result.add(sumList);</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">while</span> (lp &lt; rp &amp;&amp; nums[lp] == nums[++lp]);</span><br><span class="line">            <span class="keyword">while</span> (lp &lt; rp &amp;&amp; nums[rp] == nums[--rp]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; sum) &#123;</span><br><span class="line">            lp++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rp--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>6186. 按位或最大的最小子数组长度</title>
    <url>/practice/leetcode/bit/6186.SmallestSubarrays/</url>
    <content><![CDATA[<h1 id="6186-按位或最大的最小子数组长度"><a href="#6186-按位或最大的最小子数组长度" class="headerlink" title="6186. 按位或最大的最小子数组长度"></a>6186. 按位或最大的最小子数组长度</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。</p>
<p>对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。</p>
<p>换言之，令 Bij 表示子数组 nums[i…j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 max(Bik) ，其中 i &lt;= k &lt;= n - 1 。</p>
<span id="more"></span>

<p>一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。</p>
<p>请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。</p>
<p>子数组 是数组里一段连续非空元素组成的序列。</p>
<p>示例：</p>
<p>输入：nums = [1,0,2,1,3]<br>输出：[3,3,2,2,1]<br>解释：<br>任何位置开始，最大按位或运算的结果都是 3 。</p>
<ul>
<li>下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。</li>
<li>下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。</li>
<li>下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。</li>
<li>下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。</li>
<li>下标 4 处，能得到结果 3 的最短子数组是 [3] 。<br>所以我们返回 [3,3,2,2,1] 。</li>
</ul>
<p>提示：</p>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 105</li>
<li>0 &lt;= nums[i] &lt;= 109</li>
</ul>
<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>整数就 32 位，题目都是非负整数，所以或运算后最多也就是低 31 位全都是 1。</p>
<ul>
<li>或运算结果越大，实际就是 31 位中 1 的数量越多</li>
</ul>
<p>要是知道 31 位整数中每一位 1 出现的位置 <code>indexes</code>，那就能知道或运算达到最大值的地方。</p>
<p>或运算结果最大的最短子数组，就是：</p>
<ul>
<li>从当前索引 i，到 32 位 1 索引最大值的区间 <code>[i, max(indexes)]</code></li>
</ul>
<p>题目限制了范围大于 0 小于 10^9，所以只需要低 30 位就够了。</p>
<h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><ul>
<li>时间 <code>O(n)</code></li>
<li>空间 <code>O(1)</code></li>
</ul>
<h2 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] smallestSubarrays(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 整数低 30 位出现 1 的最小索引</span></span><br><span class="line">    <span class="keyword">int</span>[] indexes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">30</span>];</span><br><span class="line">    Arrays.fill(indexes, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> exist = (nums[i] &gt;&gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (exist &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前数字有第 j 位的 1</span></span><br><span class="line">                <span class="comment">// 因为是求最短子数组，所以更新索引为更小值</span></span><br><span class="line">                indexes[j] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexes[j] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 找出 30 位 1 索引的最大值</span></span><br><span class="line">                maxIndex = Math.max(maxIndex, indexes[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = maxIndex - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>05_指令集和解释器</title>
    <url>/lang/java/jvm/selfjvm/05_instruction/</url>
    <content><![CDATA[<h1 id="指令集和解释器"><a href="#指令集和解释器" class="headerlink" title="指令集和解释器"></a>指令集和解释器</h1><p>Java虚拟机顾名思义，就是一台虚拟的机器，而字节码（bytecode）就是运行在这台虚拟机器上的机器码。</p>
<h2 id="一、字节码指令"><a href="#一、字节码指令" class="headerlink" title="一、字节码指令"></a>一、字节码指令</h2><h3 id="1-1-指令结构"><a href="#1-1-指令结构" class="headerlink" title="1.1 指令结构"></a>1.1 指令结构</h3><p>字节码中存放编码后的 Java 虚拟机指令：</p>
<ul>
<li><p>每条指令都以一个单字节的操作码（opcode）开头。</p>
</li>
<li><p>由于只使用一字节表示操作码，Java 虚拟机最多只能支持 256 条指令。</p>
</li>
</ul>
<p>到第八版为止，Java 虚拟机规范已经定义了205条指令，操作码分别是<code>0(0x00)</code>到 <code>202(0xCA)</code>、<code>254(0xFE)</code>和 <code>255(0xFF)</code>。</p>
<span id="more"></span>

<ul>
<li>Java虚拟机使用的是变长指令，操作码后面可以跟零字节或多字节的操作数（operand）。</li>
</ul>
<p>比如 <code>0xB20002</code> 这条指令，<code>B2</code> 表示该指令的操作码，<code>0002</code> 就表示操作数。</p>
<h3 id="1-2-指令助记符"><a href="#1-2-指令助记符" class="headerlink" title="1.2 指令助记符"></a>1.2 指令助记符</h3><p>为了便于记忆，Java虚拟机规范给每个操作码都指定了一个助记符（mnemonic）。</p>
<p>比如，操作码是 <code>0x00</code> 的助记符是 <code>nop</code>（no operation）。</p>
<ul>
<li><p>操作数栈和局部变量表只存放数据的值（Slot），并不记录数据类型。</p>
</li>
<li><p>所以指令必须知道自己在操作什么类型的数据，即指令绑定了数据类型</p>
</li>
</ul>
<p>例如，<code>iadd</code> 指令就是对 int 值进行加法操作；<code>dstore</code> 指令把操作数栈顶的double值弹出，存储到局部变量表中；<code>areturn</code> 从方法中返回引用值。</p>
<h3 id="1-3-指令类型"><a href="#1-3-指令类型" class="headerlink" title="1.3 指令类型"></a>1.3 指令类型</h3><p>Java 虚拟机规范把已经定义的205条指令按用途分成了11类，分别是：</p>
<ul>
<li>常量（constants）指令</li>
<li>加载（loads）指令</li>
<li>存储（stores）指令</li>
<li>操作数栈（stack）指令</li>
<li>数学（math）指令</li>
<li>转换（conversions）指令</li>
<li>比较（comparisons）指令</li>
<li>控制（control）指令</li>
<li>引用（references）指令</li>
<li>扩展（extended）指令</li>
<li>保留（reserved）指令</li>
</ul>
<p>保留指令一共有3条。</p>
<ul>
<li><p>其中1条是留给调试器的，用于实现断点，操作码是 <code>202(0xCA)</code>，助记符是 <code>breakpoint</code>；</p>
</li>
<li><p>另外2条留给 Java 虚拟机实现内部使用，操作码分别是 <code>254(0xFE)</code> 和 <code>266(0xFF)</code>，助记符是 <code>impdep1</code> 和 <code>impdep2</code>。</p>
</li>
</ul>
<p>这3条保留指令不允许出现在class文件中。</p>
<h2 id="二、指令运行"><a href="#二、指令运行" class="headerlink" title="二、指令运行"></a>二、指令运行</h2><h3 id="2-1-指令循环"><a href="#2-1-指令循环" class="headerlink" title="2.1 指令循环"></a>2.1 指令循环</h3><p>虚拟机的运行过程，就是循环执行指令的过程，伪代码大致是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    atomically calculate pc and fetch opcode at pc;</span><br><span class="line">    <span class="keyword">if</span> (operands) fetch operands;</span><br><span class="line">    execute the action <span class="keyword">for</span> the opcode;</span><br><span class="line">&#125; <span class="keyword">while</span> (there is more to <span class="keyword">do</span>);</span><br></pre></td></tr></table></figure>

<p>每次循环都包含三个部分：</p>
<ol>
<li>计算pc</li>
<li>指令解码</li>
<li>指令执行</li>
</ol>
<p>上面的伪代码转成 java 代码的话，大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算PC</span></span><br><span class="line">    pc = calculatePC()</span><br><span class="line">    <span class="comment">// 指令解码</span></span><br><span class="line">    opcode = bytecode[pc]</span><br><span class="line">    inst = createInst(opcode)</span><br><span class="line">    inst.fetchOperands(bytecode)</span><br><span class="line">    <span class="comment">// 指令执行</span></span><br><span class="line">    inst.execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-指令接口"><a href="#2-2-指令接口" class="headerlink" title="2.2 指令接口"></a>2.2 指令接口</h3><p>根据上述的伪代码，创建指令接口 <code>Instruction</code>，作为所有指令实现的基本接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口包括2个方法：取数（<code>fetchOperands</code>）和执行（<code>execute</code>）。</p>
<h3 id="2-2-指令解码"><a href="#2-2-指令解码" class="headerlink" title="2.2 指令解码"></a>2.2 指令解码</h3><p>接下来就是怎么把字节码解析成指令接口了。</p>
<p>因为需要操作字节，所以定义字节码读取类 <code>ByteCodeReader</code>，用于读取字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeReader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 字节码字节数组 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bytes;</span><br><span class="line">    <span class="comment">/** 字节缓冲读取 */</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteCodeReader</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        reset(bytes, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bytes = bytes;</span><br><span class="line">        buf = ByteBuffer.wrap(bytes);</span><br><span class="line">        buf.order(ByteOrder.BIG_ENDIAN); <span class="comment">// 大端</span></span><br><span class="line">        buf.position(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buf.position();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buf.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buf.getShort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buf.getInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readByte();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uint8 <span class="title">readUint8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b = buf.get();</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0x0FF</span> &amp; b;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Uint8(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readShort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uint16 <span class="title">readUint16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">short</span> s = buf.getShort();</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0x0FFFF</span> &amp; s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Uint16(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uint32 <span class="title">readUint32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = buf.getInt();</span><br><span class="line">        <span class="keyword">long</span> val = <span class="number">0x0FFFFFFFFL</span> &amp; i;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Uint32(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes(Uint32 length) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>) length.value();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        buf.get(bytes);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipPadding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (getPosition() % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            readUint8();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bytes</code> 存放原始的字节码字节数组，<code>buf</code> 是 java 中的 <code>ByteBuffer</code> 类对象，可以对字节进行操作。</p>
<p>因为有些数据是占用不止1个机器字的，所以需要定义字节数组是大端，还是小端，这里设定是大端。</p>
<p><code>getPosition()</code> 可用于获取当前读到的位置，这个主要是用于后面程序计数器 PC 的定位。</p>
<p>剩余的则是读取不同数据格式的方法，和 classfile 的读取差不多。</p>
<h2 id="三、指令集"><a href="#三、指令集" class="headerlink" title="三、指令集"></a>三、指令集</h2><h3 id="3-1-抽象指令基类"><a href="#3-1-抽象指令基类" class="headerlink" title="3.1 抽象指令基类"></a>3.1 抽象指令基类</h3><p>接口包括2个方法：取数（<code>fetchOperands</code>）和执行（<code>execute</code>）。</p>
<p>很多指令都具有相同的操作数类型，所以定义一些基类来方便实现。</p>
<p>有些指令是没有操作数的，定义一个无操作数基类 <code>NoOperandsInstruction</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoOperandsInstruction</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些指令需要访问局部变量表，局部变量表索引是一个8位无符号整数，定义一个基类 <code>Index8Instruction</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index8Instruction</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">protected</span> Uint8 source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        source = reader.readUint8();</span><br><span class="line">        index = source.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些指令需要访问常量池，常量池索引是一个16位无符号整数，定义一个基类 <code>Index16Instruction</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index16Instruction</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">protected</span> Uint16 source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        source = reader.readUint16();</span><br><span class="line">        index = source.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有跳转指令，它的操作数是16位无符号整数，定义基类 <code>BranchInstruction</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BranchInstruction</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 16位有符号整数偏移 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意是16位有符号整数</span></span><br><span class="line">        offset = reader.readShort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指令跳转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frame 栈帧</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">branch</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pc = frame.getThread().getPc();</span><br><span class="line">        frame.setNextPc(pc + offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-常量（constants）指令"><a href="#3-2-常量（constants）指令" class="headerlink" title="3.2 常量（constants）指令"></a>3.2 常量（constants）指令</h3><p>常量指令，把常量推入操作数栈顶。</p>
<p>常量的来源有3个：</p>
<ul>
<li>隐含在操作码</li>
<li>操作数</li>
<li>运行时常量池</li>
</ul>
<p>下面是这几种常量来源的具体实现。</p>
<h4 id="3-2-1-隐含在操作码的常量"><a href="#3-2-1-隐含在操作码的常量" class="headerlink" title="3.2.1 隐含在操作码的常量"></a>3.2.1 隐含在操作码的常量</h4><p>所谓的隐含在操作码里，实际上指令绑定了常量，在助记符里就能看出来常量值。</p>
<p>比如指令 <code>iconst_3</code>，就是整数常量3；<code>iconst_m1</code> 就是整数常量-1；<code>dconst_1</code> 就是双精度浮点数1。</p>
<p>这种隐含在操作码的指定，有15条：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aconst_null</span><br><span class="line">iconst_m1</span><br><span class="line">iconst_0</span><br><span class="line">iconst_1</span><br><span class="line">iconst_2</span><br><span class="line">iconst_3</span><br><span class="line">iconst_4</span><br><span class="line">iconst_5</span><br><span class="line">lconst_0</span><br><span class="line">lconst_1</span><br><span class="line">fconst_0</span><br><span class="line">fconst_1</span><br><span class="line">fconst_2</span><br><span class="line">dconst_0</span><br><span class="line">dconst_1</span><br></pre></td></tr></table></figure>

<p>指令这些隐藏常量，是因为这些常量比较常用，懒得浪费1个字节去额外存储。</p>
<p><code>aconst_null</code> 指令把 <code>null</code> 引用推入操作数栈顶：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AConstNull</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().pushRef(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iconst_m1</code> 指令把 <code>int</code> 型 -1 推入操作数栈顶：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IConstM1</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().pushInt(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dconst_0</code> 指令把 <code>double</code> 型 0 推入操作数栈顶：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DConst0</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().pushDouble(<span class="number">0.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余常量指令代码都差不多，只是值不同，不再列出。</p>
<h4 id="3-2-2-操作数常量"><a href="#3-2-2-操作数常量" class="headerlink" title="3.2.2 操作数常量"></a>3.2.2 操作数常量</h4><p>有2个指令，是把操作数当作常量，放入操作数栈中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bipush</span><br><span class="line">sipush</span><br></pre></td></tr></table></figure>

<p><code>bipush</code> 是从操作数中读取一个 <code>byte</code> 整数，放入操作数栈中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIPush</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().pushInt(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意是8位有符号整数</span></span><br><span class="line">        val = reader.readInt8();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sipush</code> 是从操作数中读取一个 <code>short</code> 整数，放入操作数栈中；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SIPush</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().pushInt(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意是16位有符号整数</span></span><br><span class="line">        val = reader.readInt16();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>bipush</code> 和 <code>sipush</code> 的操作数都是有符号整数。</p>
<h4 id="3-2-3-常量池常量"><a href="#3-2-3-常量池常量" class="headerlink" title="3.2.3 常量池常量"></a>3.2.3 常量池常量</h4><p>还有几条指令，是从常量池中获取常量，放入操作数栈中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idc</span><br><span class="line">idcw</span><br><span class="line">idc2w</span><br></pre></td></tr></table></figure>

<p><code>idc</code> 的操作数是8位无符号整数，用于获取 <code>int</code>、<code>float</code> 这些类型的常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDC</span> <span class="keyword">extends</span> <span class="title">Index8Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        OperandStack stack = frame.getOpStack();</span><br><span class="line">        ConstantPool cp = frame.getMethod().getClazz().getConstantPool();</span><br><span class="line">        Constant constant = cp.getConstant(index);</span><br><span class="line">        <span class="keyword">if</span> (constant <span class="keyword">instanceof</span> IntegerConstant) &#123;</span><br><span class="line">            stack.pushInt(((IntegerConstant) constant).value());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constant <span class="keyword">instanceof</span> FloatConstant) &#123;</span><br><span class="line">            stack.pushFloat(((FloatConstant) constant).value());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Unsupported Type: &quot;</span> + constant);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>idcw</code> 的操作数是16位无符号整数，用于获取 <code>int</code>、<code>float</code> 这些类型的常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCW</span> <span class="keyword">extends</span> <span class="title">Index16Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        OperandStack stack = frame.getOpStack();</span><br><span class="line">        ConstantPool cp = frame.getMethod().getClazz().getConstantPool();</span><br><span class="line">        Constant constant = cp.getConstant(index);</span><br><span class="line">        <span class="keyword">if</span> (constant <span class="keyword">instanceof</span> IntegerConstant) &#123;</span><br><span class="line">            stack.pushInt(((IntegerConstant) constant).value());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constant <span class="keyword">instanceof</span> FloatConstant) &#123;</span><br><span class="line">            stack.pushFloat(((FloatConstant) constant).value());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Unsupported Type: &quot;</span> + constant);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>idc2w</code> 的操作数是16位无符号整数，用于获取 <code>long</code>、<code>double</code> 类型的常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDC2W</span> <span class="keyword">extends</span> <span class="title">Index16Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        OperandStack stack = frame.getOpStack();</span><br><span class="line">        ConstantPool cp = frame.getMethod().getClazz().getConstantPool();</span><br><span class="line">        Constant constant = cp.getConstant(index);</span><br><span class="line">        <span class="keyword">if</span> (constant <span class="keyword">instanceof</span> LongConstant) &#123;</span><br><span class="line">            stack.pushLong(((LongConstant) constant).value());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constant <span class="keyword">instanceof</span> DoubleConstant) &#123;</span><br><span class="line">            stack.pushDouble(((DoubleConstant) constant).value());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassFormatError(<span class="string">&quot;Constant: &quot;</span> + constant);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>idc</code>、<code>idcw</code> 的作用差不多，只是操作数的范围不一样。</p>
<p><code>idc2w</code> 是专门用于 <code>long</code>、<code>double</code> 这种双字类型的指令。</p>
<h3 id="3-3-加载（loads）指令"><a href="#3-3-加载（loads）指令" class="headerlink" title="3.3 加载（loads）指令"></a>3.3 加载（loads）指令</h3><p>加载指令，负责从局部变量表获取变量，然后推入操作数栈顶。</p>
<p>加载指令共33条。</p>
<p>按照操作数类型分的话，可以分为6种：</p>
<ul>
<li>aload 系列指令：操作引用类型变量</li>
<li>dload 系列指令：操作 double 类型变量</li>
<li>fload 系列指令：操作 float 变量</li>
<li>iload 系列指令：操作 int 变量</li>
<li>lload 系列指令：操作 long 变量</li>
<li>xaload 系列指令：操作数组变量</li>
</ul>
<p>实际上各个加载指令都差不多，只是操作数的类型不同。</p>
<p>从局部变量表中获取变量，需要指定变量索引，索引的来源有2个：</p>
<ul>
<li>隐含在操作码中</li>
<li>操作数</li>
</ul>
<p>这2种来源和前面的常量指令差不多。</p>
<p>这里给几个例子：</p>
<p><code>iload_1</code> 指令，把局部变量表中的 1 号整型变量，推入操作数栈中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ILoad1</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().pushInt(frame.getLocalVars().getInt(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dload_2</code> 指令，把局部变量表中的 2 号 <code>double</code> 变量，推入操作数栈中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLoad2</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().pushDouble(frame.getLocalVars().getDouble(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lload</code> 指令，从操作数中获取索引 index，根据索引去局部变量表中加载第 index 号的 <code>long</code> 变量，推入操作数栈中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LLoad</span> <span class="keyword">extends</span> <span class="title">Index8Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// index 是 Index8Instruction 读取的8位无符号整数</span></span><br><span class="line">        frame.getOpStack().pushLong(frame.getLocalVars().getLong(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的指令还有 <code>iload</code>、<code>fload</code>、<code>dload</code>、<code>aload</code> 等。</p>
<p>需要注意，<code>long</code>、<code>double</code> 类型实际上是会占用局部变量表和操作数栈的2个插槽 Slot 的，之前已经封装好了。</p>
<h3 id="3-4-存储（stores）指令"><a href="#3-4-存储（stores）指令" class="headerlink" title="3.4 存储（stores）指令"></a>3.4 存储（stores）指令</h3><p>存储指令，负责从操作数栈中弹出变量，放入局部变量表中。</p>
<p>存储指令和加载指令是反过来操作的，所以指令都差不多，实现也就是反过来就行。</p>
<p>这里给几个例子：</p>
<p><code>astore_0</code> 指令，从操作数栈中弹出引用变量，放入局部变量表的 0 号位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AStore0</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getLocalVars().setRef(<span class="number">0</span>, frame.getOpStack().popRef());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fstore_2</code> 指令，从操作数栈中弹出 <code>float</code> 变量，放入局部变量表的 2 号位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FStore2</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getLocalVars().setFloat(<span class="number">2</span>, frame.getOpStack().popFloat());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dstore</code> 指令，在操作数中获取索引 index，从操作数栈中弹出 <code>double</code> 变量，放入局部变量表的 index 号位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DStore</span> <span class="keyword">extends</span> <span class="title">Index8Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// index 是 Index8Instruction 读取的8位无符号整数</span></span><br><span class="line">        frame.getLocalVars().setDouble(index, frame.getOpStack().popDouble());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余指令实现都差不多，基本是和加载指令反过来而已。</p>
<h3 id="3-5-操作数栈（stack）指令"><a href="#3-5-操作数栈（stack）指令" class="headerlink" title="3.5 操作数栈（stack）指令"></a>3.5 操作数栈（stack）指令</h3><p>操作数栈指令，是直接对操作数栈中的数据进行操作。</p>
<p>共9条，包括：</p>
<ul>
<li>弹出指令：pop 系列指令将栈顶变量弹出</li>
<li>复制指令：dup 系列指令复制栈顶变量</li>
<li>交换指令：swap 指令交换栈顶的两个变量</li>
</ul>
<p>操作数栈指令，直接操作的是插槽 Slot，所以并不关系里面数据的类型。</p>
<p>因为只操作 Slot，所以需要给 OperandStack 增加2个操作 Slot 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushSlot</span><span class="params">(Slot slot)</span> </span>&#123;</span><br><span class="line">        slots[size].setSlot(slot);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Slot <span class="title">popSlot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size--;</span><br><span class="line">        Slot slot = slots[size];</span><br><span class="line">        Slot copySlot = <span class="keyword">new</span> Slot(slot);</span><br><span class="line">        slot.setSlot(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> copySlot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的弹出 Slot 和推入 Slot，实际上并不是直接替换 Slot 对象，而是改变了它里面的值。</p>
<p>这是为了保证 Slot 对象一直存在，用于占位，避免空指针异常。</p>
<h4 id="3-5-1-弹出指令"><a href="#3-5-1-弹出指令" class="headerlink" title="3.5.1 弹出指令"></a>3.5.1 弹出指令</h4><p>弹出指令包括 <code>pop</code> 和 <code>pop2</code>。</p>
<p><code>pop</code> 指令用于弹出 <code>int</code>、<code>float</code> 等占用1个插槽位置的变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pop</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().popSlot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pop2</code> 指令用于弹出 <code>long</code>、<code>double</code> 等占用2个插槽位置的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pop2</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().popSlot();</span><br><span class="line">        frame.getOpStack().popSlot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-5-2-复制指令"><a href="#3-5-2-复制指令" class="headerlink" title="3.5.2 复制指令"></a>3.5.2 复制指令</h4><p>复制指令，用于复制操作数栈的变量。</p>
<p><code>dup</code> 指令是复制栈顶的单个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dup</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Slot slot = frame.getOpStack().popSlot();</span><br><span class="line">        frame.getOpStack().pushSlot(slot);</span><br><span class="line">        frame.getOpStack().pushSlot(slot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dup2</code> 指令是复制栈顶的2个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dup2</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Slot slot1 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot2 = frame.getOpStack().popSlot();</span><br><span class="line">        frame.getOpStack().pushSlot(slot2);</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">        frame.getOpStack().pushSlot(slot2);</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dupx1</code> 指令是复制栈顶的单个变量，但复制变量不是推入栈顶，具体看实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DupX1</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Slot slot1 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot2 = frame.getOpStack().popSlot();</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">        frame.getOpStack().pushSlot(slot2);</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dupx2</code> 指令是复制栈顶的单个变量，但复制变量不是推入栈顶，具体看实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DupX2</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Slot slot1 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot2 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot3 = frame.getOpStack().popSlot();</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">        frame.getOpStack().pushSlot(slot3);</span><br><span class="line">        frame.getOpStack().pushSlot(slot2);</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dup2x1</code> 指令是复制栈顶的2个变量，但复制变量不是推入栈顶，具体看实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dup2X1</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Slot slot1 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot2 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot3 = frame.getOpStack().popSlot();</span><br><span class="line">        frame.getOpStack().pushSlot(slot2);</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">        frame.getOpStack().pushSlot(slot3);</span><br><span class="line">        frame.getOpStack().pushSlot(slot2);</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dup2x2</code> 指令是复制栈顶的2个变量，但复制变量不是推入栈顶，具体看实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dup2X2</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Slot slot1 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot2 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot3 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot4 = frame.getOpStack().popSlot();</span><br><span class="line">        frame.getOpStack().pushSlot(slot2);</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">        frame.getOpStack().pushSlot(slot4);</span><br><span class="line">        frame.getOpStack().pushSlot(slot3);</span><br><span class="line">        frame.getOpStack().pushSlot(slot2);</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了 <code>dup</code>、<code>dup2</code>，其他几个指令还是挺麻烦的。</p>
<h4 id="3-5-3-交换指令"><a href="#3-5-3-交换指令" class="headerlink" title="3.5.3 交换指令"></a>3.5.3 交换指令</h4><p>交换指令，负责交换操作数栈的2个变量。</p>
<p>只有1条指令 <code>swap</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swap</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Slot slot1 = frame.getOpStack().popSlot();</span><br><span class="line">        Slot slot2 = frame.getOpStack().popSlot();</span><br><span class="line">        frame.getOpStack().pushSlot(slot1);</span><br><span class="line">        frame.getOpStack().pushSlot(slot2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-6-数学（math）指令"><a href="#3-6-数学（math）指令" class="headerlink" title="3.6 数学（math）指令"></a>3.6 数学（math）指令</h3><p>数学指令，包括算术（加、减、乘、除）、位移、布尔、自增等基本指令。</p>
<p>共 37 条。</p>
<p>数学指令，都是先从操作数栈中弹出变量，执行数学运算后，再把结果推回操作数栈。</p>
<p>这里给几个例子：</p>
<p>算术指令，整数加法指令 <code>idd</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IAdd</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">int</span> val2 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">int</span> val = val2 + val1;</span><br><span class="line">        frame.getOpStack().pushInt(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算术指令，<code>double</code> 类型减法指令 <code>dsub</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DSub</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> val1 = frame.getOpStack().popDouble();</span><br><span class="line">        <span class="keyword">double</span> val2 = frame.getOpStack().popDouble();</span><br><span class="line">        <span class="keyword">double</span> val = val2 - val1;</span><br><span class="line">        frame.getOpStack().pushDouble(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位移指令，<code>int</code> 整型左移指令 <code>ishl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IShl</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">int</span> val2 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">int</span> val = val2 &lt;&lt; (val1 &amp; <span class="number">0x1f</span>);</span><br><span class="line">        frame.getOpStack().pushInt(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位移指令，<code>long</code> 长整型无符号右移指令 <code>lushr</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LUShr</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意位移操作数是一个int类型的</span></span><br><span class="line">        <span class="keyword">int</span> val1 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">long</span> val2 = frame.getOpStack().popLong();</span><br><span class="line">        <span class="keyword">long</span> val = val2 &gt;&gt;&gt; (val1 &amp; <span class="number">0x3f</span>);</span><br><span class="line">        frame.getOpStack().pushLong(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布尔指令，<code>int</code> 整型按位或指令 <code>or</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOr</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">int</span> val2 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">int</span> val = val2 | val1;</span><br><span class="line">        frame.getOpStack().pushInt(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自增指令 <code>iinc</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IInc</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部变量索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint8 index;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = frame.getLocalVars().getInt(index.value());</span><br><span class="line">        val += value;</span><br><span class="line">        frame.getLocalVars().setInt(index.value(), val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        index = reader.readUint8();</span><br><span class="line">        <span class="comment">// 注意这是一个8位的有符号整数</span></span><br><span class="line">        value = reader.readInt8();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数学指令还是比较简单的，不过像自增指令 <code>iinc</code> 就需要特别注意操作数类型。</p>
<h3 id="3-7-转换（conversions）指令"><a href="#3-7-转换（conversions）指令" class="headerlink" title="3.7 转换（conversions）指令"></a>3.7 转换（conversions）指令</h3><p>转换指令，是指对类型进行强制转换，比如 <code>double</code> 转 <code>long</code>，<code>float</code> 转 <code>int</code> 等。</p>
<p>共15条，这里暂时实现基本类型的转换。</p>
<p>引用类型的强制转换，会走 <code>checkcast</code> 指令，这里还没有办法实现。</p>
<p>这里给出几个例子：</p>
<p><code>i2x</code> 系列指令，<code>i2l</code> 是 <code>int</code> 转 <code>long</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I2L</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = frame.getOpStack().popInt();</span><br><span class="line">        frame.getOpStack().pushLong(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>l2x</code> 系列指令，<code>l2d</code> 是 <code>long</code> 转 <code>double</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">L2D</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = frame.getOpStack().popLong();</span><br><span class="line">        <span class="keyword">double</span> d = (<span class="keyword">double</span>) l;</span><br><span class="line">        frame.getOpStack().pushDouble(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>f2x</code> 系列指令，<code>f2i</code> 是 <code>float</code> 转 <code>int</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F2I</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> f = frame.getOpStack().popFloat();</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>) f;</span><br><span class="line">        frame.getOpStack().pushInt(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换类型没什么特别的，都比较简单。</p>
<h3 id="3-8-比较（comparisons）指令"><a href="#3-8-比较（comparisons）指令" class="headerlink" title="3.8 比较（comparisons）指令"></a>3.8 比较（comparisons）指令</h3><p>比较指令，是比较变量的值，然后做出指定的操作。</p>
<p>共 19 条。</p>
<p>比较指令可分为2类：</p>
<ul>
<li>比较后，结果推入操作数栈顶</li>
<li>比较后，根据结果跳转</li>
</ul>
<p>比较指令主要用于实现 <code>if-else</code>、<code>for</code>、<code>while</code> 等语句。</p>
<h4 id="3-8-1-结果推入操作数栈"><a href="#3-8-1-结果推入操作数栈" class="headerlink" title="3.8.1 结果推入操作数栈"></a>3.8.1 结果推入操作数栈</h4><p>比较返回结果的指令有5条：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lcmp</span><br><span class="line">fcmpg</span><br><span class="line">fcmpl</span><br><span class="line">dcmpg</span><br><span class="line">dcmpl</span><br></pre></td></tr></table></figure>

<p><code>lcmp</code> 指令用于比较 <code>long</code> 变量，并将结果（<code>int</code> 类型的-1/0/1）推入操作数栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LCmp</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> v2 = frame.getOpStack().popLong();</span><br><span class="line">        <span class="keyword">long</span> v1 = frame.getOpStack().popLong();</span><br><span class="line">        <span class="keyword">int</span> v = CmpUtil.cmpLong(v1, v2);</span><br><span class="line">        frame.getOpStack().pushInt(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于浮点数计算有可能产生 <code>NaN</code>（Not a Number）值，所以比较两个浮点数时，除了大于、等于、小于之外，还有第4种结果：无法比较。</p>
<p><code>fcmpg</code> 和 <code>fcmpl</code> 指令都是用于比较 float 变量，意义都差不多。</p>
<p><code>fcmpg</code> 和 <code>fcmpl</code> 指令的区别就在于对第4种结果（无法比较）的定义。</p>
<p>两个 · 变量中至少有一个是 <code>NaN</code> 时，用 <code>fcmpg</code> 指令比较的结果是1，而用 <code>fcmpl</code> 指令比较的结果是-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FCmpg</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> v2 = frame.getOpStack().popFloat();</span><br><span class="line">        <span class="keyword">float</span> v1 = frame.getOpStack().popFloat();</span><br><span class="line">        <span class="keyword">int</span> v = CmpUtil.cmpFloat(v1, v2, <span class="keyword">true</span>);</span><br><span class="line">        frame.getOpStack().pushInt(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FCmpl</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> v2 = frame.getOpStack().popFloat();</span><br><span class="line">        <span class="keyword">float</span> v1 = frame.getOpStack().popFloat();</span><br><span class="line">        <span class="keyword">int</span> v = CmpUtil.cmpFloat(v1, v2, <span class="keyword">false</span>);</span><br><span class="line">        frame.getOpStack().pushInt(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面几个命令有用到的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CmpUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmpLong</span><span class="params">(<span class="keyword">long</span> v1, <span class="keyword">long</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.compare(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmpFloat</span><span class="params">(<span class="keyword">float</span> v1, <span class="keyword">float</span> v2, <span class="keyword">boolean</span> gFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v1 &gt; v2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1 &lt; v2) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dcmpg</code> 和 <code>dcmpl</code> 指令用来比较 <code>double</code> 变量，它们的意义和 <code>fcmpg</code>、<code>fcmpl</code> 指令一样，这里不再给出。</p>
<h4 id="3-8-2-比较跳转"><a href="#3-8-2-比较跳转" class="headerlink" title="3.8.2 比较跳转"></a>3.8.2 比较跳转</h4><p>比较跳转的指令有14条，可以分为2类：</p>
<ul>
<li>单操作数指令：<code>if&lt;cond&gt;</code> 指令</li>
<li>双操作数指令：<code>if_icmp&lt;cond&gt;</code> 和 <code>if_acmp&lt;cond&gt;</code> 指令</li>
</ul>
<p>单操作数 <code>if&lt;cond&gt;</code> 指令，是从栈顶弹出一个 <code>int</code> 整型变量和 0 进行比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifeq: x == 0</span><br><span class="line">ifne: x != 0</span><br><span class="line">iflt: x &lt; 0</span><br><span class="line">ifle: x &lt;= 0</span><br><span class="line">ifgt: x &gt; 0</span><br><span class="line">ifge: x &gt;= 0</span><br></pre></td></tr></table></figure>

<p>实现很简单，<code>ifeq</code> 指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfEq</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="number">0</span>) &#123;</span><br><span class="line">            branch(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ifle</code> 指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfLe</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">if</span> (v1 &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            branch(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他指令类似，不在举例。</p>
<p>双操作数指令 <code>if_icmp&lt;cond&gt;</code>，用于从栈顶弹出2个 <code>int</code> 整型变量进行比较，然后跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if_icmpeq: if x1 == x2</span><br><span class="line">if_icmpne: if x1 != x2</span><br><span class="line">if_icmplt: if x1 &lt; x2</span><br><span class="line">if_icmple: if x1 &lt;= x2</span><br><span class="line">if_icmpgt: if x1 &gt; x2</span><br><span class="line">if_icmpge: if x1 &gt;= x2</span><br></pre></td></tr></table></figure>

<p><code>if_icmpne</code> 指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfICmpNe</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v2 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">int</span> v1 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">if</span> (v1 != v2) &#123;</span><br><span class="line">            branch(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if_icmpgt</code> 指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfICmpGt</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v2 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">int</span> v1 = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">if</span> (v1 &gt; v2) &#123;</span><br><span class="line">            branch(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双操作数指令 <code>if_acmp&lt;cond&gt;</code>，也是从栈顶弹出2个变量，不过是引用变量，引用变量的比较只有2种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if_acmpeq: if x1 == x2</span><br><span class="line">if_acmpne: if x1 != x2</span><br></pre></td></tr></table></figure>

<p><code>if_acmpeq</code> 指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfACmpEq</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Object v2 = frame.getOpStack().popRef();</span><br><span class="line">        Object v1 = frame.getOpStack().popRef();</span><br><span class="line">        <span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line">            branch(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if_acmpne</code> 指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfACmpNe</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Object v2 = frame.getOpStack().popRef();</span><br><span class="line">        Object v1 = frame.getOpStack().popRef();</span><br><span class="line">        <span class="keyword">if</span> (v1 != v2) &#123;</span><br><span class="line">            branch(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-9-控制（control）指令"><a href="#3-9-控制（control）指令" class="headerlink" title="3.9 控制（control）指令"></a>3.9 控制（control）指令</h3><p>控制指令，主要用于地址的直接跳转。</p>
<p>比如 <code>return</code>、<code>goto</code>、<code>switch</code> 等语句的实现。</p>
<p>包括的指令有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goto</span><br><span class="line">tableswitch</span><br><span class="line">lookupswitch</span><br><span class="line">ireturn</span><br><span class="line">lreturn</span><br><span class="line">freturn</span><br><span class="line">dreturn</span><br><span class="line">areturn</span><br></pre></td></tr></table></figure>

<p><code>return</code> 系列指令等后面再实现。</p>
<p><code>goto</code> 指令进行无条件跳转：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goto</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        branch(frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tableswitch</code> 指令和 <code>lookupswitch</code> 指令都是用于实现 <code>switch</code> 语句的：</p>
<ul>
<li><code>tableswitch</code> 指令：<code>case</code> 值可以编码成一个索引表</li>
<li><code>lookupswitch</code> 指令：<code>case</code> 值不可以编码成一个索引表</li>
</ul>
<p>什么时候 <code>case</code> 值可以编码成一个索引表？比如下面这2个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:  <span class="keyword">return</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种 <code>case</code> 值是大于等于 0 的值，可以作为索引，就会编译成 <code>tableswitch</code> 指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">100</span>: <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:  <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种存在负数的值，就不能用作索引，就会编译成 <code>lookupswitch</code> 指令。</p>
<p><code>tableswitch</code> 指令的实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableSwitch</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> defaultOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> low;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] jumpOffsets;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = frame.getOpStack().popInt();</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= low &amp;&amp; index &lt;= high) &#123;</span><br><span class="line">            offset = jumpOffsets[index - low];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            offset = defaultOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        branch(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        reader.skipPadding();</span><br><span class="line">        defaultOffset = reader.readInt();</span><br><span class="line">        low = reader.readInt();</span><br><span class="line">        high = reader.readInt();</span><br><span class="line">        <span class="keyword">int</span> jumpOffsetsCount = high - low + <span class="number">1</span>;</span><br><span class="line">        jumpOffsets = reader.readInts(jumpOffsetsCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>defaultOffset</code> 就是 <code>switch</code> 语句中的 <code>default</code> 语句，而 <code>low</code> 和 <code>high</code> 则是对应的 <code>case</code> 语句的范围。</p>
<p><code>jumpOffsets</code> 是一个索引表，里面存放 <code>high - low + 1</code> 个 <code>int</code> 值，对应各种 <code>case</code> 情况下，执行跳转所需的字节码偏移量。</p>
<p><code>tableswitch</code> 指令的操作数是从栈中弹出的，作为偏移量地址，如果在 <code>low</code> 和 <code>high</code> 范围内，则说明是 <code>case</code> 语句，否则是 <code>default</code> 语句。</p>
<p><code>tableswitch</code> 指令操作码的后面有 0~3 字节的 <code>padding</code>，这个是为了对齐地址用的，保证 <code>defaultOffset</code> 在字节码中的地址是4的倍数。</p>
<p>下面是 <code>lookupswitch</code> 指令的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LookupSwitch</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> defaultOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> npairs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] matchOffsets;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = frame.getOpStack().popInt();</span><br><span class="line">        offset = defaultOffset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; npairs * <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matchOffsets[i] == key) &#123;</span><br><span class="line">                offset = matchOffsets[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        branch(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        reader.skipPadding();</span><br><span class="line">        defaultOffset = reader.readInt();</span><br><span class="line">        npairs = reader.readInt();</span><br><span class="line">        matchOffsets = reader.readInts(npairs * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>defaultOffset</code> 也是默认的地址偏移量，<code>npairs</code> 表示有多少个 <code>case</code> 语句。</p>
<p>每个 <code>case</code> 语句都包括2部分内容：一个就是 <code>case</code> 的 key 值，比如前面的 100，一个是 <code>case</code> 代码的地址偏移量，表示跳转的偏移地址。</p>
<p><code>lookupswitch</code> 指令的操作数也是从栈中弹出，作为 <code>case</code> 的 <code>key</code> 去比较，找到则跳转到 <code>case</code> 对应的偏移地址，否则跳到 <code>default</code> 语句。</p>
<p><code>lookupswitch</code> 指令也有地址对齐的操作，和 <code>tableswitch</code> 指令作用一样。</p>
<h3 id="3-10-引用（references）指令"><a href="#3-10-引用（references）指令" class="headerlink" title="3.10 引用（references）指令"></a>3.10 引用（references）指令</h3><p>引用指令，是和字段访问、方法调用相关的指令。</p>
<p>这里暂不实现。</p>
<h3 id="3-11-扩展（extended）指令"><a href="#3-11-扩展（extended）指令" class="headerlink" title="3.11 扩展（extended）指令"></a>3.11 扩展（extended）指令</h3><p>扩展指令，是给一些操作数比较小的指令进行扩展。</p>
<p>扩展指令有3类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wide</span><br><span class="line">ifnull 和 ifnonnull</span><br><span class="line">goto_w</span><br></pre></td></tr></table></figure>

<h4 id="3-11-1-wide"><a href="#3-11-1-wide" class="headerlink" title="3.11.1 wide"></a>3.11.1 wide</h4><p><code>wide</code> 指令用于扩展操作索引的范围。</p>
<p>比如加载指令、存储指令等需要访问局部变量表的指令，索引用的都是 uint8 字节。</p>
<p>对于大部分方法来说，uint8 的大小已经足够满足了，但是不排除有些方法的局部变量表过大，所以才使用 <code>wide</code> 执行来扩展它们。</p>
<p>扩展的指令包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x15: iload</span><br><span class="line">0x16: lload</span><br><span class="line">0x17: fload</span><br><span class="line">0x18: dload</span><br><span class="line">0x19: aload</span><br><span class="line">0x36: istore</span><br><span class="line">0x37: lstore</span><br><span class="line">0x38: fstore</span><br><span class="line">0x39: dstore</span><br><span class="line">0x3a: astore</span><br><span class="line">0x84: iinc</span><br><span class="line">0xa9: ret</span><br></pre></td></tr></table></figure>

<p><code>wide</code> 指令只是增加了索引宽度，并不改变子指令操作。</p>
<p>比如，原来的加载指令 <code>iload</code> 操作数是一个 uint8 字节的索引，在 <code>wide</code> 指令中则是 uint16 的双字节索引：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WILoad</span> <span class="keyword">extends</span> <span class="title">Index16Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getOpStack().pushInt(frame.getLocalVars().getInt(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里换成了 <code>Index16Instruction</code> 基类，使用的是2字节的索引。</p>
<p>同理，<code>dstore</code> 指令也换成了双操作数索引：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WDStore</span> <span class="keyword">extends</span> <span class="title">Index16Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        frame.getLocalVars().setDouble(index, frame.getOpStack().popDouble());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自增指令 <code>iinc</code> 也是一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WIInc</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部变量索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 index;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = frame.getLocalVars().getInt(index.value());</span><br><span class="line">        val += value;</span><br><span class="line">        frame.getLocalVars().setInt(index.value(), val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        index = reader.readUint16();</span><br><span class="line">        <span class="comment">// 注意这里是16位有符号整数</span></span><br><span class="line">        value = reader.readInt16();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他指令类似，不再列出。</p>
<h4 id="3-11-2-ifnull-和-ifnonnul"><a href="#3-11-2-ifnull-和-ifnonnul" class="headerlink" title="3.11.2 ifnull 和 ifnonnul"></a>3.11.2 ifnull 和 ifnonnul</h4><p>和前面的比较指令差不多，<code>ifnull</code> 和 <code>ifnonnull</code> 就是用于比较 <code>null</code> 值并跳转的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfNull</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Object v1 = frame.getOpStack().popRef();</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            branch(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfNonNull</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        Object v1 = frame.getOpStack().popRef();</span><br><span class="line">        <span class="keyword">if</span> (v1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            branch(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-11-3-goto-w"><a href="#3-11-3-goto-w" class="headerlink" title="3.11.3 goto_w"></a>3.11.3 goto_w</h4><p>前面的 <code>goto</code> 指令操作数是 int16 位有符号整数，<code>goto_w</code> 指令则是扩展成 int32 位有符号整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WGoto</span> <span class="keyword">extends</span> <span class="title">BranchInstruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        branch(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(ByteCodeReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意是32位有符号整数</span></span><br><span class="line">        offset = reader.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-12-保留（reserved）指令"><a href="#3-12-保留（reserved）指令" class="headerlink" title="3.12 保留（reserved）指令"></a>3.12 保留（reserved）指令</h3><p>保留指令是留给虚拟机用的，这里暂时不实现。</p>
<h2 id="四、解释器"><a href="#四、解释器" class="headerlink" title="四、解释器"></a>四、解释器</h2><p>完成所有指令的解析之后，就可以实现一个简单的解释器，执行解析好的指令。</p>
<p>因为方法的调用，最后都会执行 <code>return</code> 语句，由于暂时未实现 <code>return</code> 语句，所以解释器目前只能执行一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(MethodInfo methodInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拿到方法的代码属性</span></span><br><span class="line">        CodeAttributeInfo codeAttr = methodInfo.getCodeAttributeInfo();</span><br><span class="line">        Uint16 maxLocals = codeAttr.getMaxLocals();</span><br><span class="line">        Uint16 maxStack = codeAttr.getMaxStack();</span><br><span class="line">        <span class="keyword">byte</span>[] codes = codeAttr.getCodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个栈帧测试</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        Frame frame = thread.newFrame(maxLocals.value(), maxStack.value());</span><br><span class="line">        thread.pushFrame(frame);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解释执行代码</span></span><br><span class="line">        loop(thread, codes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(Thread thread, <span class="keyword">byte</span>[] codes)</span> </span>&#123;</span><br><span class="line">        Frame frame = thread.popFrame();</span><br><span class="line">        ByteCodeReader reader = <span class="keyword">new</span> ByteCodeReader(codes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 程序计数器地址</span></span><br><span class="line">                <span class="keyword">int</span> pc = frame.getNextPc();</span><br><span class="line">                thread.setPc(pc);</span><br><span class="line">                reader.setPosition(pc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 编译识别指令</span></span><br><span class="line">                <span class="keyword">int</span> opcode = reader.readUint8().value();</span><br><span class="line">                Instruction instruction = InstructionFactory.newInstance(opcode);</span><br><span class="line">                <span class="keyword">if</span> (instruction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取指定操作数</span></span><br><span class="line">                instruction.fetchOperands(reader);</span><br><span class="line">                frame.setNextPc(reader.getPosition());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行指令</span></span><br><span class="line">                instruction.execute(frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Frame: &quot;</span> + frame);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释器的逻辑很简单：</p>
<ol>
<li>从指定方法中拿出 <code>code</code> 代码属性</li>
<li>根据指令集解析 <code>code</code> 代码的指令</li>
<li>执行解析好的指令</li>
</ol>
<p>由于没有实现 <code>return</code> 指令，所以不能很好的看出结果，而且执行到最后肯定会报错。</p>
<p>这里通过捕获错误，并打印栈帧来查看结果。</p>
<p><code>getCodeAttributeInfo()</code>、<code>getMaxLocals()</code> 这些都是 <code>MethodInfo</code> 新增的 <code>get</code> 方法，这里不多说。</p>
<p><code>InstructionFactory.newInstance(opcode)</code> 是根据字节码生成对应的指令，实现差不多这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstructionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instruction <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Nop();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x01</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AConstNull();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x02</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> IConstM1();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x03</span>:</span><br><span class="line">                .</span><br><span class="line">                .</span><br><span class="line">                .</span><br><span class="line">               ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太长了，这里就不全列举出来了。</p>
<p>还需要改造一下 Jvm 类的代码，让他可以跑指定的方法，这里执行的是 main 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Cmd cmd = <span class="keyword">new</span> Cmd();</span><br><span class="line">        cmd.printHelp();</span><br><span class="line"></span><br><span class="line">        String[] testArgs = <span class="keyword">new</span> String[]&#123; <span class="string">&quot;com.wjd.cmd.Cmd&quot;</span>, <span class="string">&quot;-classpath&quot;</span>,</span><br><span class="line">                <span class="string">&quot;D:\\Projects\\IdeaProjects\\self-jvm\\target\\test-classes;D:\\Projects\\IdeaProjects\\self-jvm\\target\\classes&quot;</span> &#125;;</span><br><span class="line">        cmd.parse(testArgs);</span><br><span class="line"></span><br><span class="line">        String userClassName = <span class="string">&quot;com\\wjd\\instructions\\InstructionsTest&quot;</span>;</span><br><span class="line">        Classpath classpath = <span class="keyword">new</span> Classpath(cmd.getJreOption(), cmd.getCpOption());</span><br><span class="line"></span><br><span class="line">        ClassFile classFile = loadClass(userClassName, classpath);</span><br><span class="line">        MethodInfo mainMethod = getMainMethod(classFile);</span><br><span class="line">        <span class="keyword">if</span> (mainMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解释器执行，解释执行 main 方法</span></span><br><span class="line">            <span class="keyword">new</span> Interpreter().interpret(mainMethod);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Not found main method!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassFile <span class="title">loadClass</span><span class="params">(String className, Classpath classpath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] userClassBytes = classpath.readClass(className);</span><br><span class="line">        ClassReader reader = <span class="keyword">new</span> ClassReader(userClassBytes);</span><br><span class="line">        <span class="keyword">return</span> ClassFile.parse(reader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取类文件中的main方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodInfo <span class="title">getMainMethod</span><span class="params">(ClassFile classFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (MethodInfo m : classFile.getMethods())</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(m.name()) &amp;&amp; <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>.equals(m.descriptor())) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改的内容就是找到测试类，拿出它的 main 方法，然后交给解释器 <code>Interpreter</code> 去解释执行。</p>
<h2 id="五、单元测试"><a href="#五、单元测试" class="headerlink" title="五、单元测试"></a>五、单元测试</h2><p>测试类，就是要测试执行它的 main 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstructionsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试应该会出现错误，在异常捕获里面，栈帧输出结果里面应该包含结果值 <code>5050</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="指令结构"><a href="#指令结构" class="headerlink" title="指令结构"></a>指令结构</h3><ul>
<li>字节码中存放编码后的 Java 虚拟机指令，每条指令都以一个单字节的操作码（opcode）开头</li>
<li>由于只使用一字节表示操作码，Java 虚拟机最多只能支持 256 条指令</li>
<li>Java 虚拟机使用的是变长指令，操作码后面可以跟零字节或多字节的操作数（operand）</li>
<li>比如 <code>0xB20002</code> 这条指令，<code>B2</code> 表示该指令的操作码，<code>0002</code> 就表示操作数</li>
</ul>
<h3 id="指令助记符"><a href="#指令助记符" class="headerlink" title="指令助记符"></a>指令助记符</h3><ul>
<li>为了便于记忆，Java 虚拟机规范给每个操作码都指定了一个助记符（mnemonic）</li>
<li>比如，操作码是 <code>0x00</code> 的助记符是 nop（no operation）</li>
<li>操作数栈和局部变量表只存放数据的值（Slot），并不记录数据类型</li>
<li>指令必须知道自己在操作什么类型的数据，即指令绑定了数据类型</li>
<li>例如，<code>iadd</code> 指令就是对 <code>int</code> 值进行加法操作</li>
</ul>
<h3 id="指令类型"><a href="#指令类型" class="headerlink" title="指令类型"></a>指令类型</h3><p>Java 虚拟机规范把已经定义的205条指令按用途分成了11类，分别是：</p>
<ul>
<li>常量（constants）指令</li>
<li>加载（loads）指令</li>
<li>存储（stores）指令</li>
<li>操作数栈（stack）指令</li>
<li>数学（math）指令</li>
<li>转换（conversions）指令</li>
<li>比较（comparisons）指令</li>
<li>控制（control）指令</li>
<li>引用（references）指令</li>
<li>扩展（extended）指令</li>
<li>保留（reserved）指令</li>
</ul>
<p>保留指令：</p>
<ul>
<li>1条是留给调试器的，用于实现断点，操作码是 <code>202(0xCA)</code>，助记符是 <code>breakpoint</code></li>
<li>另外2条留给 Java 虚拟机实现内部使用，操作码分别是 <code>254(0xFE)</code> 和 <code>266(0xFF)</code>，助记符是 <code>impdep1</code> 和 <code>impdep2</code></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>04_运行时数据区</title>
    <url>/lang/java/jvm/selfjvm/04_runtimedata/</url>
    <content><![CDATA[<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><p>在运行Java程序时，Java虚拟机需要使用内存来存放各式各样的数据。Java虚拟机规范把这些内存区域叫作运行时数据区。</p>
<p>运行时数据区可以分为两类：一类是多线程共享的，另一类则是线程私有的。</p>
<ul>
<li>多线程共享的运行时数据区需要在Java虚拟机启动时创建好，在Java虚拟机退出时销毁</li>
<li>线程私有的运行时数据区则在创建线程时才创建，线程退出时销毁</li>
</ul>
<span id="more"></span>

<p>多线程共享的内存区域主要存放两类数据：类数据和类实例（也就是对象）：</p>
<ul>
<li>类实例对象数据存放在堆（Heap）中</li>
<li>类数据存放在方法区（Method Area）中，类数据包括字段和方法信息、方法的字节码、运行时常量池等</li>
</ul>
<p>线程私有的运行时数据区用于辅助执行Java字节码。每个线程都有自己的pc寄存器（Program Counter）和Java虚拟机栈（JVMStack）。</p>
<p>Java虚拟机栈又由栈帧（Stack Frame，后面简称帧）构成，帧中保存方法执行的状态，包括局部变量表（Local Variable）和操作数栈（Operand Stack）等。</p>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p>Java虚拟机可以操作两类数据：基本类型（primitive type）和引用类型（reference type）。</p>
<p>基本类型的变量存放的就是数据本身，引用类型的变量存放的是对象引用，真正的对象数据是在堆里分配的。这里所说的变量包括类变量（静态字段）、实例变量（非静态字段）、数组元素、方法的参数和局部变量，等等。</p>
<p>基本类型可以进一步分为布尔类型（boolean type）和数字类型（numeric type），数字类型又可以分为整数类型（integral type）和浮点数类型（floating-point type）。</p>
<p>引用类型可以进一步分为3种：类类型、接口类型和数组类型。类类型引用指向类实例，数组类型引用指向数组实例，接口类型引用指向实现了该接口的类或数组实例。引用类型有一个特殊的值——null，表示该引用不指向任何对象。</p>
<h2 id="三、线程"><a href="#三、线程" class="headerlink" title="三、线程"></a>三、线程</h2><p>线程都有自己的pc寄存器（Program Counter）和Java虚拟机栈（JVMStack）。</p>
<p>定义一个线程类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 最大栈深度 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxStackSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 程序计数器  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pc;</span><br><span class="line">    <span class="comment">/** 虚拟机栈 */</span></span><br><span class="line">    <span class="keyword">private</span> JvmStack stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> JvmStack(maxStackSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPc</span><span class="params">(<span class="keyword">int</span> pc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pc = pc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushFrame</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        stack.push(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Frame <span class="title">popFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Frame <span class="title">currentFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>JvmStack</code> 是虚拟机栈，定义在后面给出。</p>
<h2 id="四、虚拟机栈"><a href="#四、虚拟机栈" class="headerlink" title="四、虚拟机栈"></a>四、虚拟机栈</h2><p>虚拟机栈就是一个栈结构，数据先入后出。虚拟机栈里面放的就是栈帧，表示每一个被调用的方法。</p>
<p>和堆一样，Java虚拟机规范对Java虚拟机栈的约束也相当宽松：</p>
<ul>
<li>Java虚拟机栈可以是连续的空间，也可以不连续；可以是固定大小，也可以在运行时动态扩展</li>
<li>如果Java虚拟机栈有大小限制，且执行线程所需的栈空间超出了这个限制，会导致StackOverflowError异常抛出</li>
<li>如果Java虚拟机栈可以动态扩展，但是内存已经耗尽，会导致OutOfMemoryError异常抛出</li>
</ul>
<p>因此可以采用单向链表的形式来实现虚拟机栈，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 最大栈深度 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">/** 当前栈深度 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">/** 栈顶对象 */</span></span><br><span class="line">    <span class="keyword">private</span> Frame top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JvmStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Frame frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= maxSize) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StackOverflowError(<span class="string">&quot;jvm stack is overflow: &quot;</span> + maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">        frame.setLower(top);</span><br><span class="line">        top = frame;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Frame <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;jvm stack is empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Frame val = top;</span><br><span class="line">        top = top.getLower();</span><br><span class="line">        val.setLower(<span class="keyword">null</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Frame <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;jvm stack is empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，栈帧 <code>Frame</code> 就作为单向链表的节点存在，栈顶就是单向链尾。</p>
<h2 id="五、栈帧"><a href="#五、栈帧" class="headerlink" title="五、栈帧"></a>五、栈帧</h2><p>栈帧表示的一个方法调用，里面包括了执行方法所需要的局部变量表和操作数栈。</p>
<p>执行方法所需的局部变量表大小和操作数栈深度是由编译器预先计算好的，存储在 class 文件 <code>method_info</code> 结构的 <code>Code</code> 属性中。</p>
<p>栈帧的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Frame</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 局部变量表 */</span></span><br><span class="line">    <span class="keyword">private</span> LocalVars localvars;</span><br><span class="line">    <span class="comment">/** 操作数栈 */</span></span><br><span class="line">    <span class="keyword">private</span> OperandStack operandStack;</span><br><span class="line">    <span class="comment">/** 指向下一个栈帧 */</span></span><br><span class="line">    <span class="keyword">private</span> Frame lower;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Frame</span><span class="params">(<span class="keyword">int</span> maxLocals, <span class="keyword">int</span> maxStack)</span> </span>&#123;</span><br><span class="line">        localvars = <span class="keyword">new</span> LocalVars(maxLocals);</span><br><span class="line">        operandStack = <span class="keyword">new</span> OperandStack(maxStack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Frame <span class="title">getLower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(Frame lower)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lower = lower;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、局部变量表"><a href="#六、局部变量表" class="headerlink" title="六、局部变量表"></a>六、局部变量表</h2><p>局部变量表是按索引访问的，可以把它想象成一个数组。</p>
<p>根据Java虚拟机规范，这个数组的每个元素至少可以容纳一个 <code>int</code> 或引用值，两个连续的元素可以容纳一个 <code>long</code> 或 <code>double</code> 值。</p>
<p>为了能够同时容纳一个 <code>int</code> 和引用值，这里采用以下结构作为局部变量表的数组元素类型，同时增加了一些静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 索引 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> num;</span><br><span class="line">    <span class="comment">/** 引用 */</span></span><br><span class="line">    <span class="keyword">private</span> Object ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRef</span><span class="params">(Object ref)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ref = ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(Slot slot, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        slot.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Slot slot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) slot.num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(Slot slot, <span class="keyword">float</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bits = Float.floatToIntBits(num);</span><br><span class="line">        setInt(slot, bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(Slot slot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bits = getInt(slot);</span><br><span class="line">        <span class="keyword">return</span> Float.intBitsToFloat(bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLong</span><span class="params">(Slot highSlot, Slot lowSlot, <span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// long类型占用2个插槽</span></span><br><span class="line">        highSlot.num = num &gt;&gt;&gt; <span class="number">32</span>;</span><br><span class="line">        lowSlot.num = num &amp; <span class="number">0x0FFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Slot highSlot, Slot lowSlot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// long类型占用2个插槽</span></span><br><span class="line">        <span class="keyword">long</span> lowerBits = lowSlot.num;</span><br><span class="line">        <span class="keyword">long</span> highBits = highSlot.num;</span><br><span class="line">        <span class="keyword">long</span> val = highBits &amp; <span class="number">0x0FFFFFFFFL</span>;</span><br><span class="line">        val = (val &lt;&lt; <span class="number">32</span>) | (lowerBits &amp; <span class="number">0x0FFFFFFFFL</span>);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(Slot highSlot, Slot lowSlot, <span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把double的bit转成long保存</span></span><br><span class="line">        <span class="keyword">long</span> bits = Double.doubleToLongBits(num);</span><br><span class="line">        setLong(highSlot, lowSlot, bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Slot highSlot, Slot lowSlot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把long的bit解析成double</span></span><br><span class="line">        <span class="keyword">long</span> bits = getLong(highSlot, lowSlot);</span><br><span class="line">        <span class="keyword">return</span> Double.longBitsToDouble(bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后局部变量表的定义则是这样的，实际就是对数组进行了一层封装，并提供了一些接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVars</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 局部变量数组的最大大小 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> defaultMaxLocals = <span class="number">65536</span>;</span><br><span class="line">    <span class="comment">/** 局部变量表数组 */</span></span><br><span class="line">    <span class="keyword">private</span> Slot[] slots;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalVars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(defaultMaxLocals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalVars</span><span class="params">(<span class="keyword">int</span> maxLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxLocals &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            maxLocals = defaultMaxLocals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一开始就把插槽初始化好</span></span><br><span class="line">        slots = <span class="keyword">new</span> Slot[maxLocals];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">            slots[i] = <span class="keyword">new</span> Slot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Slot.setInt(slots[index], num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Slot.getInt(slots[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">float</span> num)</span> </span>&#123;</span><br><span class="line">        Slot.setFloat(slots[index], num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Slot.getFloat(slots[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLong</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// long类型占用2个插槽</span></span><br><span class="line">        Slot.setLong(slots[index + <span class="number">1</span>], slots[index], num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// long类型占用2个插槽</span></span><br><span class="line">        <span class="keyword">return</span> Slot.getLong(slots[index + <span class="number">1</span>], slots[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// double类型占用2个插槽</span></span><br><span class="line">        Slot.setDouble(slots[index + <span class="number">1</span>], slots[index], num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// double类型占用2个插槽</span></span><br><span class="line">        <span class="keyword">return</span> Slot.getDouble(slots[index + <span class="number">1</span>], slots[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRef</span><span class="params">(<span class="keyword">int</span> index, Object ref)</span> </span>&#123;</span><br><span class="line">        slots[index].setRef(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getRef</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> slots[index].getRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>long</code> 和 <code>double</code> 这2种类型是占用了2个插槽的。</p>
<p><code>long</code> 类型可以拆成2个 <code>int</code> 类型保存。</p>
<p><code>float</code> 可以转成 <code>int</code> 类型保存，<code>double</code> 可以转成 <code>long</code> 类型保存。</p>
<h2 id="七、操作数栈"><a href="#七、操作数栈" class="headerlink" title="七、操作数栈"></a>七、操作数栈</h2><p>操作数栈和局部变量表类似，实际上操作数栈操作的数据，就是局部变量表里面的数据。</p>
<p>操作数栈的大小是编译器已经确定的，所以可以用 <code>Slot[]</code> 实现栈结构，其中栈顶就是 <code>slots[size - 1]</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 最大栈深度 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> defaultMaxStack = <span class="number">65536</span>;</span><br><span class="line">    <span class="comment">/** 操作数栈数组 */</span></span><br><span class="line">    <span class="keyword">private</span> Slot[] slots;</span><br><span class="line">    <span class="comment">/** 当前栈大小 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperandStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(defaultMaxStack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperandStack</span><span class="params">(<span class="keyword">int</span> maxStack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxStack &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            maxStack = defaultMaxStack;</span><br><span class="line">        &#125;</span><br><span class="line">        slots = <span class="keyword">new</span> Slot[maxStack];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">            slots[i] = <span class="keyword">new</span> Slot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInt</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Slot.setInt(slots[size], val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> Slot.getInt(slots[size]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushFloat</span><span class="params">(<span class="keyword">float</span> val)</span> </span>&#123;</span><br><span class="line">        Slot.setFloat(slots[size], val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">popFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> Slot.getFloat(slots[size]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushLong</span><span class="params">(<span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// long类型占用2个插槽</span></span><br><span class="line">        Slot.setLong(slots[size + <span class="number">1</span>], slots[size], val);</span><br><span class="line">        size += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">popLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// long类型占用2个插槽</span></span><br><span class="line">        size -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> Slot.getLong(slots[size + <span class="number">1</span>], slots[size]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushDouble</span><span class="params">(<span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// double类型占用2个插槽</span></span><br><span class="line">        Slot.setDouble(slots[size + <span class="number">1</span>], slots[size], val);</span><br><span class="line">        size += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">popDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// double类型占用2个插槽</span></span><br><span class="line">        size -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> Slot.getDouble(slots[size + <span class="number">1</span>], slots[size]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushRef</span><span class="params">(Object ref)</span> </span>&#123;</span><br><span class="line">        slots[size].setRef(ref);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">popRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size--;</span><br><span class="line">        Object ref = slots[size].getRef();</span><br><span class="line">        slots[size].setRef(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作数栈的实现和局部变量表的实现差不多，都是采用数组 <code>Slot[]</code>，所以操作数栈也需要对 <code>long</code> 和 <code>double</code> 进行特殊处理。</p>
<h2 id="八、单元测试"><a href="#八、单元测试" class="headerlink" title="八、单元测试"></a>八、单元测试</h2><p>局部变量表测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalVars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalVars localVars = <span class="keyword">new</span> LocalVars(<span class="number">100</span>);</span><br><span class="line">        localVars.setInt(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        localVars.setInt(<span class="number">1</span>, -<span class="number">100</span>);</span><br><span class="line">        localVars.setLog(<span class="number">2</span>, <span class="number">2997924580L</span>);</span><br><span class="line">        localVars.setLog(<span class="number">4</span>, -<span class="number">2997924580L</span>);</span><br><span class="line">        localVars.setFloat(<span class="number">6</span>, <span class="number">3.1415926F</span>);</span><br><span class="line">        localVars.setDouble(<span class="number">7</span>, <span class="number">2.71828182845</span>);</span><br><span class="line">        localVars.setRef(<span class="number">9</span>, <span class="keyword">this</span>);</span><br><span class="line">        System.out.println(localVars.getInt(<span class="number">0</span>));</span><br><span class="line">        System.out.println(localVars.getInt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(localVars.getLong(<span class="number">2</span>));</span><br><span class="line">        System.out.println(localVars.getLong(<span class="number">4</span>));</span><br><span class="line">        System.out.println(localVars.getFloat(<span class="number">6</span>));</span><br><span class="line">        System.out.println(localVars.getDouble(<span class="number">7</span>));</span><br><span class="line">        System.out.println(localVars.getRef(<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作数栈测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStackTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOperandStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OperandStack stack = <span class="keyword">new</span> OperandStack(<span class="number">100</span>);</span><br><span class="line">        stack.pushInt(<span class="number">100</span>);</span><br><span class="line">        stack.pushInt(-<span class="number">100</span>);</span><br><span class="line">        stack.pushLong(<span class="number">2997924580L</span>);</span><br><span class="line">        stack.pushLong(-<span class="number">2997924580L</span>);</span><br><span class="line">        stack.pushFloat(<span class="number">3.1415926F</span>);</span><br><span class="line">        stack.pushFloat(-<span class="number">3.1415926F</span>);</span><br><span class="line">        stack.pushDouble(<span class="number">2.71828182845</span>);</span><br><span class="line">        stack.pushDouble(-<span class="number">2.71828182845</span>);</span><br><span class="line">        stack.pushRef(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(stack.popRef());</span><br><span class="line">        System.out.println(stack.popDouble());</span><br><span class="line">        System.out.println(stack.popDouble());</span><br><span class="line">        System.out.println(stack.popFloat());</span><br><span class="line">        System.out.println(stack.popFloat());</span><br><span class="line">        System.out.println(stack.popLong());</span><br><span class="line">        System.out.println(stack.popLong());</span><br><span class="line">        System.out.println(stack.popInt());</span><br><span class="line">        System.out.println(stack.popInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据结构：</p>
<ul>
<li><p>运行时数据区可以分为两类：一类是多线程共享的，另一类则是线程私有的</p>
</li>
<li><p>多线程共享的运行时数据区需要在Java虚拟机启动时创建好，在Java虚拟机退出时销毁</p>
</li>
<li><p>线程私有的运行时数据区则在创建线程时才创建，线程退出时销毁</p>
</li>
<li><p>多线程共享的内存区域主要存放两类数据：类数据和类实例（也就是对象）</p>
</li>
<li><p>类实例对象数据存放在堆（Heap）中</p>
</li>
<li><p>类数据存放在方法区（Method Area）中，类数据包括字段和方法信息、方法的字节码、运行时常量池等</p>
</li>
</ul>
<p>数据类型：</p>
<ul>
<li>Java虚拟机可以操作两类数据：基本类型（primitive type）和引用类型（reference type）</li>
<li>基本类型的变量存放的就是数据本身，引用类型的变量存放的是对象引用，真正的对象数据是在堆里分配的</li>
<li>基本类型可以进一步分为布尔类型（boolean type）和数字类型（numeric type），数字类型又可以分为整数类型（integral type）和浮点数类型（floating-point type）</li>
<li>引用类型可以进一步分为3种：类类型、接口类型和数组类型。类类型引用指向类实例，数组类型引用指向数组实例，接口类型引用指向实现了该接口的类或数组实例</li>
</ul>
<p>线程结构：</p>
<ul>
<li>线程都有自己的pc寄存器（Program Counter）和Java虚拟机栈（JVMStack）</li>
<li>虚拟机栈就是一个栈结构，数据先入后出。虚拟机栈里面放的就是栈帧，表示每一个被调用的方法</li>
<li>Java虚拟机规范对虚拟机栈的约束相当宽松：<ul>
<li>Java虚拟机栈可以是连续的空间，也可以不连续；可以是固定大小，也可以在运行时动态扩展</li>
<li>如果Java虚拟机栈有大小限制，且执行线程所需的栈空间超出了这个限制，会导致StackOverflowError异常抛出</li>
<li>如果Java虚拟机栈可以动态扩展，但是内存已经耗尽，会导致OutOfMemoryError异常抛出</li>
</ul>
</li>
<li>局部变量表是按索引访问的，可以把它想象成一个数组</li>
<li>根据Java虚拟机规范，局部变量表的每个元素至少可以容纳一个 <code>int</code> 或引用值，两个连续的元素可以容纳一个 <code>long</code> 或 <code>double</code> 值</li>
<li>操作数栈的大小是编译器已经确定的</li>
<li>操作数栈实际操作的数据就是局部变量表里面的数据</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>02_操作符</title>
    <url>/lang/java/core/basic/02_operators/</url>
    <content><![CDATA[<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>Java 中的操作符有很多，大概可以分成以下几种：</p>
<ul>
<li>关系操作符：&gt;、&lt;、&gt;=、&lt;=、==、!=</li>
<li>逻辑操作符：!、&amp;、|、&amp;&amp;、||</li>
<li>条件操作符：?:</li>
<li>算术操作符：-、++、–、+、-、*、/、%</li>
<li>位操作符：~、&amp;、|、^、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</li>
<li>赋值操作符：=、+=、-=、*=、/=、&amp;=、|=、^=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</li>
</ul>
<span id="more"></span>

<h2 id="一、操作符优先级"><a href="#一、操作符优先级" class="headerlink" title="一、操作符优先级"></a>一、操作符优先级</h2><p>当一个表达式存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。</p>
<p>Java 中操作符的优先级共分为 14 级，其中 1 级最高，14 级最低。在表达式中操作符优先级高的优先执行。</p>
<p>下面是各种操作符的优先级和结合性：</p>
<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="left">操作符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">()、[]、{}</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">!、+、-、~、++、–</td>
<td align="left">从右至左</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">*、/、%</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">+、-</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">==、!=</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">&amp;</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">^</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">|</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">||</td>
<td align="left">从左至右</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">?:</td>
<td align="left">从右至左</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">=、+=、-=、*=、/=、&amp;=、|=、^=、~=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</td>
<td align="left">从右至左</td>
</tr>
</tbody></table>
<p>比如说，下面的表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--a &gt; <span class="number">0</span> || ++b &lt;= <span class="number">1</span> &amp;&amp; c * d &gt; <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>然后根据表中的优先级，它的实际计算顺序应该是这样的：</p>
<ol>
<li>先计算a的自减，即 <code>--a</code></li>
<li>再计算 <code>--a &gt; 0</code> 的结果</li>
<li>再计算b的自增，即 <code>++b</code></li>
<li>接着计算 <code>++b &lt;= 1</code> 的结果</li>
<li>然后计算c、d的乘法，即 <code>c * d</code></li>
<li>再计算 <code>c * d &gt; 100</code> 的结果</li>
<li>由于 <code>&amp;&amp;</code> 优先级比 <code>||</code> 高，所以再接着是计算 <code>++b &lt;= 1 &amp;&amp; c * d &gt; 100</code> 的结果</li>
<li>最后则是将2的结果和7的结果进行逻辑或（<code>||</code>）运算，即计算 <code>--a &gt; 0 || ++b &lt;= 1 &amp;&amp; c * d &gt; 100</code> 的结果</li>
</ol>
<p>实际上，不建议直接写这种混合了多种优先级的表达式，因为一旦混合在一起后，就很难识别它们的优先级了。</p>
<p>对于复杂的表达式，一般建议按照以下操作去修改，方便理解：</p>
<ul>
<li>尽量不要在一个表达式中混合使用多种不同优先级的操作符</li>
<li>不要写过于复杂的表达式，而是建议把它分成几个简单表达式</li>
<li>不要过多地依赖操作符的优先级来控制表达式的执行顺序，尽量使用小括号 <code>()</code> 来控制表达式的执行顺序</li>
</ul>
<p>就比如上面的表达式，为了方便理解，可以给它加上小括号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((--a) &gt; <span class="number">0</span>) || ((++b) &lt;= <span class="number">1</span> &amp;&amp; (c * d) &gt; <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>虽然小括号不是必须的，但是加上之后，表达式理解起来反而更加容易了，很简单就能识别出各个部分的优先级。</p>
<h2 id="二、关系操作符"><a href="#二、关系操作符" class="headerlink" title="二、关系操作符"></a>二、关系操作符</h2><p>关系操作符是用于计算操作数之间的关系，其结果是一个布尔值，即 <code>true</code> 或 <code>false</code>。</p>
<p>关系操作符包括以下几个：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
<td align="left">a &gt; b</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
<td align="left">a &lt; b</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">大于等于</td>
<td align="left">a &gt;= b</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">小于等于</td>
<td align="left">a &lt;= b</td>
</tr>
<tr>
<td align="left">==</td>
<td align="left">等于</td>
<td align="left">a == b</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不等于</td>
<td align="left">a != b</td>
</tr>
</tbody></table>
<p>这个关系运算，和平时数学里的值比较差不多，需要注意的有几个地方：</p>
<ul>
<li>等于操作符（<code>==</code>、<code>!=</code>）可以作用于所有基本数据类型</li>
<li>其他的大小比较操作符（<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>）能作用于除布尔基本类型外的其他基本数据类型。因为布尔值只有 <code>true</code> 和 <code>false</code> 这2种，不存在大小关系，没有意义</li>
</ul>
<p>特别注意，等于操作符（<code>==</code>、<code>!=</code>）作用在基本数据类型和对象上时的效果是不一样的：</p>
<ul>
<li>作用在基本数据类型上，比较的就是数据的真实值</li>
<li>作用在对象上，实际比较的是对象的引用地址，而不是对象的值</li>
</ul>
<p>举个栗子来说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">boolean</span> c = a == b; <span class="comment">// c = true，因为a和b都是基本数据类型，它们的值是相等的</span></span><br><span class="line"></span><br><span class="line">Integer d = <span class="number">1000</span>;</span><br><span class="line">Integer e = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">boolean</span> f = d == e; <span class="comment">// f = false，因为d和e都是对象，==比较的是对象引用地址，而不是对象的值</span></span><br></pre></td></tr></table></figure>

<p>d和e都是对象，<code>==</code> 比较的是对象引用地址，而不是对象的值，所以表达式 <code>d == e</code> 的返回值是 <code>false</code>。因为 <code>d</code> 和 <code>e</code> 是2个对象，虽然这2个对象的数值是相等的，但是它们的引用地址是不同的。</p>
<p>再举个栗子，如果同时对比基本数据类型和包装类型对象的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1000</span>;</span><br><span class="line">Integer b = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">boolean</span> c = a == b; <span class="comment">// c = true</span></span><br></pre></td></tr></table></figure>

<p>最终c的结果为<code>true</code>，说明了在对基本数据类型和包装类型进行比较时，包装类型对象会自动拆箱成基本数据类型，然后再比较2个基本数据类型的值。</p>
<p>所以，判断操作数的关系时，需要注意：</p>
<ul>
<li>比较对象的值，一般不用 <code>==</code>，而是用 <code>equals()</code> 方法</li>
<li>比较基本数据类型的值，<code>equals()</code> 方法用不了，直接用 <code>==</code></li>
</ul>
<p>简单来说，不要用 <code>==</code> 和 <code>!=</code> 去判断对象就对了。</p>
<p>还有，不要将等于操作符（<code>==</code>、<code>!=</code>）作用在浮点数（<code>float</code>、<code>double</code>）上，由于计算机内存放的浮点数与实际的实数存在着一定的误差，如果对浮点数进行 ==（相等）或 !=（不相等）的比较，容易产生错误结果。</p>
<h2 id="三、逻辑操作符"><a href="#三、逻辑操作符" class="headerlink" title="三、逻辑操作符"></a>三、逻辑操作符</h2><p>逻辑操作符是对布尔类型变量/布尔表达式进行运算，其运算结果也是布尔类型值，即 <code>true</code> 或 <code>false</code>。</p>
<p>注意，逻辑操作符只能操作布尔值（布尔变量、关系表达式）。</p>
<p>逻辑操作符包括以下几个：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">!</td>
<td align="left">逻辑非</td>
<td align="left">!a</td>
</tr>
<tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑与</td>
<td align="left">a &amp;&amp; b</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">逻辑或</td>
<td align="left">a || b</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">与</td>
<td align="left">a &amp; b</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">或</td>
<td align="left">a | b</td>
</tr>
</tbody></table>
<p>本来 <code>&amp;</code> 和 <code>|</code> 不算在逻辑操作符内的，不过它也能用来进行逻辑判断，所以姑且放在这里。</p>
<p>逻辑运算符的作用是，把各部分的运算关系表达式连接起来，组成一个复杂的逻辑表达式。</p>
<p>比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = a &gt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> || !(c &lt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>通过逻辑操作符将 <code>a &gt; 0</code>、<code>b &lt; 0</code>、<code>c &lt; 0</code> 这几个简单连接成了一个复杂的逻辑表达式。</p>
<p>逻辑操作符 <code>&amp;&amp;</code>、<code>||</code> 具有“短路”现象，即一旦能够明确整个表达式的值，就不再计算表达式剩余的部分了。</p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> a = <span class="number">1</span> &lt; <span class="number">2</span> &amp;&amp; <span class="number">3</span> &lt; <span class="number">4</span> || <span class="number">5</span> &gt; <span class="number">6</span>; <span class="comment">// a = true</span></span><br></pre></td></tr></table></figure>

<p>这条表达式，它是这样计算的：</p>
<ol>
<li>首先计算 <code>1 &lt; 2</code>，结果是 <code>true</code>；</li>
<li>其次计算 <code>3 &lt; 4</code>，结果是 <code>true</code>；</li>
<li>发现后面是逻辑或运算，此时前面的表达式 <code>1 &lt; 2 &amp;&amp; 3 &lt; 4</code> 的结果已经是 <code>true</code> 了，所以就明确肯定整条表达式的值必然是 <code>true</code>（因为 <code>true</code> 逻辑或任何值，结果都是 <code>true</code>），这个时候就不再计算表达式剩余部分 <code>5 &gt; 6</code> 的值了，而是直接返回 <code>true</code> 给 a。</li>
</ol>
<p>表达式计算只计算到 <code>1 &lt; 2 &amp;&amp; 3 &lt; 4</code> 就返回了，后面的 <code>5 &gt; 6</code> 无需计算。这种行为就是“短路”现象，通过提前返回结果，减少表达式的判断，优化性能。</p>
<p>不过，<code>&amp;</code> 和 <code>|</code> 就没有“短路”操作了，它会执行完整个表达式，所以一般情况下，不会在逻辑表达式中用 <code>&amp;</code> 和 <code>|</code>，因为它们没有短路优化，但是结果却与 <code>&amp;&amp;</code> 和 <code>||</code> 是一样的。</p>
<p>一般建议，不要用 <code>&amp;</code> 和 <code>|</code> 来做逻辑判断，这2个操作符主要还是用在位操作上。</p>
<h2 id="四、条件操作符"><a href="#四、条件操作符" class="headerlink" title="四、条件操作符"></a>四、条件操作符</h2><p>条件操作符一个三元运算符，表示 <code>if-then-else</code> 行为：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">?:</td>
<td align="left">if-then-else</td>
<td align="left">a &gt; 0 ? b : c</td>
</tr>
</tbody></table>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;                    <span class="comment">// a = 10</span></span><br><span class="line"><span class="keyword">int</span> b = a &gt; <span class="number">0</span> ? a + <span class="number">1</span> : a - <span class="number">1</span>; <span class="comment">// b = 11</span></span><br></pre></td></tr></table></figure>

<p>条件操作符就是一个判断语句，还是比较好理解的：</p>
<ol>
<li>首先判断 <code>a &gt; 0</code>；</li>
<li>若 <code>a &gt; 0</code> 为 <code>true</code>，则执行 <code>?</code> 后的语句，即 <code>a + 1</code>;</li>
<li>若 <code>a &gt; 0</code> 为 <code>false</code>，则执行 <code>:</code> 后的语句，即 <code>a - 1</code>。</li>
</ol>
<p>条件操作符和平时写的条件判断 <code>if-else</code> 差不多，相当于它的简写形式。</p>
<h2 id="五、算术操作符"><a href="#五、算术操作符" class="headerlink" title="五、算术操作符"></a>五、算术操作符</h2><p>Java 中的算术操作符主要用来对数值类型数据进行算术运算。</p>
<p>按照算术运算中涉及的操作数量，可以分为一元运算符和二元运算符。</p>
<h3 id="5-1-一元运算符"><a href="#5-1-一元运算符" class="headerlink" title="5.1 一元运算符"></a>5.1 一元运算符</h3><p>一元运算符包括以下几个：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">一元减，取反符号</td>
<td align="left">-a</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">一元加</td>
<td align="left">+a</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">自减一</td>
<td align="left">a–、–a</td>
</tr>
<tr>
<td align="left">++</td>
<td align="left">自增一</td>
<td align="left">a++、++a</td>
</tr>
</tbody></table>
<p>一元减号 <code>-</code> 用于转变数据的符号，比如正变负，负变正。一元加号 <code>+</code> 只是为了与一元减号相对应，实际作用不大。不过它们有一个特点：</p>
<ul>
<li>一元运算符 <code>-</code>、<code>+</code> 会先将小整数类型（<code>byte</code>、<code>char</code>、<code>short</code>）提升为 <code>int</code> 类型，再执行运算</li>
</ul>
<p>实际应用效果就类似下面这样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;            <span class="comment">// a = 10</span></span><br><span class="line"><span class="keyword">int</span> b = -a;            <span class="comment">// b = -10</span></span><br><span class="line"><span class="keyword">byte</span> c = <span class="number">10</span>;           <span class="comment">// c(byte) = 10</span></span><br><span class="line"><span class="keyword">short</span> d = (<span class="keyword">short</span>) +c;  <span class="comment">// d(short) = 10，+号会自动提升操作数类型为int，所以这里需要强制转换为short</span></span><br><span class="line"><span class="keyword">short</span> e = (<span class="keyword">short</span>) -c;  <span class="comment">// e(short) = 10，-号会自动提升操作数类型为int，所以这里需要强制转换为short</span></span><br></pre></td></tr></table></figure>

<p>自增操作符可分为前缀式（<code>--a</code>）和后缀式（<code>a--</code>），前缀式是先计算，再返回值；而后缀式则是先返回值，再计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">// a = 10</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;  <span class="comment">// b = 20</span></span><br><span class="line"><span class="keyword">int</span> c = --a; <span class="comment">// c = 9，a = 9，先计算自减--，再返回值</span></span><br><span class="line"><span class="keyword">int</span> d = b--; <span class="comment">// d = 20，b = 19，先返回值，再计算自减--</span></span><br></pre></td></tr></table></figure>

<p>在表达式中使用前缀式和后缀式时，需要特别注意它们的返回值，要清楚知道表达式的返回值是多少。</p>
<p>不过一般建议使用小括号把它们括起来，这样就无需过多在意前后缀表达式的返回值了。</p>
<h3 id="5-2-二元运算符"><a href="#5-2-二元运算符" class="headerlink" title="5.2 二元运算符"></a>5.2 二元运算符</h3><p>二元运算符包括以下几个：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加</td>
<td align="left">a + b</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减</td>
<td align="left">a - b</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘</td>
<td align="left">a * b</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">除</td>
<td align="left">a / b</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取余</td>
<td align="left">a % b</td>
</tr>
</tbody></table>
<p>这个就是平时的基本数学运算，理解起来很简单。</p>
<p>有点不同的就是，Java 中的整数除法会直接去掉小数位来取整，而不是常见的四舍五入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;     <span class="comment">// a = 10</span></span><br><span class="line"><span class="keyword">int</span> b = a / <span class="number">3</span>;  <span class="comment">// b = 3，会直接去掉小数位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = -<span class="number">10</span>;    <span class="comment">// c = -10</span></span><br><span class="line"><span class="keyword">int</span> d = c / <span class="number">3</span>;  <span class="comment">// d = -3，会直接去掉小数位</span></span><br></pre></td></tr></table></figure>

<p>注意整数除法是直接去掉小数位数据，既不是向上/向下取整，也不是四舍五入。</p>
<p>另外，二元运算符也会导致小整数类型（<code>byte</code>、<code>char</code>、<code>short</code>）提升为 <code>int</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">10</span>;</span><br><span class="line">a = (<span class="keyword">short</span>) (a + <span class="number">1</span>);  <span class="comment">// a 会先提升为 int 类型，再执行运算</span></span><br><span class="line">a = (<span class="keyword">short</span>) (a * <span class="number">2</span>);  <span class="comment">// a 会先提升为 int 类型，再执行运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> b = --a;        <span class="comment">// 注意，自增/自减不会提升为 int 类型，或者说底层已经帮我们转好类型了</span></span><br></pre></td></tr></table></figure>

<p>一般来说，只要是涉及到数学运算的，小整数类型（<code>byte</code>、<code>char</code>、<code>short</code>）都会先提升为 <code>int</code> 类型，再运算。</p>
<p>当然，除了自增（<code>++</code>）和自减（<code>--</code>）以外。</p>
<h2 id="六、位操作符"><a href="#六、位操作符" class="headerlink" title="六、位操作符"></a>六、位操作符</h2><p>位操作符是直接对整数类型的位进行操作，类型包括 <code>long</code>，<code>int</code>，<code>short</code>，<code>char</code> 和 <code>byte</code>。</p>
<p>注意，位操作只对整数起作用，浮点数 <code>float</code> 和 <code>double</code> 不能进行位操作（因为它们是按 IEEE754 标准保存的，位运算的意义不是很大）。</p>
<p>按照意义，位操作符可分为2种：</p>
<ul>
<li>按位运算符：对2个操作数对应的位执行布尔代数操作</li>
<li>移位运算符：直接对操作数的位移动，并用0/1补充移动后空出来的位</li>
</ul>
<p>下面分别介绍2种操作符类型。</p>
<h3 id="6-1-按位运算符"><a href="#6-1-按位运算符" class="headerlink" title="6.1 按位运算符"></a>6.1 按位运算符</h3><p>按位运算符包括以下几个：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与（AND）</td>
<td align="left">a &amp; b</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或（OR）</td>
<td align="left">a | b</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">按位异或（XOR）</td>
<td align="left">a ^ b</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">按位取反（NOT）</td>
<td align="left">~a</td>
</tr>
</tbody></table>
<p>按位运算符是直接对位进行操作的，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = -<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> c = a ^ b;</span><br></pre></td></tr></table></figure>

<p>它的一个实际运算过程是这样的，会按照操作数的每一个位进行布尔运算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   00000000000000000000000000001010        // a = 10</span><br><span class="line">^  11111111111111111111111111101100        // b = -20</span><br><span class="line">-------------------------------------</span><br><span class="line">   11111111111111111111111111100110        // c = -26</span><br></pre></td></tr></table></figure>

<p>注意，布尔类型也可以进行按位运算，但是只能执行 <code>&amp;</code>、<code>|</code>、<code>^</code> 这3种操作，而没有按位取反 <code>~</code> 操作。</p>
<p>至于没有按位取反操作的原因，可能有以下几个：</p>
<ul>
<li>布尔类型只有 <code>true</code> 和 <code>false</code> 这2个值，而布尔类型的位数是不确定的，在这种情况下执行按位取反，有可能会出现非布尔类型值<ul>
<li>假设布尔类型是8位，其中 <code>10000000</code> 表示 <code>true</code>，<code>00000001</code> 表示 <code>false</code>，在这种情况下按位取反的话，<code>true</code> 取反后的值并不是 <code>false</code>，而且也不是布尔类型值了</li>
<li>除非布尔类型只有1位，它的按位取反才显得正常，因为只有1位的话，就肯定只会有2个值，取反后肯定是相反值，也就不会出现非布尔类型值了</li>
</ul>
</li>
<li>还有可能是为了避免和逻辑非（<code>!</code>）混淆，因为布尔值只有2个，所以从理论上来说，按位取反（<code>~</code>）和逻辑非（<code>!</code>）的结果是一样的</li>
</ul>
<p>综上，由于某些原因，布尔类型并没有按位取反（<code>~</code>）的操作。</p>
<h3 id="6-2-移位运算符"><a href="#6-2-移位运算符" class="headerlink" title="6.2 移位运算符"></a>6.2 移位运算符</h3><p>移位运算符包括以下几个：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt;&lt;</td>
<td align="left">左移（高位移除、低位补0）</td>
<td align="left">a &lt;&lt; 1</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">有符号右移（高位补符号位、低位移除）</td>
<td align="left">a &gt;&gt; 2</td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt;</td>
<td align="left">无符号右移（高位补0、低位移除）</td>
<td align="left">a &gt;&gt;&gt; 3</td>
</tr>
</tbody></table>
<p>有符号右移和无符号右移，区别就在于高位的补充是什么值。举2个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># b = a &gt;&gt; 2</span><br><span class="line"></span><br><span class="line">&gt;&gt;  11111111111111111111111111110110        // a = -10</span><br><span class="line">-------------------------------------</span><br><span class="line">    11111111111111111111111111111101        // b = a &gt;&gt; 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># b = a &gt;&gt;&gt; 2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 11111111111111111111111111110110        // a = -10</span><br><span class="line">-------------------------------------</span><br><span class="line">    00111111111111111111111111111101        // b = a &gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure>

<p>有符号右移（<code>&gt;&gt;</code>），高位会补充符号位（负数补 1，其他补 0），无符号右移（<code>&gt;&gt;&gt;</code>）高位统一补 0。</p>
<p>另外，移位操作还有几个特点：</p>
<ul>
<li>小整数类型 <code>byte</code>、<code>char</code>、<code>short</code> 执行移位操作前，会先提升为 <code>int</code> 类型，再进行移位</li>
<li><code>int</code> 移位只取操作数的低 5 位数值（2 的 5 次方是 32，也就是 <code>int</code> 的位数）</li>
<li><code>long</code> 移位只取操作数的低 6 位数值（2 的 6 次方是 64，也就是 <code>long</code> 的位数）</li>
</ul>
<p>也就是说，小整数类型进行移位操作会出现这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">10</span>;</span><br><span class="line">a = (<span class="keyword">short</span>) (a &gt;&gt; <span class="number">1</span>); <span class="comment">// 返回值要强制类型转换</span></span><br></pre></td></tr></table></figure>

<p>因为移位操作会把 <code>short</code> 提升为 <code>int</code>，所以最后的运算结果需要强制类型转换。</p>
<p>至于移位操作数的值超出 <code>int</code> 或 <code>long</code> 的位数时，就需要特殊处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;      <span class="comment">// a = 1010</span></span><br><span class="line"><span class="keyword">int</span> b = a &lt;&lt; <span class="number">55</span>; <span class="comment">// b = 101000000000000000000000000, 55 = 110111</span></span><br></pre></td></tr></table></figure>

<p>这种情况，55 明显超出了 <code>int</code> 的 32 位，所以它实际上移位的数值是 55（110111） 的低 5 位，也就是 23（10111），也就是 <code>a &lt;&lt; 55</code> 等价于 <code>a &lt;&lt; 23</code>。</p>
<p>同样地，如果移位操作数是负数，也是取低5位（<code>long</code> 取低6位）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;       <span class="comment">// a = 1010</span></span><br><span class="line"><span class="keyword">int</span> b = a &lt;&lt; -<span class="number">55</span>; <span class="comment">// b = 1010000000000, -55 = 11111111111111111111111111001001</span></span><br></pre></td></tr></table></figure>

<p>55 的低 5 位是 9（<code>1001</code>），所以 <code>a &lt;&lt; -55</code> 等价于 <code>a &lt;&lt; 9</code>。</p>
<p>截取低位来运算，是为了避免移位超出类型的位数，徒做无用功。</p>
<h2 id="七、赋值操作符"><a href="#七、赋值操作符" class="headerlink" title="七、赋值操作符"></a>七、赋值操作符</h2><p>赋值操作符就比较简单了，就是给变量赋值。</p>
<p>赋值操作符包括以下几个：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">直接赋值</td>
<td align="left">a = 1</td>
</tr>
<tr>
<td align="left">+=</td>
<td align="left">先加，再赋值</td>
<td align="left">a += 2</td>
</tr>
<tr>
<td align="left">-=</td>
<td align="left">先减，再赋值</td>
<td align="left">a -= 3</td>
</tr>
<tr>
<td align="left">*=</td>
<td align="left">先乘，再赋值</td>
<td align="left">a *= 3</td>
</tr>
<tr>
<td align="left">/=</td>
<td align="left">先除，再赋值</td>
<td align="left">a /= 3</td>
</tr>
<tr>
<td align="left">&amp;=</td>
<td align="left">先按位与，再赋值</td>
<td align="left">a &amp;= 3</td>
</tr>
<tr>
<td align="left">|=</td>
<td align="left">先按位或，再赋值</td>
<td align="left">a |= 3</td>
</tr>
<tr>
<td align="left">^=</td>
<td align="left">先按位异或，再赋值</td>
<td align="left">a ^= 3</td>
</tr>
<tr>
<td align="left">&lt;&lt;=</td>
<td align="left">先左移位，再赋值</td>
<td align="left">a &lt;&lt;= 3</td>
</tr>
<tr>
<td align="left">&gt;&gt;=</td>
<td align="left">先有符号右移位，再赋值</td>
<td align="left">a &gt;&gt;= 3</td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt;=</td>
<td align="left">先无符号右移位，再赋值</td>
<td align="left">a &gt;&gt;&gt;= 3</td>
</tr>
</tbody></table>
<p>除了赋值操作符 <code>=</code> 以外，其他的都是复合操作符，也就是赋值操作和运算操作联合在一起形成的。</p>
<p>除了一元操作符（<code>--</code>、<code>++</code>、<code>~</code>），凡是运算相关的操作符（不包括关系、逻辑、条件），基本上都能和 <code>=</code> 联合形成复合操作符。</p>
<p>不过这种复合操作符的优先级是比较低的（和 <code>=</code> 的优先级一样），举个例子来说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a *= <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>正常来说，乘法 <code>*</code> 优先级肯定比加法 <code>+</code> 高的，但实际上的它却等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a * (<span class="number">1</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>所以说，复合操作符的优先级比较低，和直接赋值 <code>=</code> 优先级一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>操作符种类：</p>
<ul>
<li>关系操作符：&gt;、&lt;、&gt;=、&lt;=、==、!=</li>
<li>逻辑操作符：!、&amp;、|、&amp;&amp;、||</li>
<li>条件操作符：?:</li>
<li>算术操作符：-、++、–、+、-、*、/、%</li>
<li>位操作符：~、&amp;、|、^、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</li>
<li>赋值操作符：=、+=、-=、*=、/=、&amp;=、|=、^=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</li>
</ul>
<p>操作符优先级：</p>
<ul>
<li>操作符的优先级共分为 14 级，其中 1 级最高，14 级最低</li>
<li>尽量不要在一个表达式中混合使用多种不同优先级的操作符</li>
<li>不要写过于复杂的表达式，而是建议把它分成几个简单表达式</li>
<li>不要过多地依赖操作符的优先级来控制表达式的执行顺序，尽量使用小括号 <code>()</code> 来控制表达式的执行顺序</li>
</ul>
<p>关系操作符：</p>
<ul>
<li>等于操作符（<code>==</code>、<code>!=</code>）可以作用于所有基本数据类型</li>
<li>其他的大小比较操作符（<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>）能作用于除布尔基本类型外的其他基本数据类型。因为布尔值只有 <code>true</code> 和 <code>false</code> 这2种，不存在大小关系，没有意义</li>
<li>作用在基本数据类型上，比较的就是数据的真实值</li>
<li>作用在对象上，实际比较的是对象的引用地址，而不是对象的值</li>
<li>比较对象的值，一般不用 <code>==</code>，而是用 <code>equals()</code> 方法</li>
<li>比较基本数据类型的值，<code>equals()</code> 方法用不了，直接用 <code>==</code></li>
</ul>
<p>逻辑操作符：</p>
<ul>
<li>逻辑操作符 <code>&amp;&amp;</code>、<code>||</code> 具有“短路”现象，即一旦能够明确整个表达式的值，就不再计算表达式剩余的部分了</li>
<li><code>&amp;</code> 和 <code>|</code> 就没有“短路”操作了，它会执行完整个表达式</li>
<li>一般建议，不要用 <code>&amp;</code> 和 <code>|</code> 来做逻辑判断，这2个操作符主要还是用在位操作上</li>
</ul>
<p>条件操作符：</p>
<ul>
<li>条件操作符和平时写的条件判断 <code>if-else</code> 差不多，相当于它的简写形式</li>
</ul>
<p>算术操作符：</p>
<ul>
<li>按照算术运算中涉及的操作数量，可以分为一元运算符和二元运算符</li>
<li>自增操作符可分为前缀式（<code>--a</code>）和后缀式（<code>a--</code>），前缀式是先计算，再返回值；而后缀式则是先返回值，再计算</li>
<li>注意整数除法是直接去掉小数位数据，既不是向上/向下取整，也不是四舍五入</li>
<li>一般来说，凡是涉及到数学运算的，小整数类型（<code>byte</code>、<code>char</code>、<code>short</code>）都会先提升为 <code>int</code> 类型，再运算</li>
</ul>
<p>位操作符：</p>
<ul>
<li>位操作符是直接对整数类型的位进行操作，类型包括 <code>long</code>，<code>int</code>，<code>short</code>，<code>char</code> 和 <code>byte</code></li>
<li>位操作只对整数起作用，浮点数 <code>float</code> 和 <code>double</code> 不能进行位操作（因为它们是按 IEEE754 标准保存的，位运算的意义不是很大）</li>
<li>按照意义，位操作符可分为2种：<ul>
<li>按位运算符：对2个操作数对应的位执行布尔代数操作</li>
<li>移位运算符：直接对操作数的位移动，并用0/1补充移动后空出来的位</li>
</ul>
</li>
<li>布尔类型也可以进行按位运算，但是只能执行 <code>&amp;</code>、<code>|</code>、<code>^</code> 这3种操作，而没有按位取反 <code>~</code> 操作</li>
<li>小整数类型 <code>byte</code>、<code>char</code>、<code>short</code> 执行移位操作前，会先提升为 <code>int</code> 类型，再进行移位</li>
<li><code>int</code> 移位只取操作数的低 5 位数值（2 的 5 次方是 32，也就是 <code>int</code> 的位数）</li>
<li><code>long</code> 移位只取操作数的低 6 位数值（2 的 6 次方是 64，也就是 <code>long</code> 的位数）</li>
</ul>
<p>赋值操作符：</p>
<ul>
<li>除了赋值操作符 <code>=</code> 以外，其他的都是复合操作符，也就是赋值操作和运算操作联合在一起形成的</li>
<li>除了一元操作符（<code>--</code>、<code>++</code>、<code>~</code>），凡是运算相关的操作符（不包括关系、逻辑、条件），基本上都能和 <code>=</code> 联合形成复合操作符</li>
<li>复合操作符的优先级是比较低的（和 <code>=</code> 的优先级一样）</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>01_基本类型</title>
    <url>/lang/java/core/basic/01_types/</url>
    <content><![CDATA[<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="一、类型大小"><a href="#一、类型大小" class="headerlink" title="一、类型大小"></a>一、类型大小</h2><p>在 Java 中，通过 <code>new</code> 生成的对象数据是存储在“堆”中，而基本类型则是直接把“值”保存在栈中。</p>
<p>Java 中每种基本类型所占用的存储空间大小都是确定的，不会随着机器硬件架构变化而变化。</p>
<ul>
<li>存储空间大小不变性，为Java的可移植性提供了很大的帮助</li>
</ul>
<span id="more"></span>

<p>Java 中各种基本类型的空间大小如下：</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">包装器类型</th>
<th align="left">大小（bit）</th>
<th align="left">最小值</th>
<th align="left">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">Byte</td>
<td align="left">8</td>
<td align="left">-128</td>
<td align="left">+127</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">Character</td>
<td align="left">16</td>
<td align="left">Unicode 0</td>
<td align="left">Unicode $ 2 ^ 16 - 1 $</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
<td align="left">16</td>
<td align="left">$ -2 ^ 15 $</td>
<td align="left">$ 2 ^ 15 - 1 $</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
<td align="left">32</td>
<td align="left">$ -2 ^ 31 $</td>
<td align="left">$ 2 ^ 31 - 1 $</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
<td align="left">64</td>
<td align="left">$ -2 ^ 63 $</td>
<td align="left">$ 2 ^ 63 - 1 $</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
<td align="left">32</td>
<td align="left">IEEE754</td>
<td align="left">IEEE754</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
<td align="left">64</td>
<td align="left">IEEE754</td>
<td align="left">IEEE754</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">Void</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>在 Java 中，基本类型有以下几个特点：</p>
<ul>
<li>所有数值类型都是有正负号的，不存在无符号数值类型</li>
<li>boolean 类型的存储大小没有明确规定，仅定义为能够取字面值 <code>true</code> 和 <code>false</code></li>
<li>基本类型都有对应的包装器类型</li>
</ul>
<p>Java SE5 中的自动包箱功能可以自动将基本类型转换为包装器类型。</p>
<h2 id="二、类型转换"><a href="#二、类型转换" class="headerlink" title="二、类型转换"></a>二、类型转换</h2><p>在适当的时候，Java 会把一种数据类型转换为另一种数据类型，这个就称为类型转换。</p>
<p>例如，执行以下语句时，编译器会适当地转换数据类型来完成操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> d = a + <span class="number">1.0</span>; <span class="comment">// 此处a会自动转换为double类型</span></span><br></pre></td></tr></table></figure>

<p>但是，有时候不能自动进行转换，则需要手动强制转换类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> j = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>) j + <span class="number">10</span>; <span class="comment">// 这种必须显式地进行强制类型转换</span></span><br></pre></td></tr></table></figure>

<p>对于类型转换，有如下几个特点：</p>
<ul>
<li>布尔基本类型（boolean）不允许进行任何类型转换</li>
<li>除布尔基本类型外，其他基本类型之间可以任意转换，不过进行转换时可能会丢失部分信息</li>
<li>没有血缘关系（继承）的“类”之间不允许进行类型转换</li>
</ul>
<p>比较特殊的就是布尔基本类型（boolean），它不允许进行任何的类型转换。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>) b; <span class="comment">// 不允许转换</span></span><br><span class="line">b = (<span class="keyword">boolean</span>) i; <span class="comment">// 不允许转换</span></span><br></pre></td></tr></table></figure>

<p>这2种转换操作，在 Java 中都是不允许的，编译器也不会通过这些语句。</p>
<p>根据转换的实际情况，可以分为2种转换类型：</p>
<ul>
<li>窄化转换（narrowing conversion）：将大数据类型转换为小数据类型了，可能会丢失部分信息，比如 long 转换为 int，int 转换为 short 等</li>
<li>扩展转换（widening conversion）：将小数据类型转换为大数据类型，不会丢失任何信息，比如 short 转换为 int，int 转换为 long 等</li>
</ul>
<p>对于窄化转换，必须显式地进行强制类型转换，否则编译器会直接报错。而对于扩展转换，则不必显式地进行类型转换，它会自动转换。</p>
<p>对于窄化转换，它是怎么转换的呢？是直接截取？还是舍入？举个例子来看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t = <span class="number">0x0FF0FF00F0F0F0F0L</span>;</span><br><span class="line">System.out.println(t);</span><br><span class="line">System.out.println(Long.toBinaryString(t));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>) t;</span><br><span class="line">System.out.println(i);</span><br><span class="line">System.out.println(Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1148698284486881520</span><br><span class="line">111111110000111111110000000011110000111100001111000011110000</span><br><span class="line">-252645136</span><br><span class="line">11110000111100001111000011110000</span><br></pre></td></tr></table></figure>

<p>很明显，long 窄化转换为 int，它是直接进行的截尾操作。也就是说，64位的 long 窄化转换为32位的 int 时，是直接截取的 long 的低32位。</p>
<p>类似地，其他大类型转换为小类型时，也是直接截取的低位数。</p>
<p>还需要注意的一点就是，窄化转换后，数值符号可能会发生变化，比如从正数变负数，或者从负数变正数，因为它是直接截尾转换的。</p>
<p>而对于扩展转换，它的实际情况如何呢？也举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0xF0F0F0F0</span>;</span><br><span class="line">System.out.println(i);</span><br><span class="line">System.out.println(Integer.toBinaryString(i));</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t = i;</span><br><span class="line">System.out.println(t);</span><br><span class="line">System.out.println(Long.toBinaryString(t));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-252645136</span><br><span class="line">11110000111100001111000011110000</span><br><span class="line">-252645136</span><br><span class="line">1111111111111111111111111111111111110000111100001111000011110000</span><br></pre></td></tr></table></figure>

<p>可以看到，扩展转换的数据信息是不会丢失的，它是用符号位进行扩充来填补高位，从而保持了数值的符号不变。</p>
<p>总之，扩展转换是不需要关心的，主要还是大数据类型转小数据类型的窄化转换，它可能会导致部分信息丢失，需要特别留意。</p>
<h2 id="三、高精度数值类型"><a href="#三、高精度数值类型" class="headerlink" title="三、高精度数值类型"></a>三、高精度数值类型</h2><p>另外，除了上面的基本数据类型，Java还提供了2种高精度数值类型：</p>
<ul>
<li><code>BigInteger</code>：支持任意精度的整数</li>
<li><code>BigDecimal</code>：支持任意精度的定点数</li>
</ul>
<p>这2种类型分别对应的是 <code>int</code> 和 <code>float</code> 基本类型，它们所能执行的操作相似。</p>
<p>也就是说，<code>int</code> 和 <code>float</code> 能做的事，都可以用 <code>BigInteger</code> 和 <code>BigDecimal</code> 来做，而且精度更高。</p>
<p>但是 <code>BigInteger</code> 和 <code>BigDecimal</code> 毕竟不是基本类型，而是一种对象类型，所以运算速度会比较慢。</p>
<p>实际上基本类型也是用精度换取了速度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本类型：</p>
<ul>
<li><p>在 Java 中，通过 <code>new</code> 生成的对象数据是存储在“堆”中，而基本类型则是直接把“值”保存在栈中</p>
</li>
<li><p>Java 中每种基本类型所占用的存储空间大小都是确定的，不会随着机器硬件架构变化而变化。</p>
</li>
<li><p>存储空间大小不变性，为Java的可移植性提供了很大的帮助</p>
</li>
<li><p>所有数值类型都是有正负号的，不存在无符号数值类型</p>
</li>
<li><p>boolean 类型的存储大小没有明确规定，仅定义为能够取字面值 <code>true</code> 和 <code>false</code></p>
</li>
<li><p>基本类型都有对应的包装器类型</p>
</li>
<li><p>Java SE5 中的自动包箱功能可以自动将基本类型转换为包装器类型</p>
</li>
</ul>
<p>类型转换：</p>
<ul>
<li>根据转换的实际情况，可以分为2种转换类型：<ul>
<li>窄化转换（narrowing conversion）：将大数据类型转换为小数据类型了，可能会丢失部分信息，比如 long 转换为 int，int 转换为 short 等</li>
<li>扩展转换（widening conversion）：将小数据类型转换为大数据类型，不会丢失任何信息，比如 short 转换为 int，int 转换为 long 等</li>
</ul>
</li>
<li>对于窄化转换，必须显式地进行强制类型转换，否则编译器会直接报错。而对于扩展转换，则不必显式地进行类型转换，它会自动转换</li>
<li>窄化转换，采用的是截尾实现，也就是截取大数据类型的低位</li>
<li>窄化转换后，数值符号可能会发生变化，比如从正数变负数，或者从负数变正数</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>03_解析class文件</title>
    <url>/lang/java/jvm/selfjvm/03_classfile/</url>
    <content><![CDATA[<h2 id="解析class文件"><a href="#解析class文件" class="headerlink" title="解析class文件"></a>解析class文件</h2><p>Java 虚拟机规范中所指的 class 文件，并非特指位于磁盘中的 .class 文件，而是泛指任何格式符合规范的 class 数据。它实际上可以通过网络下载，从数据库加载，甚至是在运行中直接生成等方式来获取 class 文件。</p>
<ul>
<li>构成 class 文件的基本数据单位是字节，可以把整个 class 文件当成一个字节流来处理</li>
<li>数据由连续多个字节构成，这些数据在 class 文件中以大端（big-endian）方式存储</li>
</ul>
<p>为了描述 class 文件格式，Java 虚拟机规范定义了 u1、u2 和 u4 三种数据类型来表示1、2和4字节无符号整数。</p>
<span id="more"></span>

<ul>
<li>相同类型的多条数据一般按表（table）的形式存储在 class 文件中</li>
<li>表由表头和表项（item）构成，表头是 u2 或 u4 整数</li>
</ul>
<p>整个 class 文件被描述为一个 ClassFile 结构，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4                 magic;</span><br><span class="line">    u2                 minor_version;</span><br><span class="line">    u2                 major_version;</span><br><span class="line">    u2                 constant_pool_count;</span><br><span class="line">    cp_info            constant_pool[constant_pool_count<span class="number">-1</span>];</span><br><span class="line">    u2                 access_flags;</span><br><span class="line">    u2                 this_class;</span><br><span class="line">    u2                 super_class;</span><br><span class="line">    u2                 interfaces_count;</span><br><span class="line">    u2                 interfaces[interfaces_count];</span><br><span class="line">    u2                 fields_count;</span><br><span class="line">    field_info         fields[fields_count];</span><br><span class="line">    u2                 methods_count;</span><br><span class="line">    method_info        methods[methods_count];</span><br><span class="line">    u2                 attributes_count;</span><br><span class="line">    attribute_info     attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h2><h3 id="1-1-自定义数据类型"><a href="#1-1-自定义数据类型" class="headerlink" title="1.1 自定义数据类型"></a>1.1 自定义数据类型</h3><p>Java 虚拟机规范定义了 u1、u2 和 u4 三种数据类型来表示1、2和4字节无符号整数。</p>
<p>但是 Java 中都是有符号整数，没有无符号整数，所以这里先定义几种无符号整数类型，实际上它们是由更大范围的整数值来保存的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8比特无符号整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Uint8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Uint8</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 16比特无符号整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Uint16</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Uint16</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 32比特无符号整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Uint32</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Uint32</span><span class="params">(<span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义类型的原因是，方便在定义 ClassFile 类时，各个成员变量的类型能更清晰一些，不然都是 int、long 这些类型的话，都不知道 ClassFile 中实际保存的字节数量。</p>
<p>这样增加自定义类型后，下面的 ClassFile 结构就稍微好看一点了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 魔数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint32 magic;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 次版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 minorVersion;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 majorVersion;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池常量数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 constantCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConstantPoolInfo constantPool;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类访问标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 accessFlags;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 className;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 superClassName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 interfaceCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16[] interfaces;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 fieldCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FieldInfo[] fields;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 methodCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MethodInfo[] methods;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Uint16 attributesCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AttributeInfo[] attributes;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-类型数据读取"><a href="#1-2-类型数据读取" class="headerlink" title="1.2 类型数据读取"></a>1.2 类型数据读取</h3><p>现在是把 class 文件当成字节流来处理，但是如果直接操作字节是很不方便的。而且前面增加了自定义数据类型，把数据读出来后，还要再转成对应的数据类型，相当麻烦。</p>
<p>所以定义了一个工具类 <code>ClassReader</code> 来帮助读取数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    ClassReader (<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        buf = ByteBuffer.wrap(bytes);</span><br><span class="line">        buf.order(ByteOrder.BIG_ENDIAN); <span class="comment">// 大端</span></span><br><span class="line">        offset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buf.getInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buf.getLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buf.getFloat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buf.getDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uint8 <span class="title">readUint8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = buf.get();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Uint8(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uint16 <span class="title">readUint16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">short</span> s = buf.getShort();</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0x0FFFF</span> &amp; s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Uint16(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uint32 <span class="title">readUint32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = buf.getInt();</span><br><span class="line">        <span class="keyword">long</span> val = <span class="number">0x0FFFFFFFFL</span> &amp; i;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Uint32(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Uint16[] readUint16s(Uint16 length) &#123;</span><br><span class="line">        Uint16[] table = <span class="keyword">new</span> Uint16[length.value()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            table[i] = readUint16();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes(<span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        buf.get(bytes);</span><br><span class="line">        offset += length;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工具类底层是用 <code>ByteBuffer</code> 来实现的，它提供了很多有用的方法来读取指定类型的数据，基本上可以直接使用。</p>
<h2 id="二、类文件数据结构"><a href="#二、类文件数据结构" class="headerlink" title="二、类文件数据结构"></a>二、类文件数据结构</h2><h3 id="2-1-魔数"><a href="#2-1-魔数" class="headerlink" title="2.1 魔数"></a>2.1 魔数</h3><p>很多文件格式都会规定满足该格式的文件必须以某几个固定字节开头，这几个字节主要起标识作用，叫作魔数（magic number）。</p>
<p>class 文件的魔数是 <code>0xCAFEBABE</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">magic = reader.readUint32();</span><br></pre></td></tr></table></figure>

<p>Java 虚拟机规范规定，如果加载的 class 文件不符合要求的格式，Java 虚拟机实现就抛出 <code>java.lang.ClassFormatError</code> 异常。</p>
<h3 id="2-2-版本号"><a href="#2-2-版本号" class="headerlink" title="2.2 版本号"></a>2.2 版本号</h3><p>魔数之后是 class 文件的次版本号和主版本号，都是u2类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">minorVersion = reader.readUint16();</span><br><span class="line">majorVersion = reader.readUint16();</span><br></pre></td></tr></table></figure>

<p>次版本号只在 J2SE 1.2 之前用过，从1.2开始基本上就没什么用了（都是0）。</p>
<p>主版本号在 J2SE 1.2 之前是45，从1.2开始，每次有大的 Java 版本发布，都会加1。</p>
<table>
<thead>
<tr>
<th align="center">Java 版本</th>
<th align="center">class 文件版本号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDK 1.0.2</td>
<td align="center">45.0 ~ 45.3</td>
</tr>
<tr>
<td align="center">JDK 1.1</td>
<td align="center">45.0 ~ 45.65535</td>
</tr>
<tr>
<td align="center">J2SE 1.2</td>
<td align="center">46.0</td>
</tr>
<tr>
<td align="center">J2SE 1.3</td>
<td align="center">47.0</td>
</tr>
<tr>
<td align="center">J2SE 1.4</td>
<td align="center">48.0</td>
</tr>
<tr>
<td align="center">Java SE 5.0</td>
<td align="center">49.0</td>
</tr>
<tr>
<td align="center">Java SE 6</td>
<td align="center">50.0</td>
</tr>
<tr>
<td align="center">Java SE 7</td>
<td align="center">51.0</td>
</tr>
<tr>
<td align="center">Java SE 8</td>
<td align="center">52.0</td>
</tr>
</tbody></table>
<p>特定的 Java 虚拟机实现只能支持版本号在某个范围内的 class 文件。</p>
<p>例如，Java 8 支持版本号为 45.0 ~ 52.0 的 class 文件。</p>
<p>如果版本号不在支持的范围内，Java 虚拟机实现就抛出 <code>java.lang.UnsupportedClassVersionError</code> 异常。</p>
<h3 id="2-3-类访问标志"><a href="#2-3-类访问标志" class="headerlink" title="2.3 类访问标志"></a>2.3 类访问标志</h3><p>类访问标志，这是一个16位的 <code>bitmask</code>，用于指出 class 文件定义的是类还是接口，访问级别是 <code>public</code> 还是 <code>private</code> 等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">accessFlags = reader.readUint16();</span><br></pre></td></tr></table></figure>

<h3 id="2-4-类和超类"><a href="#2-4-类和超类" class="headerlink" title="2.4 类和超类"></a>2.4 类和超类</h3><p>类访问标志之后是两个u2类型的常量池索引，分别给出类名和超类名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">className = reader.readUint16();</span><br><span class="line">superClassName = reader.readUint16();</span><br></pre></td></tr></table></figure>

<p>class 文件存储的类名类似完全限定名，但是把点（<code>.</code>）换成了斜线（<code>/</code>），这种名字叫作二进制名（binary names）。</p>
<p>比如，<code>java.lang.Object</code> 在 class 文件中存储的名称为 <code>java/lang/Object</code>。</p>
<p>每个类都要有名字，所以 <code>className</code> 必须是有效的常量池索引。</p>
<p>除 <code>java.lang.Object</code> 之外，其他类都有超类，所以除了 <code>Object.class</code> 以外，其他 class 文件中的 <code>superClassName</code> 必须是有效的常量池索引。</p>
<p>而 <code>java.lang.Object</code> 的 class 文件中，<code>superClassName</code> 的值是0。</p>
<h3 id="2-5-类接口"><a href="#2-5-类接口" class="headerlink" title="2.5 类接口"></a>2.5 类接口</h3><p>类和超类索引后面是接口索引表，表中存放的也是常量池索引，给出该类实现的所有接口的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interfaceCount = reader.readUint16();</span><br><span class="line">interfaces = reader.readUint16s(interfaceCount);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-字段、方法"><a href="#2-6-字段、方法" class="headerlink" title="2.6 字段、方法"></a>2.6 字段、方法</h3><p>接口索引表之后是字段表和方法表，分别存储字段和方法信息。字段和方法的基本结构大致相同，差别仅在于属性表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2                     access_flags;</span><br><span class="line">    u2                     name_index;</span><br><span class="line">    u2                     descriptor_index;</span><br><span class="line">    u2                     attributes_count;</span><br><span class="line">    attribute_info         attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和类一样，字段和方法也有自己的访问标志。</p>
<p>访问标志之后是一个常量池索引，给出字段名或方法名。</p>
<p>然后又是一个常量池索引，给出字段或方法的描述符。</p>
<p>最后是属性表。</p>
<p>字段和方法的结构基本一致，所以它们的解析过程也差不多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line">fieldCount = reader.readUint16();</span><br><span class="line">fields = <span class="keyword">new</span> FieldInfo[fieldCount.value()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">    fields[i] = <span class="keyword">new</span> FieldInfo();</span><br><span class="line">    fields[i].readFrom(reader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line">methodCount = reader.readUint16();</span><br><span class="line">methods = <span class="keyword">new</span> MethodInfo[methodCount.value()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">    methods[i] = <span class="keyword">new</span> MethodInfo();</span><br><span class="line">    methods[i].readFrom(reader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="三、常量池"><a href="#三、常量池" class="headerlink" title="三、常量池"></a>三、常量池</h2><p>常量池里面存放着各式各样的常量信息，包括数字和字符串常量、类和接口名、字段和方法名等等。</p>
<p>常量池实际上也是一个表。表头给出的常量池大小比实际大1。</p>
<p>假设表头给出的值是n，那么常量池的实际大小是n–1。也就是说，常量池的有效的常量池索引是1~n–1。0是无效索引，表示不指向任何常量。</p>
<p><code>CONSTANT_Long_info</code> 和 <code>CONSTANT_Double_info</code> 各占两个位置。也就是说，如果常量池中存在这两种常量，实际的常量数量比n–1还要少，而且1~n–1的某些数也会变成无效索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">constantCount = reader.readUint16();</span><br><span class="line">constantPool = <span class="keyword">new</span> ConstantInfo[constantCount.value()];</span><br><span class="line"><span class="comment">// 常量池的索引从1开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; constantPool.length; i++) &#123;</span><br><span class="line">    constantPool[i] = readConstantInfo(reader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双字类型（即8字节）占2个位置</span></span><br><span class="line">    <span class="keyword">if</span> (constantPool[i] <span class="keyword">instanceof</span> LongConstantInfo</span><br><span class="line">            || constantPool[i] <span class="keyword">instanceof</span> DoubleConstantInfo) &#123;</span><br><span class="line">        constantPool[++i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量的第一个字节是 tag 值，用于指明常量的类型。</p>
<p>Java 虚拟机规范定义了14种常量，各个常量值对应的 tag 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantUtf8 = <span class="number">1</span>;                <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantInteger = <span class="number">3</span>;             <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantFloat = <span class="number">4</span>;               <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantLong = <span class="number">5</span>;                <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantDouble = <span class="number">6</span>;              <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantClass = <span class="number">7</span>;               <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantString = <span class="number">8</span>;              <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantFieldRef = <span class="number">9</span>;            <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantMethodRef = <span class="number">10</span>;          <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantInterfaceMethodRef = <span class="number">11</span>; <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantNameAndType = <span class="number">12</span>;        <span class="comment">// Java 1.0.2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantMethodHandle = <span class="number">15</span>;       <span class="comment">// Java 7</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantMethodType = <span class="number">16</span>;         <span class="comment">// Java 7</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantInvokeDynamic = <span class="number">18</span>;      <span class="comment">// Java 7</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantModule = <span class="number">19</span>;             <span class="comment">// Java 9</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantPackage = <span class="number">20</span>;            <span class="comment">// Java 9</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ConstantDynamic = <span class="number">17</span>;            <span class="comment">// Java 11</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照结构，常量池的常量可以分为2种，一种是存放有数据的字面常量，一种是存放索引的引用常量。</p>
<p>像整数、浮点数、UTF8字节等，都属于字面常量；而像字符串、类型、方法等都是引用常量。</p>
<p>就比如，整数常量的结构是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    3 (u1 tag);</span><br><span class="line">    101 (u4 Integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数常量的 <code>u4 Integer</code> 的值 101 就是这个整数常量的值，也就是它是直接保存数据的。</p>
<p>而字符串常量的结构是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_String_info &#123;</span><br><span class="line">    8 (u1 tag);</span><br><span class="line">    34 (u2 string_index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串常量里面的 <code>string_index</code> 就只是一个索引，指向了另外的常量，并不直接保存数据。</p>
<p>下面分别详细介绍这些常量的结构定义。</p>
<h3 id="3-1-字面常量"><a href="#3-1-字面常量" class="headerlink" title="3.1 字面常量"></a>3.1 字面常量</h3><p>字面常量，和 Java 中的基本类型概念差不多，是实际拥有数据的常量。</p>
<h4 id="3-1-1-CONSTANT-Utf8"><a href="#3-1-1-CONSTANT-Utf8" class="headerlink" title="3.1.1 CONSTANT_Utf8"></a>3.1.1 CONSTANT_Utf8</h4><p><code>CONSTANT_Utf8</code> 是一个变长的数据结构，里面存放的是 MUTF-8 编码的字符串，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 1。</p>
<p><code>length</code> 是它的长度，u2 是2个字节，所以它的最大值为 65536。</p>
<p>这也就意味着，Java 中允许的最大字符串长度为 65536 字节。也就是能够放 65536 个 ASCII 字符，或者 65536/3 个中文字符。</p>
<p>它的读取比较直接，按照字节长度读取即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    length = reader.readUint16();</span><br><span class="line">    val = reader.readBytes(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-CONSTANT-Integer"><a href="#3-1-2-CONSTANT-Integer" class="headerlink" title="3.1.2 CONSTANT_Integer"></a>3.1.2 CONSTANT_Integer</h4><p><code>CONSTANT_Integer</code> 是整型常量，使用4字节存储数值，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u4 bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 3。</p>
<p>整型常量，对应的就是 Java 中的 Integer 整型，所以直接按照读取 Integer 的方式读取即可。</p>
<p>刚好 <code>ByteBuffer</code> 也提供了相应的基本类型读取方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buf.getInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在解析整型常量时，可以直接解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    val = reader.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-CONSTANT-Float"><a href="#3-1-3-CONSTANT-Float" class="headerlink" title="3.1.3 CONSTANT_Float"></a>3.1.3 CONSTANT_Float</h4><p><code>CONSTANT_Float</code> 是 IEEE754 单精度浮点数常量，使用4字节存储数值，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_Float_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u4 bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 4。</p>
<p>单精度浮点数常量，对应的就是 Java 中的 Float 单精度浮点数。</p>
<p><code>ByteBuffer</code> 也提供了相应的读取方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buf.getFloat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以直接解析浮点数了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    val = reader.readFloat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-4-CONSTANT-Long"><a href="#3-1-4-CONSTANT-Long" class="headerlink" title="3.1.4 CONSTANT_Long"></a>3.1.4 CONSTANT_Long</h4><p><code>CONSTANT_Long</code> 是8字节长整型常量，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_Long_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u4 high_bytes;</span><br><span class="line">    u4 low_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 5。</p>
<p>注意，在长整型常量定义中，8字节是被拆分成高位4字节和低位4字节来存放的。</p>
<p>长整型常量，对应的就是 Java 中的 Long 长整型。</p>
<p><code>ByteBuffer</code> 也提供了相应的读取方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buf.getLong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接解析即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    val = reader.readLong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-5-CONSTANT-Double"><a href="#3-1-5-CONSTANT-Double" class="headerlink" title="3.1.5 CONSTANT_Double"></a>3.1.5 CONSTANT_Double</h4><p><code>CONSTANT_Double</code> 是 IEEE754 双精度浮点数常量，使用8字节存储数值，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_Double_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u4 high_bytes;</span><br><span class="line">    u4 low_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 6。</p>
<p>注意，在双精度浮点数常量定义中，8字节也是被拆分成高位4字节和低位4字节来存放的。</p>
<p>双精度浮点数常量，对应的是 Java 中的 Double 双精度浮点数。</p>
<p><code>ByteBuffer</code> 也提供了相应的读取方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buf.getDouble();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接解析即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    val = reader.readDouble();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-引用常量"><a href="#3-2-引用常量" class="headerlink" title="3.2 引用常量"></a>3.2 引用常量</h3><p>引用常量比较简单，它们不直接保存数据，只保存了索引，所以结构上可能会比字面常量稍微复杂一些。</p>
<p>下面简单介绍其中几种常见的引用常量。</p>
<h4 id="3-2-1-CONSTANT-String"><a href="#3-2-1-CONSTANT-String" class="headerlink" title="3.2.1 CONSTANT_String"></a>3.2.1 CONSTANT_String</h4><p><code>CONSTANT_String_info</code> 常量表示 <code>java.lang.String</code> 字面量，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_String_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 string_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 8。</p>
<p><code>string_index</code> 是常量池索引，指向一个 <code>CONSTANT_Utf8_info</code> 常量。</p>
<h4 id="3-2-2-CONSTANT-Class"><a href="#3-2-2-CONSTANT-Class" class="headerlink" title="3.2.2 CONSTANT_Class"></a>3.2.2 CONSTANT_Class</h4><p><code>CONSTANT_Class</code> 常量表示类或者接口的符号引用，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 7。</p>
<p><code>name_index</code> 是常量池索引，指向一个 <code>CONSTANT_Utf8_info</code> 常量。</p>
<h4 id="3-2-3-CONSTANT-Fieldref"><a href="#3-2-3-CONSTANT-Fieldref" class="headerlink" title="3.2.3 CONSTANT_Fieldref"></a>3.2.3 CONSTANT_Fieldref</h4><p><code>CONSTANT_Fieldref_info</code> 表示字段符号引用，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 class_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 9。</p>
<p><code>class_index</code> 是所在类索引，指向一个 <code>CONSTANT_Class_info</code> 常量。</p>
<p><code>name_and_type_index</code> 是名称和类型定义索引，指向一个 <code>CONSTANT_NameAndType_info</code> 常量。</p>
<h4 id="3-2-4-CONSTANT-Methodref"><a href="#3-2-4-CONSTANT-Methodref" class="headerlink" title="3.2.4 CONSTANT_Methodref"></a>3.2.4 CONSTANT_Methodref</h4><p><code>CONSTANT_Methodref_info</code> 表示普通（非接口）方法符号引用，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 class_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 10。</p>
<p><code>class_index</code> 是所在类索引，指向一个 <code>CONSTANT_Class_info</code> 常量。</p>
<p><code>name_and_type_index</code> 是名称和类型定义索引，指向一个 <code>CONSTANT_NameAndType_info</code> 常量。</p>
<h4 id="3-2-5-CONSTANT-InterfaceMethodref"><a href="#3-2-5-CONSTANT-InterfaceMethodref" class="headerlink" title="3.2.5 CONSTANT_InterfaceMethodref"></a>3.2.5 CONSTANT_InterfaceMethodref</h4><p><code>CONSTANT_InterfaceMethodref_info</code> 表示接口方法符号引用，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_InterfaceMethodref_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 class_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 11。</p>
<p><code>class_index</code> 是所在接口索引，指向一个 <code>CONSTANT_Class_info</code> 常量。</p>
<p><code>name_and_type_index</code> 是名称和类型定义索引，指向一个 <code>CONSTANT_NameAndType_info</code> 常量。</p>
<h4 id="3-2-6-CONSTANT-NameAndType"><a href="#3-2-6-CONSTANT-NameAndType" class="headerlink" title="3.2.6 CONSTANT_NameAndType"></a>3.2.6 CONSTANT_NameAndType</h4><p><code>CONSTANT_NameAndType_info</code> 给出字段或方法的名称和描述符，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;</span><br><span class="line">    u2 descriptor_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 等于 12。</p>
<p><code>name_index</code> 是名称索引，指向一个 <code>CONSTANT_Utf8_info</code> 常量。</p>
<p><code>descriptor_index</code> 是字段或方法的描述符索引，也是指向一个 <code>CONSTANT_Utf8_info</code> 常量。</p>
<p><code>CONSTANT_Class_info</code> 和 <code>CONSTANT_NameAndType_info</code> 加在一起可以唯一确定一个字段或者方法。</p>
<p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p>
<p>不过这里的描述符，不是常见的完整的字段或者函数定义，而是一种缩写形式，它的规则有以下几个：</p>
<ul>
<li>类型描述符<ul>
<li>基本类型byte、short、char、int、long、float和double的描述符是单个字母，分别对应B、S、C、I、J、F和D（注意，long的描述符是J而不是L）</li>
<li>引用类型的描述符是“L + 类的完全限定名 + 分号”</li>
<li>数组类型的描述符是“[ + 数组元素类型描述符”</li>
</ul>
</li>
<li>字段描述符<ul>
<li>字段描述符就是字段类型的描述符</li>
</ul>
</li>
<li>方法描述符<ul>
<li>方法描述符是“（分号分隔的参数类型描述符）+ 返回值类型描述符”，其中void返回值由单个字母V表示</li>
</ul>
</li>
</ul>
<p>这里直接举几个例子来说明：</p>
<table>
<thead>
<tr>
<th align="center">描述符</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">byte</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">Ljava/lang/Object;</td>
<td align="center">java.lang.Object</td>
</tr>
<tr>
<td align="center">[I</td>
<td align="center">int[]</td>
</tr>
<tr>
<td align="center">[[Ljava/lang/String;</td>
<td align="center">String[][]</td>
</tr>
<tr>
<td align="center">()V</td>
<td align="center">void method()</td>
</tr>
<tr>
<td align="center">(Ljava/lang/String;)Ljava/lang/String;</td>
<td align="center">String method(String)</td>
</tr>
<tr>
<td align="center">([JJ)J</td>
<td align="center">long method(long[], long)</td>
</tr>
<tr>
<td align="center">(Ljava/lang/String;Ljava/lang/String;)V</td>
<td align="center">void method(String, String)</td>
</tr>
</tbody></table>
<p>为了减少描述符在 ClassFile 文件中占用的空间，它只保留了必要的属性，一些不必要的属性如方法名称，并没有直接保存在描述符中。</p>
<p>Java语言支持方法重载（override），不同的方法可以有相同的名字，只要参数列表不同即可。这就是为什么<code>CONSTANT_NameAndType_info</code>结构要同时包含名称和描述符的原因。</p>
<p>那么字段呢？Java是不能定义多个同名字段的，哪怕它们的类型各不相同。这只是Java语法的限制而已，从class文件的层面来看，是完全可以支持这点的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>常量池中的常量分为两类：字面量（literal）和符号引用（symbolic reference）。</p>
<p>字面量包括数字常量和字符串常量，符号引用包括类和接口名、字段和方法信息等。</p>
<p>除了字面量，其他引用常量都是通过索引直接或间接指向 <code>CONSTANT_Utf8_info</code> 常量。</p>
<h2 id="四、属性表"><a href="#四、属性表" class="headerlink" title="四、属性表"></a>四、属性表</h2><p>属性表可谓是个大杂烩，里面存储了各式各样的信息，如方法的字节码等。</p>
<p>常量是由Java虚拟机规范严格定义的，共有14种。但属性是可以扩展的，不同的虚拟机实现可以定义自己的属性类型。</p>
<p>由于这个原因，Java虚拟机规范没有使用tag，而是使用属性名来区别不同的属性。</p>
<p>属性数据放在属性名之后的u1表中，这样Java虚拟机实现就可以跳过自己无法识别的属性。</p>
<p>属性的结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性表中存放的属性名实际上并不是编码后的字符串，而是常量池索引 <code>attribute_name_index</code>，指向常量池中的 <code>CONSTANT_Utf8_info</code> 常量。</p>
<p>按照这个定义，定义了一个属性接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeInfo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体属性只要实现 <code>readFrom</code> 方法即可。</p>
<h3 id="4-1-属性类型"><a href="#4-1-属性类型" class="headerlink" title="4.1 属性类型"></a>4.1 属性类型</h3><p>Java虚拟机规范预定义了23种属性，按照用途可以分为三组：</p>
<ul>
<li>实现Java虚拟机所必需的，共有5种</li>
<li>Java类库所必需的，共有12种</li>
<li>提供给工具使用，共有6种，这组属性是可选的</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">所在位置</th>
<th align="center">分组</th>
<th align="center">增加版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ConstantValue</td>
<td align="center">field_info</td>
<td align="center">1</td>
<td align="center">1.0.2</td>
</tr>
<tr>
<td align="center">Code</td>
<td align="center">meghod_info</td>
<td align="center">1</td>
<td align="center">1.0.2</td>
</tr>
<tr>
<td align="center">Exceptions</td>
<td align="center">method_info</td>
<td align="center">1</td>
<td align="center">1.0.2</td>
</tr>
<tr>
<td align="center">SourceFile</td>
<td align="center">ClassFile</td>
<td align="center">3</td>
<td align="center">1.0.2</td>
</tr>
<tr>
<td align="center">LineNumberTable</td>
<td align="center">Code</td>
<td align="center">3</td>
<td align="center">1.0.2</td>
</tr>
<tr>
<td align="center">LocalVariableTable</td>
<td align="center">Code</td>
<td align="center">3</td>
<td align="center">1.0.2</td>
</tr>
<tr>
<td align="center">InnerClasses</td>
<td align="center">ClassFile</td>
<td align="center">2</td>
<td align="center">1.1</td>
</tr>
<tr>
<td align="center">Synthetic</td>
<td align="center">ClassFile,field_info,method_info</td>
<td align="center">2</td>
<td align="center">1.1</td>
</tr>
<tr>
<td align="center">Deprecated</td>
<td align="center">ClassFile,field_info,method_info</td>
<td align="center">3</td>
<td align="center">1.1</td>
</tr>
<tr>
<td align="center">EnclosingMethod</td>
<td align="center">ClassFile</td>
<td align="center">2</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">Signature</td>
<td align="center">ClassFile,field_info,method_info</td>
<td align="center">2</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">SourceDebugExtension</td>
<td align="center">ClassFile</td>
<td align="center">3</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">LocalVariableTypeTable</td>
<td align="center">Code</td>
<td align="center">3</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">RunttimeVisibleAnnotations</td>
<td align="center">ClassFile,field_info,method_info</td>
<td align="center">2</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">RunttimeInvisibleAnnotations</td>
<td align="center">ClassFile,field_info,method_info</td>
<td align="center">2</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">RunttimeVisibleParameterAnnotations</td>
<td align="center">method_info</td>
<td align="center">2</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">RunttimeInvisibleParameterAnnotations</td>
<td align="center">method_info</td>
<td align="center">2</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">AnnotationDefault</td>
<td align="center">method_info</td>
<td align="center">2</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">StackMapTable</td>
<td align="center">Code</td>
<td align="center">1</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">BootstrapMethods</td>
<td align="center">ClassFile</td>
<td align="center">1</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">RunttimeVisibleTypeAnnotations</td>
<td align="center">ClassFile,field_info,method_info,Code</td>
<td align="center">2</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">RunttimeInvisibleTypeAnnotations</td>
<td align="center">ClassFile,field_info,method_info,Code</td>
<td align="center">2</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">MethodParameters</td>
<td align="center">method_info</td>
<td align="center">2</td>
<td align="center">8</td>
</tr>
</tbody></table>
<h3 id="4-2-属性定义"><a href="#4-2-属性定义" class="headerlink" title="4.2 属性定义"></a>4.2 属性定义</h3><h4 id="4-2-1-Deprecated和Synthetic属性"><a href="#4-2-1-Deprecated和Synthetic属性" class="headerlink" title="4.2.1 Deprecated和Synthetic属性"></a>4.2.1 Deprecated和Synthetic属性</h4><p><code>Deprecated</code> 是最简单的两种属性之一，仅起标记作用，不包含任何数据。</p>
<p>它的结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Deprecated_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于不包含任何数据，所以attribute_length的值必须是0。</p>
<p><code>Deprecated</code> 属性用于指出类、接口、字段或方法已经不建议使用，编译器等工具可以根据Deprecated属性输出警告信息。</p>
<p>J2SE 5.0之前,可以使用 Javadoc 提供的 <code>@deprecated</code> 标签指示编译器给类、接口、字段或方法添加 <code>Deprecated</code> 属性。</p>
<p>从J2SE 5.0开始，可以使用 <code>@Deprecated</code> 注解。</p>
<p><code>Deprecated</code> 属性不包含数据，所以它的 <code>readFrom</code> 实现为空就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-Synthetic"><a href="#4-2-2-Synthetic" class="headerlink" title="4.2.2 Synthetic"></a>4.2.2 Synthetic</h4><p><code>Synthetic</code> 是最简单的两种属性之一，仅起标记作用，不包含任何数据。</p>
<p>它的结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Synthetic_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Synthetic</code> 属性用来标记源文件中不存在、由编译器生成的类成员，引入 <code>Synthetic</code> 属性主要是为了支持嵌套类和嵌套接口。</p>
<p><code>Synthetic</code> 属性不包含数据，所以它的 <code>readFrom</code> 也是为空：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-SourceFile"><a href="#4-2-3-SourceFile" class="headerlink" title="4.2.3 SourceFile"></a>4.2.3 SourceFile</h4><p><code>SourceFile</code> 是可选定长属性，只会出现在 <code>ClassFile</code> 结构中，用于指出源文件名。</p>
<p>其结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SourceFile_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 sourcefile_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attribute_length</code> 的值必须是2。</p>
<p><code>sourcefile_index</code> 是常量池索引，指向一个 <code>CONSTANT_Utf8_info</code> 常量。</p>
<p><code>SourceFile</code> 属性读取很简单，直接读就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    length = reader.readUint32();</span><br><span class="line">    nameIndex = reader.readUint16();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-ConstantValue"><a href="#4-2-4-ConstantValue" class="headerlink" title="4.2.4 ConstantValue"></a>4.2.4 ConstantValue</h4><p><code>ConstantValue</code> 是定长属性，只会出现在 <code>field_info</code> 结构中，用于表示常量表达式的值。</p>
<p>其结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attribute_length</code> 的值必须是2。</p>
<p><code>constantvalue_index</code> 是常量池索引，指向某一个类型定义，但具体指向哪种常量因字段类型而异。</p>
<p><code>ConstantValue</code> 属性读取也很简单，也是直接读就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    length = reader.readUint32();</span><br><span class="line">    constantIndex = reader.readUint16();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-Code"><a href="#4-2-5-Code" class="headerlink" title="4.2.5 Code"></a>4.2.5 Code</h4><p><code>Code</code> 是变长属性，只存在于 <code>method_info</code> 结构中。<code>Code</code> 属性中存放字节码等方法相关信息。</p>
<p>其结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 max_stack;</span><br><span class="line">    u2 max_locals;</span><br><span class="line">    u4 code_length;</span><br><span class="line">    u1 code[code_length];</span><br><span class="line">    u2 exception_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>max_stack</code> 给出操作数栈的最大深度；<code>max_locals</code>给出局部变量表大小；</p>
<p>接着是字节码，存在u1表中；最后是异常处理表和属性表。</p>
<p><code>Code</code> 属性结构相对复杂一些，有几层结构，读取起来有点麻烦：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    length = reader.readUint32();</span><br><span class="line">    maxStack = reader.readUint16();</span><br><span class="line">    maxLocals = reader.readUint16();</span><br><span class="line">    codeLength = reader.readUint32();</span><br><span class="line">    codes = reader.readBytes(codeLength);</span><br><span class="line">    exceptionLength = reader.readUint16();</span><br><span class="line">    exceptionEntries = <span class="keyword">new</span> ExceptionTableEntry[exceptionLength.value()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exceptionEntries.length; i++) &#123;</span><br><span class="line">        exceptionEntries[i] = readExceptionEntry(reader);</span><br><span class="line">    &#125;</span><br><span class="line">    attributeInfoTable = <span class="keyword">new</span> AttributeInfoTable();</span><br><span class="line">    attributeInfoTable.readFrom(reader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ExceptionTableEntry <span class="title">readExceptionEntry</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    ExceptionTableEntry entry = <span class="keyword">new</span> ExceptionTableEntry();</span><br><span class="line">    entry.setStartPC(reader.readUint16());</span><br><span class="line">    entry.setEndPC(reader.readUint16());</span><br><span class="line">    entry.setHandlerPC(reader.readUint16());</span><br><span class="line">    entry.setCatchPC(reader.readUint16());</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-6-Exceptions"><a href="#4-2-6-Exceptions" class="headerlink" title="4.2.6 Exceptions"></a>4.2.6 Exceptions</h4><p><code>Exceptions</code> 是变长属性，记录方法抛出的异常表。</p>
<p>其结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exceptions_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 number_of_exceptions;</span><br><span class="line">    u2 exception_index_table[number_of_exceptions];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Exceptions</code> 属性简单，直接读取即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    length = reader.readUint32();</span><br><span class="line">    numberOfExceptions = reader.readUint16();</span><br><span class="line">    exceptionIndexTable = reader.readUint16s(numberOfExceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-7-LineNumberTable"><a href="#4-2-7-LineNumberTable" class="headerlink" title="4.2.7 LineNumberTable"></a>4.2.7 LineNumberTable</h4><p><code>LineNumberTable</code> 属性表存放方法的行号信息。</p>
<p>结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 line_number;</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LineNumberTable</code> 属性表不算复杂，可以直接读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFrom</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    length = reader.readUint32();</span><br><span class="line">    lineNumberLength = reader.readUint16();</span><br><span class="line">    lineNumberEntries = <span class="keyword">new</span> LineNumberTableEntry[lineNumberLength.value()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineNumberEntries.length; i++) &#123;</span><br><span class="line">        lineNumberEntries[i] = readLineNumberTableEntry(reader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LineNumberTableEntry <span class="title">readLineNumberTableEntry</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    LineNumberTableEntry entry = <span class="keyword">new</span> LineNumberTableEntry();</span><br><span class="line">    entry.setStartPC(reader.readUint16());</span><br><span class="line">    entry.setLineNumber(reader.readUint16());</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>相对于常量来说，属性的结构要稍微复杂一些，毕竟是可以扩展的，不像常量池常量那样基本都是固定的。</p>
<p>虽然属性的机构稍微复杂一些，但是层次还是比较清晰的。</p>
<h2 id="五、单元测试"><a href="#五、单元测试" class="headerlink" title="五、单元测试"></a>五、单元测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFileStructureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> bt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> l = <span class="number">4L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> f = <span class="number">5.0F</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> d = <span class="number">6.0</span>;</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">short</span> s = -<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i = s;</span><br><span class="line">        <span class="keyword">int</span> ii = s &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="keyword">long</span> ss = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> si = ss | i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class File Test&quot;</span> + i + <span class="string">&quot; &quot;</span> + ii + <span class="string">&quot; &quot;</span> + si);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getClassName</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String jreOption = <span class="keyword">null</span>;</span><br><span class="line">        String cpOption = <span class="string">&quot;C:\\IdeaProjects\\self-jvm\\target;C:\\IdeaProjects\\self-jvm\\target\\classes&quot;</span>;</span><br><span class="line">        String bootClassName = <span class="string">&quot;java\\lang\\Object&quot;</span>;</span><br><span class="line">        String userClassName = <span class="string">&quot;com\\wjd\\classfile\\ClassFileStructureTest&quot;</span>;</span><br><span class="line">        Classpath classpath = <span class="keyword">new</span> Classpath(jreOption, cpOption);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bootClassBytes = classpath.readClass(bootClassName);</span><br><span class="line">        ClassReader bootReader = <span class="keyword">new</span> ClassReader(bootClassBytes);</span><br><span class="line">        ClassFile bootClassFile = ClassFile.parse(bootReader);</span><br><span class="line">        assertEquals(<span class="string">&quot;Class name error&quot;</span>, <span class="string">&quot;java/lang/Object&quot;</span>, bootClassFile.getClassName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] userClassBytes = classpath.readClass(userClassName);</span><br><span class="line">        ClassReader userReader = <span class="keyword">new</span> ClassReader(userClassBytes);</span><br><span class="line">        ClassFile userClassFile = ClassFile.parse(userReader);</span><br><span class="line">        assertEquals(<span class="string">&quot;Class name error&quot;</span>, <span class="string">&quot;com/wjd/classfile/ClassFileStructureTest&quot;</span>, userClassFile.getClassName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>class 文件：</p>
<ul>
<li>Java 虚拟机规范中所指的 class 文件，并非特指位于磁盘中的 .class 文件，而是泛指任何格式符合规范的 class 数据。它实际上可以通过网络下载，从数据库加载，甚至是在运行中直接生成等方式来获取 class 文件<ul>
<li>构成 class 文件的基本数据单位是字节，可以把整个 class 文件当成一个字节流来处理</li>
<li>数据由连续多个字节构成，这些数据在 class 文件中以大端（big-endian）方式存储</li>
</ul>
</li>
<li>为了描述 class 文件格式，Java 虚拟机规范定义了 u1、u2 和 u4 三种数据类型来表示1、2和4字节无符号整数</li>
<li>相同类型的多条数据一般按表（table）的形式存储在 class 文件中</li>
<li>表由表头和表项（item）构成，表头是 u2 或 u4 整数</li>
</ul>
<p>常量池：</p>
<ul>
<li>常量池里面存放着各式各样的常量信息，包括数字和字符串常量、类和接口名、字段和方法名等等</li>
<li>常量池实际上也是一个表。表头给出的常量池大小比实际大1<ul>
<li>假设表头给出的值是n，那么常量池的实际大小是n–1。也就是说，常量池的有效的常量池索引是1~n–1。0是无效索引，表示不指向任何常量</li>
<li><code>long</code> 和 <code>double</code> 各占两个位置。也就是说，如果常量池中存在这两种常量，实际的常量数量比n–1还要少，而且1~n–1的某些数也会变成无效索引</li>
</ul>
</li>
<li>按照结构，常量池的常量可以分为2种，一种是存放有数据的字面常量（literal），一种是存放索引的符号引用常量（symbolic reference）<ul>
<li>字面量包括数字常量和字符串常量，符号引用包括类和接口名、字段和方法信息等</li>
<li>像整数、浮点数、UTF8字节等，都属于字面常量，直接存放数据</li>
<li>而像字符串、类型、方法等都是引用常量，不直接存放数据，只保存指向数据的索引</li>
<li>除了字面量，其他引用常量都是通过索引直接或间接指向 <code>CONSTANT_Utf8_info</code> 常量</li>
</ul>
</li>
</ul>
<p>属性：</p>
<ul>
<li>Java虚拟机规范没有使用tag，而是使用属性名来区别不同的属性</li>
<li>常量是由Java虚拟机规范严格定义的，共有14种。但属性是可以扩展的，不同的虚拟机实现可以定义自己的属性类型</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>02_查找class文件</title>
    <url>/lang/java/jvm/selfjvm/02_classpath/</url>
    <content><![CDATA[<h1 id="查找class文件"><a href="#查找class文件" class="headerlink" title="查找class文件"></a>查找class文件</h1><p>加载允许一个类，必须把它相关的依赖类也加载进来，比如父类、成员类等。</p>
<p>Java虚拟机规范并没有规定去哪里寻找类，所以不同虚拟机可以采用不同的方法。</p>
<h2 id="一、类加载路径"><a href="#一、类加载路径" class="headerlink" title="一、类加载路径"></a>一、类加载路径</h2><p>Oracle的Java虚拟机是根据类路径（classpath）来搜索类，按照搜索顺序可分为3类：</p>
<ol>
<li>启动类路径（bootstrasp classpath）：默认目录是 <code>jre\lib</code>，即Java标准库（大部分在rt.jar里）所在位置</li>
<li>扩展类路径（extension classpath）：默认目录是 <code>jre\lib\ext</code>，即Java扩展机制的类所在位置</li>
<li>用户类路径（user classpath）：默认当前目录，即自己实现的类、以及第三方类库所在位置</li>
</ol>
<span id="more"></span>

<p>可以通过参数 <code>-Xbootclasspath</code> 来修改启动类路径。</p>
<p>可以设置环境变量 <code>CLASSPATH</code> 来修改用户类路径，也可以使用参数 <code>-classpath/-cp</code> 来设置用户类路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp path\classes ...</span><br><span class="line">java -cp path\lib1.jar ...</span><br><span class="line">java -cp path\lib2.zip ...</span><br></pre></td></tr></table></figure>

<p><code>-classpath/-cp</code> 既可以使用目录，也可以指向 jar 文件或者 zip 文件，可以同时指定多个目录或文件。</p>
<p>指定多个路径，需要分隔符分开，不同操作系统的分隔符不一样，在 windows 下是分号 <code>;</code>，在类 Unix 下是冒号 <code>:</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp path\classes;path\lib1.jar;path\lib2.zip ...</span><br></pre></td></tr></table></figure>

<p>从 Java 6 开始，还可以使用通配符（*）指定某个目录下的所有 jar 文件（注意，不会递归子目录的 jar 文件）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp path\classes;path\lib\* ...</span><br></pre></td></tr></table></figure>

<h2 id="二、类文件查找"><a href="#二、类文件查找" class="headerlink" title="二、类文件查找"></a>二、类文件查找</h2><h3 id="2-1-添加jre参数"><a href="#2-1-添加jre参数" class="headerlink" title="2.1 添加jre参数"></a>2.1 添加jre参数</h3><p>首先在命令行 <code>Cmd</code> 类中增加一个非标准参数 <code>Xjre</code>，表示 jre 所在的目录路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">options.addOption(Option.builder(<span class="string">&quot;Xjre&quot;</span>)</span><br><span class="line">                .hasArg().desc(<span class="string">&quot;jre directory&quot;</span>)</span><br><span class="line">                .type(String.class)</span><br><span class="line">                .build());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String jreOption;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jre路径</span></span><br><span class="line"><span class="keyword">if</span> (line.hasOption(<span class="string">&quot;Xjre&quot;</span>)) &#123;</span><br><span class="line">    jreOption = line.getOptionValue(<span class="string">&quot;Xjre&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-查找入口类"><a href="#2-2-查找入口类" class="headerlink" title="2.2 查找入口类"></a>2.2 查找入口类</h3><p>其次，要实现不同类加载路径的入口类，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取class文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className class的完整名称（java/lang/Object）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] readClass(String className) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">string</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后有4种入口实现，分别对应上面几种类加载路径的写法：</p>
<ul>
<li>DirEntry：查找 class 的目录</li>
<li>ZipEntry：查找 class 的 zip 或 jar 文件</li>
<li>CompositeEntry：多种查找路径的组合，比如目录，或 zip，或 jar</li>
<li>WildcardEntry：通配符路径，指定某个目录下的所有子 zip 或 jar 文件</li>
</ul>
<p>各自的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目录入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirEntry</span> <span class="keyword">implements</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目录绝对路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String absPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirEntry</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.absPath = Paths.get(path).toAbsolutePath().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readClass(String className) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Path path = Paths.get(absPath, className);</span><br><span class="line">        <span class="keyword">if</span> (Files.exists(path)) &#123;</span><br><span class="line">            System.out.println(className + <span class="string">&quot; found in &quot;</span> + string());</span><br><span class="line">            <span class="keyword">return</span> Files.readAllBytes(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> absPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * zip或jar入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipEntry</span> <span class="keyword">implements</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件绝对路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String absPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZipEntry</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.absPath = Paths.get(path).toAbsolutePath().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readClass(String className) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(absPath);</span><br><span class="line">             BufferedInputStream buf = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">             ArchiveInputStream in = <span class="keyword">new</span> ArchiveStreamFactory().createArchiveInputStream(buf)) &#123;</span><br><span class="line">            ArchiveEntry entry;</span><br><span class="line">            <span class="keyword">while</span> ((entry = in.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!in.canReadEntryData(entry)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 转成路径格式一样的才能对比得上完整名称</span></span><br><span class="line">                String entryPath = Paths.get(entry.getName()).toString();</span><br><span class="line">                <span class="keyword">if</span> (entryPath.equals(className)) &#123;</span><br><span class="line">                    System.out.println(className + <span class="string">&quot; found in &quot;</span> + string());</span><br><span class="line">                    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    IOUtils.copy(in, out);</span><br><span class="line">                    <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArchiveException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> absPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeEntry</span> <span class="keyword">implements</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径选项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String pathOptions;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子入口列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Entry&gt; entries;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompositeEntry</span><span class="params">(String pathOptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pathOptions = pathOptions;</span><br><span class="line">        <span class="keyword">this</span>.initEntries();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readClass(String className) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (entries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Entry e : entries) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = e.readClass(className);</span><br><span class="line">            <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> bytes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (entries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pathOptions;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;CompositeEntry [&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Entry e : entries) &#123;</span><br><span class="line">            sb.append(e.string()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化Entries列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] paths = pathOptions.split(File.pathSeparator);</span><br><span class="line">        entries = <span class="keyword">new</span> ArrayList&lt;&gt;(paths.length);</span><br><span class="line">        <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">            entries.add(EntryFactory.newEntry(path));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通配符入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardEntry</span> <span class="keyword">implements</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绝对路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String absPath;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子入口列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Entry&gt; entries;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WildcardEntry</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 去掉后面的通配符</span></span><br><span class="line">        String p = path.substring(<span class="number">0</span>, path.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.absPath = Paths.get(p).toAbsolutePath().toString();</span><br><span class="line">        initEntries();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readClass(String className) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (entries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Entry e : entries) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = e.readClass(className);</span><br><span class="line">            <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> bytes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (entries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> absPath;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;WildcardEntry [&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Entry e : entries) &#123;</span><br><span class="line">            sb.append(e.string()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化Entries列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(absPath);</span><br><span class="line">        <span class="keyword">if</span> (!dir.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目录下所有的zip或jar文件</span></span><br><span class="line">        File[] files = dir.listFiles((dir1, name) -&gt; &#123;</span><br><span class="line">            String lowerName = name.toLowerCase();</span><br><span class="line">            <span class="keyword">return</span> lowerName.endsWith(<span class="string">&quot;.zip&quot;</span>) || lowerName.endsWith(<span class="string">&quot;.jar&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (files == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成所有子入口实例</span></span><br><span class="line">        entries = <span class="keyword">new</span> ArrayList&lt;&gt;(files.length);</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            String filePath = file.getAbsolutePath();</span><br><span class="line">            entries.add(EntryFactory.newEntry(filePath));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-类查找实现"><a href="#2-3-类查找实现" class="headerlink" title="2.3 类查找实现"></a>2.3 类查找实现</h3><p>查找入口搞定后，接下来就是真正的类查找实现了。</p>
<p>首先，对命令行参数进行解析，包括设置 jre 目录、启动类路径、用户类路径等，并创建对应的入口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Classpath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动类路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry bootEntry;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展类路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry extEntry;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry userEntry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动路径选项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String jreOption;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类路径选项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String cpOptions;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Classpath</span><span class="params">(String jreOption, String cpOptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jreOption = jreOption;</span><br><span class="line">        <span class="keyword">this</span>.cpOptions = cpOptions;</span><br><span class="line">        initOptions();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * classpath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cpOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化选项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        parseBootAndExtClasspath();</span><br><span class="line">        parseUserClasspath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析启动类路径和扩展类路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBootAndExtClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String jrePath = getJrePath();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动类路径（jre/lib/*）</span></span><br><span class="line">        Path bootPath = Paths.get(jrePath, <span class="string">&quot;lib&quot;</span>);</span><br><span class="line">        String bootDir = bootPath.toAbsolutePath() + File.separator + <span class="string">&quot;*&quot;</span>;</span><br><span class="line">        bootEntry = EntryFactory.newEntry(bootDir);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩展类路径（jre/lib/ext/*）</span></span><br><span class="line">        Path extPath = Paths.get(jrePath, <span class="string">&quot;lib&quot;</span>, <span class="string">&quot;ext&quot;</span>);</span><br><span class="line">        String extDir = extPath.toAbsolutePath() + File.separator + <span class="string">&quot;*&quot;</span>;</span><br><span class="line">        extEntry = EntryFactory.newEntry(extDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析用户类路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseUserClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cpOptions == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(cpOptions)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用户类路径（-classpath/-cp）</span></span><br><span class="line">        userEntry = EntryFactory.newEntry(cpOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取jre文件夹路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> jre文件夹路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getJrePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Path path;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户自定义路径</span></span><br><span class="line">        <span class="keyword">if</span> (jreOption != <span class="keyword">null</span>) &#123;</span><br><span class="line">            path = Paths.get(jreOption);</span><br><span class="line">            <span class="keyword">if</span> (Files.exists(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> path.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 系统环境变量</span></span><br><span class="line">        String jdkPath = System.getenv(<span class="string">&quot;JAVA_HOME&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (jdkPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            path = Paths.get(jdkPath, <span class="string">&quot;jre&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (Files.exists(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> path.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后尝试在当前路径下寻找jre目录</span></span><br><span class="line">        path = Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;jre&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Files.exists(path)) &#123;</span><br><span class="line">            <span class="keyword">return</span> path.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找不到jre的路径</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can not found jre folder!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，就是实际的类查找流程实现了，它是按照 <code>启动类路径 -&gt; 扩展类路径 -&gt; 用户类路径</code> 去查找的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Classpath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取class文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className class的完整名称（java/lang/Object）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readClass(String className) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换成文件路径</span></span><br><span class="line">        String classPath = Paths.get(className).toString();</span><br><span class="line">        String classFileName = classPath + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动类加载</span></span><br><span class="line">        <span class="keyword">if</span> (bootEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bytes = bootEntry.readClass(classFileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩展类加载</span></span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span> &amp;&amp; extEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bytes = extEntry.readClass(classFileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户类加载</span></span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span> &amp;&amp; userEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bytes = userEntry.readClass(classFileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;not found class &quot;</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，创建入口实例的方法统一放到了一个工厂类里面，为了方便查看和修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据参数生成指定的Entry类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entryOption 选项参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 具体的Entry实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title">newEntry</span><span class="params">(String entryOption)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多选项路径</span></span><br><span class="line">        <span class="keyword">if</span> (entryOption.contains(File.pathSeparator)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CompositeEntry(entryOption);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通配符路径</span></span><br><span class="line">        <span class="keyword">if</span> (entryOption.endsWith(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WildcardEntry(entryOption);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// zip或者jar</span></span><br><span class="line">        String lowName = entryOption.toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (lowName.endsWith(<span class="string">&quot;.zip&quot;</span>) || lowName.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ZipEntry(entryOption);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件夹路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirEntry(entryOption);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的类查找代码差不多就是这样了，后面就是要测试实际的效果了。</p>
<h3 id="2-4-单元测试"><a href="#2-4-单元测试" class="headerlink" title="2.4 单元测试"></a>2.4 单元测试</h3><p>下面就是单元测试的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClasspathTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readClass</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String jreOption = <span class="keyword">null</span>;</span><br><span class="line">        String cpOption = <span class="string">&quot;C:\\IdeaProjects\\self-jvm\\target;C:\\IdeaProjects\\self-jvm\\target\\classes&quot;</span>;</span><br><span class="line">        String bootClassName = <span class="string">&quot;java\\lang\\Object&quot;</span>;</span><br><span class="line">        String userClassName = <span class="string">&quot;com\\wjd\\cmd\\Cmd&quot;</span>;</span><br><span class="line">        Classpath classpath = <span class="keyword">new</span> Classpath(jreOption, cpOption);</span><br><span class="line">        Assert.assertNotNull(<span class="string">&quot;Object is null&quot;</span>, classpath.readClass(bootClassName));</span><br><span class="line">        Assert.assertNotNull(<span class="string">&quot;Cmd is null&quot;</span>, classpath.readClass(userClassName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WildcardEntry [D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\charsets.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\deploy.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\javaws.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\jce.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\jfr.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\jfxswt.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\jsse.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\management-agent.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\plugin.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\resources.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\rt.jar]</span><br><span class="line"></span><br><span class="line">WildcardEntry [D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\access-bridge-64.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\cldrdata.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\dnsns.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\jaccess.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\jfxrt.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\localedata.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\nashorn.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\sunec.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\sunjce_provider.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\sunmscapi.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\sunpkcs11.jar, D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\ext\zipfs.jar]</span><br><span class="line"></span><br><span class="line">CompositeEntry [C:\IdeaProjects\self-jvm\target, C:\IdeaProjects\self-jvm\target\classes]</span><br><span class="line"></span><br><span class="line">java\lang\Object.class found in D:\Program Files\JDK\jdk1.8.0_25_x64\jre\lib\rt.jar</span><br><span class="line"></span><br><span class="line">com\wjd\cmd\Cmd.class found in C:\IdeaProjects\self-jvm\target\classes</span><br></pre></td></tr></table></figure>

<p>看起来，实际加载的包和最后查找到的类路径都是对的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>Oracle的Java虚拟机是根据类路径（classpath）来搜索类，按照搜索顺序可分为3类：</p>
<ol>
<li>启动类路径（bootstrasp classpath）：默认目录是 <code>jre\lib</code>，即Java标准库（大部分在rt.jar里）所在位置</li>
<li>扩展类路径（extension classpath）：默认目录是 <code>jre\lib\ext</code>，即Java扩展机制的类所在位置</li>
<li>用户类路径（user classpath）：默认当前目录，即自己实现的类、以及第三方类库所在位置</li>
</ol>
</li>
<li><p><code>-classpath/-cp</code> 既可以使用目录，也可以指向 jar 文件或者 zip 文件，可以同时指定多个目录或文件。</p>
</li>
<li><p>指定多个路径，需要分隔符分开，不同操作系统的分隔符不一样，在 windows 下是分号 <code>;</code>，在类 Unix 下是冒号 <code>:</code></p>
</li>
<li><p>从 Java 6 开始，还可以使用通配符（*）指定某个目录下的所有 jar 文件（注意，不会递归子目录的 jar 文件）</p>
</li>
<li><p>具体代码实现，有4种入口类，分别对应几种类加载路径的写法：</p>
<ul>
<li>DirEntry：查找 class 的目录</li>
<li>ZipEntry：查找 class 的 zip 或 jar 文件</li>
<li>CompositeEntry：多种查找路径的组合，比如目录，或 zip，或 jar</li>
<li>WildcardEntry：通配符路径，指定某个目录下的所有子 zip 或 jar 文件</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：上面的代码实现，为了简单，有些地方没做参数校验，默认传入参数的格式都是正确的（好吧。。实际是我懒得写了，先把功能实现了再说~~）</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>01_命令行工具</title>
    <url>/lang/java/jvm/selfjvm/01_cmd/</url>
    <content><![CDATA[<h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><p>Java虚拟机启动时，需要指定类启动应用程序。</p>
<p>但是Java虚拟机规范中并没有明确规定，怎么指定类启动应用程序，也就是主类（包含<code>main</code>方法的类）。</p>
<p>Oracle的虚拟机实现是通过 java 命令来启动的，主类名由命令函参数指定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java [-options] class [args]</span><br><span class="line">java [-options] -jar jarfile [args]</span><br><span class="line">javaw [-options] class [args]</span><br><span class="line">javaw [-options] -jar jarfile [args]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ul>
<li><p><code>class</code>：主类名</p>
</li>
<li><p><code>jarfile</code>：jar包文件名</p>
</li>
<li><p><code>args</code>：<code>main()</code> 方法参数</p>
</li>
<li><p>标准选项比较稳定，不会轻易变动</p>
</li>
<li><p>非标准选项以 <code>-X</code> 开头，很有可能在未来版本中发生变更</p>
</li>
<li><p>非标准选项中的高级选项，以 <code>-XX</code> 开头</p>
</li>
</ul>
<h2 id="一、编写命令行工具"><a href="#一、编写命令行工具" class="headerlink" title="一、编写命令行工具"></a>一、编写命令行工具</h2><p>目前主要添加几个命令参数：</p>
<ul>
<li>-help</li>
<li>-version</li>
<li>-classpath</li>
</ul>
<p>另外，启动程序主类名也是参数之一，并且必须放在所有参数中的第一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> helpFlag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> versionFlag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> String cpOption = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> String mainClass = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>命令行参数的生成和解析，采用了 Apache 的一个 <code>commons-cli</code> 命令行工具包。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cmd</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Options options;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        options = <span class="keyword">new</span> Options();</span><br><span class="line">        options.addOption(<span class="keyword">new</span> Option(<span class="string">&quot;help&quot;</span>, <span class="keyword">false</span>, <span class="string">&quot;print help message&quot;</span>));</span><br><span class="line">        options.addOption(<span class="keyword">new</span> Option(<span class="string">&quot;?&quot;</span>, <span class="keyword">false</span>, <span class="string">&quot;print help message&quot;</span>));</span><br><span class="line">        options.addOption(<span class="keyword">new</span> Option(<span class="string">&quot;version&quot;</span>, <span class="keyword">false</span>, <span class="string">&quot;print version and exit&quot;</span>));</span><br><span class="line">        options.addOption(Option.builder(<span class="string">&quot;classpath&quot;</span>)</span><br><span class="line">                .hasArg().desc(<span class="string">&quot;classpath&quot;</span>)</span><br><span class="line">                .type(String.class)</span><br><span class="line">                .build());</span><br><span class="line">        options.addOption(Option.builder(<span class="string">&quot;cp&quot;</span>)</span><br><span class="line">                .hasArg().desc(<span class="string">&quot;classpath&quot;</span>)</span><br><span class="line">                .type(String.class)</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> helpFlag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> versionFlag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String cpOption = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String mainClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String[] args = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析命令行参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析命令行参数</span></span><br><span class="line">            CommandLineParser parser = <span class="keyword">new</span> DefaultParser();</span><br><span class="line">            CommandLine line = parser.parse(options, args);</span><br><span class="line">            <span class="keyword">this</span>.args = Arrays.copyOfRange(args, <span class="number">1</span>, args.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印帮助信息</span></span><br><span class="line">            <span class="keyword">if</span> (line.hasOption(<span class="string">&quot;help&quot;</span>) || line.hasOption(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                helpFlag = <span class="keyword">true</span>;</span><br><span class="line">                printHelp();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 版本信息</span></span><br><span class="line">            <span class="keyword">if</span> (line.hasOption(<span class="string">&quot;version&quot;</span>)) &#123;</span><br><span class="line">                versionFlag = <span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;version 0.0.1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动程序主类名</span></span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mainClass = args[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// classpath路径</span></span><br><span class="line">            <span class="keyword">if</span> (line.hasOption(<span class="string">&quot;classpath&quot;</span>)) &#123;</span><br><span class="line">                cpOption = line.getOptionValue(<span class="string">&quot;classpath&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.hasOption(<span class="string">&quot;cp&quot;</span>)) &#123;</span><br><span class="line">                cpOption = line.getOptionValue(<span class="string">&quot;cp&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印所有参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;helpFlag = &quot;</span> + helpFlag);</span><br><span class="line">            System.out.println(<span class="string">&quot;versionFlag = &quot;</span> + versionFlag);</span><br><span class="line">            System.out.println(<span class="string">&quot;mainClass = &quot;</span> + mainClass);</span><br><span class="line">            System.out.println(<span class="string">&quot;classpath = &quot;</span> + cpOption);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印命令行帮助信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HelpFormatter formatter = <span class="keyword">new</span> HelpFormatter();</span><br><span class="line">        formatter.printHelp(<span class="string">&quot;self-jvm&quot;</span>, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、添加测试类"><a href="#二、添加测试类" class="headerlink" title="二、添加测试类"></a>二、添加测试类</h2><p>测试类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmdTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] args = <span class="keyword">new</span> String[]&#123; <span class="string">&quot;com.wjd.cmd.Cmd&quot;</span>, <span class="string">&quot;-classpath&quot;</span>, <span class="string">&quot;/projects&quot;</span> &#125;;</span><br><span class="line">        Cmd cmd = <span class="keyword">new</span> Cmd();</span><br><span class="line">        cmd.parse(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cmd cmd = <span class="keyword">new</span> Cmd();</span><br><span class="line">        cmd.printHelp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试的打印结果大概是这样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># parse</span><br><span class="line">helpFlag = false</span><br><span class="line">versionFlag = false</span><br><span class="line">mainClass = com.wjd.cmd.Cmd</span><br><span class="line">classpath = /projects</span><br><span class="line"></span><br><span class="line"># printHelp</span><br><span class="line">usage: self-jvm</span><br><span class="line"> -?                 print help message</span><br><span class="line"> -classpath &lt;arg&gt;   classpath</span><br><span class="line"> -cp &lt;arg&gt;          classpath</span><br><span class="line"> -help              print help message</span><br><span class="line"> -version           print version and exit</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack</title>
    <url>/lang/java/source/jdk8/collection/Stack/</url>
    <content><![CDATA[<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Stack</code> 继承自 <code>Vector</code> 类，因此拥有 <code>Vector</code> 的所有特性。</p>
<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p><code>Stack</code> 除了增加几个栈特用的方法以外，其他的和 <code>Vector</code> 都一样，而增加的这几个方法，内部实际上也是调用的 <code>Vector</code> 的方法。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    addElement(item);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E obj;</span><br><span class="line">    <span class="keyword">int</span> len = size();</span><br><span class="line">    obj = peek();</span><br><span class="line">    removeElementAt(len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = size();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 <code>Vector</code> 的保持一致，<code>Stack</code> 添加的方法也加上了同步锁 <code>synchronized</code>，避免并发问题。</p>
<p>不过 <code>push</code> 方法并没有加上同步锁，这个倒是有点出乎意料，或许是因为它内部调用的方法 <code>addElement</code> 已经加锁的原因吧。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector</title>
    <url>/lang/java/source/jdk8/collection/Vector/</url>
    <content><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>定义上和 <code>ArrayList</code> 一样，继承同一个父类和实现相同的接口。</p>
<h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><span id="more"></span>

<p>实际上，<code>Vector</code> 和 <code>ArrayList</code> 的实现代码基本一致，底层数据结构都是数组，而且接口方法的实现代码都差不多。</p>
<p>目前来说，也就发现了 <code>Vector</code> 和 <code>ArrayList</code> 的几点区别。</p>
<h3 id="2-1-同步锁"><a href="#2-1-同步锁" class="headerlink" title="2.1 同步锁"></a>2.1 同步锁</h3><p>第1点是同步锁的区别，<code>Vector</code> 的大部分方法都使用了 <code>synchronized</code> 来加锁，用于避免并发访问和修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>ArrayList</code> 的方法都是没有 <code>synchronized</code> 加持的，也就是完全不考虑并发同步的问题。所以一般情况下，<code>ArrayList</code> 相比于 <code>Vector</code> 在取数存数上的效率会高一些。</p>
<h3 id="2-2-迭代器"><a href="#2-2-迭代器" class="headerlink" title="2.2 迭代器"></a>2.2 迭代器</h3><p><code>ArrayList</code> 使用的当前最常用的迭代器接口 <code>Iterator</code>。</p>
<p>而 <code>Vector</code> 则是以前的旧枚举迭代器 <code>Enumeration</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;E&gt;() &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count &lt; elementCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; elementCount) &#123;</span><br><span class="line">                    <span class="keyword">return</span> elementData(count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;Vector Enumeration&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也不是说 <code>Iterator</code> 就比 <code>Enumeration</code> 好。只是 <code>Iterator</code> 相比于 <code>Enumeration</code>，不仅增加了 <code>remove</code> 方法，而且 接口方法名称也更精简。</p>
<p>在使用体验上，<code>Iterator</code> 确实会更好用一些。 </p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>PriorityQueue</title>
    <url>/lang/java/source/jdk8/collection/PriorityQueue/</url>
    <content><![CDATA[<h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从名称就可以看出来，这是个优先队列，也就是按照从小到大（或从大到小）排序的队列。</p>
<span id="more"></span>

<p>继承的类就是队列 <code>Queue</code> 的模板实现类 <code>AbstractQueue</code>。</p>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>既然是有顺序的队列，那么它的底层数据结构是什么样的呢？</p>
<p>其实还是数组~~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>学过数据结构的话，应该知道，数组也可以用于表示树结构。就比如数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>就可以表示下面的完全二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   / \   / \</span><br><span class="line">  4   5 6   7</span><br><span class="line"> / \</span><br><span class="line">8   9</span><br></pre></td></tr></table></figure>

<p>假如当前索引是 <code>k</code>，那么父节点索引就是 <code>(k - 1) / 2</code>，2个子节点索引分别是 <code>(k * 2) + 1</code> 和 <code>(k * 2) + 2</code>。</p>
<p>用例子来说，假如当前索引是 1，那么父节点索引就是 <code>(1 - 1) / 2 = 0</code>，子节点索引是 <code>(1 * 2) + 1 = 3</code> 和 <code>(1 * 2) + 2 = 4</code>。</p>
<p>完全二叉树在数据结构中，常用于表示堆（当然，完全多叉树也可以）。</p>
<p>堆也是可以有序的，一般可以分为最大值堆和最小值堆：</p>
<ol>
<li>最小值堆，父节点都不比子节点的值大；</li>
<li>最大值堆，父节点都不比子节点的值小。</li>
</ol>
<p>例如上面的例子 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>，就是最小值堆。</p>
<p>优先队列 <code>PriorityQueue</code> 实际上也是用有序堆来实现的。</p>
<p>不过具体是最小值堆，还是最大值堆，就得看优先队列的比较器函数是什么了。</p>
<h3 id="2-2-扩容机制"><a href="#2-2-扩容机制" class="headerlink" title="2.2 扩容机制"></a>2.2 扩容机制</h3><p>底层结构是数组，那也就是和 <code>ArrayList</code> 一样，当元素增多时，就需要进行扩容。</p>
<p>优先队列 <code>PriorityQueue</code> 的扩容机制，基本和 <code>ArrayList</code> 差不多，只有些许区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先队列 <code>PriorityQueue</code> 对容量比较小的情况进行了特别处理，其他则和 <code>ArrayList</code> 一样：</p>
<ol>
<li>当队列容量还比较小（&lt; 64）时，就直接扩容 1 倍（oldCapacity + 2）；</li>
<li>否则就扩容 0.5 倍（oldCapacity &gt;&gt; 1）。</li>
</ol>
<p>举2个列子说明：</p>
<p>当 <code>queue.length</code> 是 <code>9</code> 时，因为 <code>9 &lt; 64</code>，所以扩容 1 倍，新容量就是 <code>9 + (9 + 2) = 20</code>。</p>
<p>当 <code>queue.length</code> 是 <code>70</code> 时，因为 <code>70 &gt; 64</code>，所以扩容 0.5 倍，新容量就是 <code>70 + (70 / 2) = 105</code>。</p>
<h3 id="2-3-堆操作"><a href="#2-3-堆操作" class="headerlink" title="2.3 堆操作"></a>2.3 堆操作</h3><p>从数组变成堆的实现，和数据结构里的方法差不多。</p>
<p>堆的构造，一般是从数组的最后一个非叶子节点开始，到根节点为止，一直执行下沉操作，就能够完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说一下下沉函数 <code>siftDown</code> 的实现吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下沉 <code>siftDown</code> 可以分为2种情况，一种是有自定义的比较器，一种是用默认的比较。</p>
<p>下沉 <code>siftDown</code> 就是一直往下替换当前节点，直到成为叶子节点，或子节点都比节点小（或大）时才结束。</p>
<p>比如，当前需要下沉的节点是 9：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    9     2</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 5   6</span><br><span class="line"> / \</span><br><span class="line">7   8</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    3     2</span><br><span class="line">   / \   / \</span><br><span class="line">  9   4 5   6       下沉，交换 9 &lt;==&gt; 3</span><br><span class="line"> / \</span><br><span class="line">7   8</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    3     2</span><br><span class="line">   / \   / \</span><br><span class="line">  7   4 5   6       下沉，交换 9 &lt;==&gt; 7</span><br><span class="line"> / \</span><br><span class="line">9   8</span><br></pre></td></tr></table></figure>

<p>至于上浮 <code>siftUp</code> 和下沉的 <code>siftDown</code> 代码差不多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是逻辑反过来而已，比如需要上浮的节点是 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    3     4</span><br><span class="line">   / \   / \</span><br><span class="line">  5   6 7   8</span><br><span class="line"> / \</span><br><span class="line">9   2</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    3     4</span><br><span class="line">   / \   / \</span><br><span class="line">  2   6 7   8       上浮，交换 2 &lt;==&gt; 5</span><br><span class="line"> / \</span><br><span class="line">9   5</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     4</span><br><span class="line">   / \   / \</span><br><span class="line">  3   6 7   8       上浮，交换 2 &lt;==&gt; 3</span><br><span class="line"> / \</span><br><span class="line">9   5</span><br></pre></td></tr></table></figure>

<h3 id="2-4-集合操作"><a href="#2-4-集合操作" class="headerlink" title="2.4 集合操作"></a>2.4 集合操作</h3><p>优先队列的增删查改稍微麻烦一些，因为它是一个有序的堆，因此在增删元素时，会引起堆结构发生变化。</p>
<p><strong>1）查询</strong></p>
<p>查找没什么好说的，因为底层结构是数组，所以直接遍历数组查询就行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(queue[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）添加</strong></p>
<p>不过，添加元素时，总是先添加到队列数组的末尾，再利用上浮 <code>siftUp</code> 来调整堆结构，算是有点小麻烦：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）删除</strong></p>
<p>而删除则是更麻烦一些，删除时，会把删除元素和数组末尾的元素交换，再执行下沉 <code>siftDown</code> 或上浮 <code>siftUp</code> 操作，也就是说，删除时是不确定是要下沉，还是上浮的。而添加是明确的只会上浮（因为添加总是在末尾）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E  `removeAt` (<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);</span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除元素的话，也可以分为几种情况：</p>
<ol>
<li>删除队列头，移除后，这个只要执行下沉操作；</li>
<li>删除末尾元素，直接移除，不需要额外的操作；</li>
<li>删除中间的元素，可能下沉，也可能上浮。</li>
</ol>
<p>删除比添加会稍微复杂一点，不过也还好，毕竟都是堆的基本操作。</p>
<p>这里举2个栗子，简单说明一下什么时候需要下沉？什么时候需要上浮？</p>
<p>栗1，删除节点 2，这种情况就会下沉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     4</span><br><span class="line">   / \   / \</span><br><span class="line">  3   6 7   8       需要删除2</span><br><span class="line"> / \</span><br><span class="line">9   5</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    5     4</span><br><span class="line">   / \   / \</span><br><span class="line">  3   6 7   8       和末尾元素交换，2 &lt;==&gt; 5</span><br><span class="line"> / \</span><br><span class="line">9   2</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    5     4</span><br><span class="line">   / \   / \</span><br><span class="line">  3   6 7   8       删除末尾元素</span><br><span class="line"> /</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    3     4</span><br><span class="line">   / \   / \</span><br><span class="line">  5   6 7   8       下沉，交换 5 &lt;==&gt; 3</span><br><span class="line"> /</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>栗2，删除节点 8，这种情况就会上浮：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     7</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 8   9       需要删除8</span><br><span class="line"> / \</span><br><span class="line">5   6</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     7</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 6   9       和末尾元素交换，8 &lt;==&gt; 6</span><br><span class="line"> / \</span><br><span class="line">5   8</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     7</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 6   9       删除末尾元素</span><br><span class="line"> /</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     6</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 7   9       上浮，交换 6 &lt;==&gt; 7</span><br><span class="line"> /</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>一般情况下，删除元素时，</p>
<ol>
<li>删除元素的是和末尾元素位于同一侧的子树，肯定会执行下沉操作；</li>
<li>删除元素的是和末尾元素位于不同侧的子树，有可能会执行上浮操作，也可能是执行下沉操作；</li>
</ol>
<p>因为同侧子树，祖先节点肯定比末尾节点要小，所以交换后肯定是执行下沉操作的。而不同侧的子树，交换后是有可能祖先节点比末尾节点大的，所以有可能执行上浮操作（注意是可能）。</p>
<p>另外，为什么这里的 <code>removeAt</code> 需要返回值？而且还是只返回执行了上浮 <code>siftUp</code> 的值？有什么特殊的意义嘛？这个原因到后面迭代器那里再说~~</p>
<h3 id="2-5-迭代器"><a href="#2-5-迭代器" class="headerlink" title="2.5 迭代器"></a>2.5 迭代器</h3><p>首先明确一点，优先队列的迭代是按照底层数组顺序遍历的，并不是按大小顺序。</p>
<p>也就是说，迭代遍历出来的顺序，并不是有序的，这点必须要搞清楚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (cursor &lt; size)</span><br><span class="line">            <span class="keyword">return</span> (E) queue[lastRet = cursor++]; <span class="comment">// 按照数组顺序遍历所有元素</span></span><br><span class="line">        <span class="keyword">if</span> (forgetMeNot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            lastRetElt = forgetMeNot.poll();</span><br><span class="line">            <span class="keyword">if</span> (lastRetElt != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> lastRetElt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实优先队列的迭代器，如果只是简单遍历访问的话，倒也没什么问题。</p>
<p>关键是迭代时，是可以删除元素的，而优先队列的元素是有序的，如果在迭代期间移除元素，就会引起堆的数据结构发生变化，那后面还能正常迭代下去嘛？或者说是怎么实现，数据结构变化后依旧可以正常遍历？</p>
<p>先确认一下，迭代删除时，是否会影响后续的遍历？</p>
<p>举个栗子吧，比如当前访问的元素是 8，下一个迭代元素是 9（<code>next()</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     7</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 8   9       要删除8</span><br><span class="line"> / \</span><br><span class="line">5   6</span><br></pre></td></tr></table></figure>

<p>假如此时删除当前元素 8，那么堆结构就会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     6</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 7   9       6还没遍历到，但是已经被移到前面遍历过的位置了</span><br><span class="line"> /</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>那么问题就来了，6 还能不能遍历到呢？毕竟下一个待遍历的元素是 7，迭代器是不可能回到前面再遍历 6 的，所以 6 已经无法被遍历到了，那要怎么处理这种情况呢？</p>
<p>为了解决这个问题，优先队列 <code>PriorityQueue</code> 的迭代器里就加上一个成员变量 <code>forgetMeNot</code>，用于保存这种发生移动后，正常迭代遍历无法访问到的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A queue of elements that were moved from the unvisited portion of</span></span><br><span class="line"><span class="comment">     * the heap into the visited portion as a result of &quot;unlucky&quot; element</span></span><br><span class="line"><span class="comment">     * removals during the iteration.  (Unlucky element removals are those</span></span><br><span class="line"><span class="comment">     * that require a siftup instead of a siftdown.)  We must visit all of</span></span><br><span class="line"><span class="comment">     * the elements in this list to complete the iteration.  We do this</span></span><br><span class="line"><span class="comment">     * after we&#x27;ve completed the &quot;normal&quot; iteration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We expect that most iterations, even those involving removals,</span></span><br><span class="line"><span class="comment">     * will not need to store elements in this field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;E&gt; forgetMeNot = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (lastRet != -<span class="number">1</span>) &#123;</span><br><span class="line">            E moved = PriorityQueue.<span class="keyword">this</span>.removeAt(lastRet);</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (moved == <span class="keyword">null</span>)</span><br><span class="line">                cursor--;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (forgetMeNot == <span class="keyword">null</span>)</span><br><span class="line">                    forgetMeNot = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">                forgetMeNot.add(moved);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastRetElt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            PriorityQueue.<span class="keyword">this</span>.removeEq(lastRetElt);</span><br><span class="line">            lastRetElt = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，只有发生上浮 <code>siftUp</code> 时，才会导致元素无法被遍历到，因此前面的 <code>removeAt</code> 方法只返回了上浮 <code>siftUp</code> 情况下的移动节点，其实就是专门为这个迭代器准备的。</p>
<p>如果 <code>removeAt</code> 的返回值不为 <code>null</code>，就说明发生了上浮 <code>siftUp</code>，那么就需要添加到 <code>forgetMeNot</code>。</p>
<p>另外，<code>forgetMeNot</code> 中的元素，需要等到正常的迭代遍历走完以后，才会遍历到素（看上面<code>next()</code>的代码）。</p>
<p>也就是说，删除元素后，实际上会影响到遍历的顺序。用个栗子说明一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     7</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 8   9       删除8</span><br><span class="line"> / \</span><br><span class="line">5   6</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     6</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 7   9       删除8之后，此时再删除9</span><br><span class="line"> /</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     5</span><br><span class="line">   / \   / \</span><br><span class="line">  3   4 7   6       删除9之后的结构</span><br></pre></td></tr></table></figure>

<p>删除2次之后，<code>forgetMeNot</code> 里面应该包含2个元素 <code>[6, 5]</code>，这个时候迭代顺序就发生变化了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 正常的遍历顺序</span><br><span class="line">1 2 7 3 4 8 9 5 6</span><br><span class="line"></span><br><span class="line">// 删除后的遍历顺序</span><br><span class="line">1 2 7 3 4 8 9 6 5</span><br></pre></td></tr></table></figure>

<p>可以看到，删除后可能会影响实际遍历的顺序。</p>
<p>其实我有一点不明白的是，删除时删除元素交换的始终都是末尾元素，它本来就是最后遍历的，而 <code>forgetMeNot</code> 保存的就是移动的元素，实际上也就是末尾元素，所以 <code>forgetMeNot</code> 是倒着放入末尾元素的，为什么不是用 <code>Stack</code> ，而是用队列 <code>ArrayDeque</code> 呢？</p>
<p>这点还没有搞明白，还是说反正都是遍历，顺序什么的都不是啥大问题？？</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Hashtable</title>
    <url>/lang/java/source/jdk8/collection/Hashtable/</url>
    <content><![CDATA[<h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Hashtable</code> 继承了旧的父类 <code>Dictionary</code>，和新的接口 <code>Map</code>。</p>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><span id="more"></span>

<h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p><code>HashTable</code> 底层是采用“数组 + 链表”的结构实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>key</code> 的 <code>hash</code> 映射到数组table上，找到位置后，再将不同的 <code>key</code> 链接到链表上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___      ___      ___ </span><br><span class="line">| 0 | -&gt; | 4 | -&gt; | 8 |      --链表</span><br><span class="line"> ___      ___ </span><br><span class="line">| 1 | -&gt; | 5 |               --链表</span><br><span class="line"> ___ </span><br><span class="line">| 2 |                        --链表</span><br><span class="line"> ___      ___      ____ </span><br><span class="line">| 3 | -&gt; | 7 | -&gt; | 11 |     --链表</span><br></pre></td></tr></table></figure>

<h3 id="2-2-集合操作"><a href="#2-2-集合操作" class="headerlink" title="2.2 集合操作"></a>2.2 集合操作</h3><p><strong>1）添加元素</strong></p>
<p>知道了数据结构，实际上就很容易理解怎么添加一个元素了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容代码那里暂时忽略，后面再解释，直接看后面几行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br></pre></td></tr></table></figure>

<p>举个例子说明这2行代码的意义，假设当前数据结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___ </span><br><span class="line">| 4 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___</span><br><span class="line">| 3 |</span><br></pre></td></tr></table></figure>

<p>这个时候添加 0，此时 0 还不在集合里，<code>0 % 4 = 0</code>，所以应该要放入 <code>table[0]</code> 中，但是此时 <code>table[0]</code> 已经有 4 了，所以就需要追加到链表上。</p>
<p>那么按照上面的2行代码，最终结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___      ___ </span><br><span class="line">| 0 | -&gt; | 4 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___</span><br><span class="line">| 3 |</span><br></pre></td></tr></table></figure>

<p>注意，添加元素时，是插入到链表头部的，而不是链表尾部。</p>
<p>至于为什么倒着插入，我想应该是如果每次都插到尾部的话，就得遍历一次链表，代价有点高~~</p>
<p><strong>2）删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除数组元素</span></span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除没什么好说的，直接删就是了，唯一需要注意的就是，如果删除的是数组上的节点，就需要更新它的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___      ___ </span><br><span class="line">| 0 | -&gt; | 4 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___</span><br><span class="line">| 3 |</span><br></pre></td></tr></table></figure>

<p>比如删除 0，就需要把 4 设置到数组里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___ </span><br><span class="line">| 4 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___</span><br><span class="line">| 3 |</span><br></pre></td></tr></table></figure>

<h3 id="2-2-扩容机制"><a href="#2-2-扩容机制" class="headerlink" title="2.2 扩容机制"></a>2.2 扩容机制</h3><p><code>HashTable</code> 是采用“数组 + 链表”的结构实现的，理论上链表可以无限长。</p>
<p>但是如果链表太长了，就会导致查询变得很慢，这个要怎么解决呢？</p>
<p>这个时候就需要扩容了，把过长的链表拆分，变成短链表。那要怎么拆分？</p>
<p>数据是通过“数组 + 链表”保存的，在维持元素数量不变的情况下，想要链表变短，那就只能增长数组长度。</p>
<p>其实，<code>HashTable</code> 的扩容规则就是这样的，通过增长数组容量，以重新调整链表的结构，缩短链表的长度。</p>
<p><strong>1）负载因子</strong></p>
<p>那还有一个问题，就是，多长的链表才算是太长？或者说，什么时候才需要重新调整数组容量？</p>
<p>在 <code>HashTable</code> 中，使用了负载因子来表示需要重构数组的时机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>为了了解负载因子的作用，先解释一下负载的意义。</p>
<p>举个例子说明，比如当前结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___      ___ </span><br><span class="line">| 0 | -&gt; | 4 |</span><br><span class="line"> ___ </span><br><span class="line">| 1 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___      ___      ____ </span><br><span class="line">| 3 | -&gt; | 7 | -&gt; | 11 |</span><br></pre></td></tr></table></figure>

<p>那么，此时的数组容量是 4，元素数量是 6，因此实际负载就是 <code>6 / 4 = 1.5</code>。</p>
<p>也就是说，负载其实表示的是当前数据结构的负载情况，数值越高，表示保存的数据越多。</p>
<p>因此，负载因子相当于一个阈值，当负载超过这个阈值时，就表示当前数据已经很满了，需要对数组进行扩容了。</p>
<p>再举个例子，假设当前 <code>HashTable</code> 的负载因子是 0.8，此时的数据结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___      ___ </span><br><span class="line">| 0 | -&gt; | 4 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___</span><br><span class="line">| 3 |</span><br></pre></td></tr></table></figure>

<p>此时的负载是 <code>4 / 3 = 0.75 &lt; 0.8</code>，暂时不需要扩容。</p>
<p>如果我再添加一个元素 1 之后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___      ___ </span><br><span class="line">| 0 | -&gt; | 4 |</span><br><span class="line"> ___ </span><br><span class="line">| 1 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___</span><br><span class="line">| 3 |</span><br></pre></td></tr></table></figure>

<p>此时的负载是 <code>4 / 4 = 1 &gt; 0.8</code>，这个时候就需要扩容了。</p>
<p>还有，<code>HashTable</code> 中为了避免经常计算负载，就添加了另一个变量阈值，来维护需要扩容的数量阈值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 阈值</span><br><span class="line">private int threshold;</span><br></pre></td></tr></table></figure>

<p>它实际就是由数组容量和负载因子算出来的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threshold = table.length * loadFactor</span><br></pre></td></tr></table></figure>

<p>当元素数量大于这个阈值时，就需要扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但实际上，阈值 <code>threshold</code> 并不是一个必要的变量，只是为了减少负载的计算（除法计算），而添加的。</p>
<p><strong>2）扩容规则</strong></p>
<p>好了，既然知道了扩容的时机，那就说一下扩容的规则吧，究竟要扩容多少才好呢？</p>
<p><code>HashTable</code> 和其他集合类差不多，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">        <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除去溢出判断，一般情况下其实就是 <code>2倍 + 1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新数组容量 = 旧数组容量 * 2 + 1</span><br></pre></td></tr></table></figure>

<p><strong>3）扩容实现</strong></p>
<p>先上代码，后面再解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算扩容后新的数组容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 计算新的阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重新分配数组的链表</span></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例子说明，假设 <code>HashTable</code> 的负载因子是 0.75，阈值 <code>threshold = 4 * 0.75 = 3</code>，此时的数据结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___      ___ </span><br><span class="line">| 0 | -&gt; | 4 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___</span><br><span class="line">| 3 |</span><br></pre></td></tr></table></figure>

<p>此时元素数量是 <code>3 &gt;= threshold</code>，表示要扩容了，但是暂时还不需要扩容，因为实际上的扩容，是在下一次添加元素的时候。比如当下次再添加一个元素 1 时，添加前会先扩容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新数组容量 = 4 * 2 + 1 = 9</span><br></pre></td></tr></table></figure>

<p>好了，现在就开始重新分配数据了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">旧数组（4）              新数组（9）</span><br><span class="line"> ___      ___             ___ </span><br><span class="line">| 0 | -&gt; | 4 |           |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">|   |                    |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">|   |                    |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">| 3 |                    |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br></pre></td></tr></table></figure>

<p>首先是 3（为什么是3？仔细看看上面的代码，遍历是从 <code>table.length - 1</code> 倒着开始的），<code>3 % 9 = 3</code>，所以它的新位置就在新数组索引 3 那里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">旧数组（4）              新数组（9）</span><br><span class="line"> ___      ___             ___ </span><br><span class="line">| 0 | -&gt; | 4 |           |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">|   |                    |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">|   |                    |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">| 3 |                    | 3 |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br></pre></td></tr></table></figure>

<p>接着是 0，<code>0 % 9 = 0</code>，所以它的新位置就在新数组索引 0 那里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">旧数组（4）              新数组（9）</span><br><span class="line"> ___      ___             ___ </span><br><span class="line">| 0 | -&gt; | 4 |           | 0 |</span><br><span class="line"> ___                      ___ </span><br><span class="line">|   |                    |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">|   |                    |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">| 3 |                    | 3 |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br></pre></td></tr></table></figure>

<p>最后是 4，<code>4 % 9 = 4</code>，所以它的新位置就在新数组索引 4 那里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">旧数组（4）              新数组（9）</span><br><span class="line"> ___      ___             ___ </span><br><span class="line">| 0 | -&gt; | 4 |           | 0 |</span><br><span class="line"> ___                      ___ </span><br><span class="line">|   |                    |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">|   |                    |   |</span><br><span class="line"> ___                      ___ </span><br><span class="line">| 3 |                    | 3 |</span><br><span class="line">                          ___ </span><br><span class="line">                         | 4 |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br><span class="line">                          ___ </span><br><span class="line">                         |   |</span><br></pre></td></tr></table></figure>

<p>至此，扩容重新分配就完成了。</p>
<p>其实可以看到，链表 0 被拆分了，就是通过这种扩容方式，来减短链表的长度，提高查询效率。</p>
<p>差点忘了，还要把新增元素1加进去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（9）</span><br><span class="line"> ___ </span><br><span class="line">| 0 |</span><br><span class="line"> ___ </span><br><span class="line">| 1 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">| 3 |</span><br><span class="line"> ___ </span><br><span class="line">| 4 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br></pre></td></tr></table></figure>

<p>这样才算是圆满结束了~~</p>
<p>等等！！其实还有个比较有趣的地方，那就是分配后的链表元素顺序，怎么说？</p>
<p>还是直接举例子吧，下面这种结构，重新分配后是怎么样的呢：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（4）</span><br><span class="line"> ___      ___      ____ </span><br><span class="line">| 0 | -&gt; | 4 | -&gt; | 12 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___</span><br><span class="line">|   |</span><br></pre></td></tr></table></figure>

<p>过程就不说了，直接给结果吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组（9）</span><br><span class="line"> ____      ___ </span><br><span class="line">| 12 | -&gt; | 0 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">| 4 |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br><span class="line"> ___ </span><br><span class="line">|   |</span><br></pre></td></tr></table></figure>

<p>咦？0 和 12 的顺序变了！是的，没错，实际上确实是这样，仔细看看重新分配的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">newMap[index] = e;</span><br></pre></td></tr></table></figure>

<p>实际上重新分配时，和添加元素时一样，元素是倒着插入的，都是为了提高效率。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList</title>
    <url>/lang/java/source/jdk8/collection/LinkedList/</url>
    <content><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LinkedList</code> 和 <code>ArrayList</code> 的定义有一些区别，<code>LinkedList</code> 是继承于 <code>AbstractSequentialList</code> 的，而 <code>ArrayList</code> 是直接继承于 <code>AbstractList</code>。</p>
<p><code>LinkedList</code> 的继承链多了一层 <code>AbstractSequentialList</code>。</p>
<span id="more"></span>

<p>另外，<code>LinkedList</code> 还实现了另外一个双向队列的接口 <code>Deque</code>，表示 <code>LinkedList</code> 能够双向访问元素。</p>
<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>底层的数据存储是采用双向链表来实现的，至于链表节点类型，是一个静态内部类 <code>Node</code>，有2个引用分别指向前一个和后一个节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-集合操作"><a href="#2-2-集合操作" class="headerlink" title="2.2 集合操作"></a>2.2 集合操作</h3><p><code>LinkedList</code> 的集合操作不外乎增删查改，底层数据结构是链表，实际上这些操作就是链表的操作。</p>
<p>首先看一下查询，既然是链表，那么就有链头和链尾，在 <code>LinkedList</code> 内分别用2个成员变量表示，获取表头和表尾还是比较简单的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于查找链表中间的节点，没有别的办法，必须需要遍历链表才行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 链表前半段</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 链表后半段</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过在查找时进行了一些优化，因为 <code>LinkedList</code> 是一个双向链表，所以可以从两边任意一边开始搜索。</p>
<p>搜索指定索引的元素时，如果小于长度的一半，就从表头正向查找；如果大于长度的一半，就从表尾逆向查找。</p>
<p>接下来是添加和删除，其实都是链表的基本操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立后链</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 建立前链</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line"></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加元素也没什么特别的，一般就是追加和插入指定位置。追加的话，直接链接到表尾就行；至于插入，则先需要需要前面的搜索，找到插入的位置，再执行插入，会多耗费一些。所以专门针对这2种情况分别进行了处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解开前链</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解开后链</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除元素也一样，添加元素是插入时建立节点链接，删除实际就是解除某个节点的链接。所以操作上都差不多。</p>
<p>最后是更新，这个更简单了,先查找到需要更新的元素，然后直接就可以更新：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，增删查改这几个操作，也就查找有点看头，其他的都是链表的基本操作。</p>
<h3 id="2-3-迭代器"><a href="#2-3-迭代器" class="headerlink" title="2.3 迭代器"></a>2.3 迭代器</h3><p><code>LinkedList</code> 是一个双向链表，所以它的迭代器也一样，可以双向遍历，然后我就发现了一个有意思的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">        unlink(lastReturned);</span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextIndex--;</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的是迭代器中的2个成员变量 <code>next</code> 和 <code>lastReturned</code>。</p>
<p>在 <code>next()</code> 方法中可以看到，一般情况下， <code>next</code> 和 <code>lastReturned</code> 是指向不同的元素的，<code>next</code> 正常是 <code>lastReturned</code> 的下一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lastReturned = next;</span><br><span class="line">next = next.next;</span><br></pre></td></tr></table></figure>

<p>但是如果执行过 <code>previous()</code> 方法，它们的指向就发生变化了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br></pre></td></tr></table></figure>

<p>这个时候，<code>next</code> 和 <code>lastReturned</code> 都指向同一个元素，也就是当前 <code>next</code> 的前一个元素。</p>
<p>由于 <code>next()</code> 和 <code>previous()</code> 的不同情况，其他方法在处理时，也需要考虑这两种情况，就比如上面的 <code>remove()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">    <span class="comment">// previous()的情况</span></span><br><span class="line">    next = lastNext;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// next()的情况</span></span><br><span class="line">    nextIndex--;</span><br></pre></td></tr></table></figure>

<p>一开始看到这里，貌似是有点别扭的，因为感觉代码写起来有点不太统一。</p>
<p>后来仔细相想想，可能是因为只用了 <code>next</code> 变量来遍历，如果再加上一个 <code>previous</code> 变量可能会更好理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 添加previous指向前一个元素</span></span><br><span class="line">        lastReturned = previous = next;</span><br><span class="line">        next = next.next;</span><br><span class="line"></span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 添加previous指向前一个元素</span></span><br><span class="line">        lastReturned = next = previous;</span><br><span class="line">        previous = previous.prev;</span><br><span class="line">        </span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样貌似好理解一些，不过多了一个变量 <code>previous</code>，维护起来可能麻烦一些吧？所以源码实现并没有添加？</p>
<p>由于 <code>LinkedList</code> 是双向的，所以也还有另一个迭代器，逆向迭代器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过在实现上，实际是直接用的正向迭代器，在它外面包装了一层，真正遍历时就调用正向迭代器中相反的接口。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList</title>
    <url>/lang/java/source/jdk8/collection/ArrayList/</url>
    <content><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个地方没搞明白，按理说抽象类 <code>AbstractList</code> 已经包含了接口 <code>List</code>，为何还需要再次实现这个接口呢？</p>
<p>难道是担心抽象类 <code>AbstractList</code> 有可能会修改，不再实现接口 <code>List</code>？</p>
<span id="more"></span>

<h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p><code>ArrayList</code> 底层实现是用数组 <code>elementData</code> 来保存集合元素的，并且数组的类型是 <code>Object</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有设为private的原因是为了让内部类可以访问该属性</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-最大容量"><a href="#2-1-最大容量" class="headerlink" title="2.1 最大容量"></a>2.1 最大容量</h3><p><code>ArrayList</code> 内置数组的最大容量是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum size of array to allocate. Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>为什么需要 <code>-8</code> 呢？按照源码的备注来看，是因为有些 JVM 在数组的实现上，会保留一些字节作为数组头，用于标记数组的相关信息。可能是“长度”“类型”之类的信息（具体我也没了解）。</p>
<h3 id="2-2-扩容机制"><a href="#2-2-扩容机制" class="headerlink" title="2.2 扩容机制"></a>2.2 扩容机制</h3><p>虽然底层实现是数组，但是集合列表 <code>ArrayList</code> 是可扩容的，它的扩容方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先在当前基础上是增长1/2容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断增长1/2后是否满足容量要求</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新容量-数组最大值 &gt; 0，则扩充为大容量数组</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制数组到更大的内存</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容可以分为3步：</p>
<ol>
<li>正常情况下，每次扩容增长当前数组容量的 1/2。</li>
<li>扩容1/2后仍小于最小容量，则使用最小容量；</li>
<li>若最小容量值大于数组最大值，则使用大数组容量。</li>
</ol>
<p>举几个例子说明：</p>
<p>例1：假如当前的数组容量是 <code>oldCapacity = 16</code>，<code>minCapacity = 23</code>，那么按照扩容机制的第1条规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newCapacity = <span class="number">16</span> + <span class="number">16</span> / <span class="number">2</span> = <span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>满足要求，因此最终扩容后的数组容量是 <code>24</code>。</p>
<p>例2：假如当前的数组容量是 <code>oldCapacity = 16</code>，<code>minCapacity = 30</code>，那么按照扩容机制的第2条规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第1条规则</span></span><br><span class="line">newCapacity = <span class="number">16</span> + <span class="number">16</span> / <span class="number">2</span> = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2条规则</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - <span class="number">30</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    newCapacity = <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么此时按照第2条规则，最终扩容后的数组容量是 <code>30</code>。</p>
<p>例3：假如当前的数组容量是 <code>oldCapacity = 16</code>，<code>minCapacity = Integer.MAX_VALUE - 4</code>，那么按照扩容机制的第3条规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">minCapacity = Integer.MAX_VALUE - <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第1条规则</span></span><br><span class="line">newCapacity = <span class="number">16</span> + <span class="number">16</span> / <span class="number">2</span> = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2条规则</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    newCapacity = minCapacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第3条规则</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时扩充后的数组容量由方法 <code>hugeCapacity(minCapacity)</code> 计算，而这个方法的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，当 <code>minCapacity</code> 值介于 <code>MAX_ARRAY_SIZE</code> 和 <code>Integer.MAX_VALUE</code> 之间时，返回 <code>Integer.MAX_VALUE</code>；否则返回默认的数组最大值 <code>MAX_ARRAY_SIZE</code>。</p>
<p>虽然这3条规则的代码看起来比较简单，但是实际上它还考虑到了溢出的问题。</p>
<h3 id="2-3-集合操作"><a href="#2-3-集合操作" class="headerlink" title="2.3 集合操作"></a>2.3 集合操作</h3><p>集合的操作，不外乎增删查改，由于底层是数组实现，因此对于查询和更新，可以直接根据数组的索引来访问即可，很简单（当然，这中间还会进行索引范围的检查，但也不是难事）。</p>
<p>至于添加和删除，这就涉及到了数组的移动。如果插入到数组中间，就需要把插入位置后面的数组元素都往后移动，才能插入；而删除中间的某个元素，也需要把该元素之后的数组元素往前移动。</p>
<p>实际上操作也不复杂，举个插入的例子。首先是插入函数的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引的范围</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保证数组空间足够，不够就扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把插入位置后的元素往后移动</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">                     </span><br><span class="line">    <span class="comment">// 插入新元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理比较简单，和平时自己用把数据插入到数组时的操作差不多，只是多了一些索引范围和扩容的校验。</p>
<p>删除的原理也差不多，不过有一个比较有意思的就是，如果同一个对象保存在集合中不止一个位置，那么在删除的时候，只会删除第一个出现的位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，删除元素时，只要找到第一个就把它删除，至于后面是否还有这个元素，就不再管了。</p>
<h3 id="2-4-子列表"><a href="#2-4-子列表" class="headerlink" title="2.4 子列表"></a>2.4 子列表</h3><p>子列表本来觉得没什么特别的东西，后来仔细一看，还真发现了一些华点。</p>
<p><strong>1）子列表构造函数的参数</strong></p>
<p>子列表构造函数的参数有啥特别的？先上源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">        <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">    <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">    <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fromIndex</code> 和 <code>toIndex</code> 很容易理解，就是子集合的索引范围；<code>parent</code> 也很清楚，就是子集合的父集合；</p>
<p>但是 <code>offset</code> 是干啥用的，不是已经有 <code>fromIndex</code> 和 <code>toIndex</code> 了吗？需要这个参数吗？</p>
<p>看到后面才发现，原来是为了嵌套子列表，也就是子列表再获取子列表的情况：</p>
<p><code>ArrayList -&gt; SubList -&gt; SubList -&gt; ...</code></p>
<p>就类似这种层层嵌套的结构。</p>
<p>子列表的子列表函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, offset, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 <code>offset</code> 的作用就体现出来了。</p>
<p><strong>2）内部类 <code>SubList</code> 与 <code>ArrayList</code> 的关系</strong></p>
<p>在源码里可以看到，<code>SubList</code> 里经常会访问 <code>ArrayList</code> 的变量，主要包括 <code>modCount</code> 和 <code>elementData</code>。</p>
<p>但是考虑到嵌套子列表的情况，它里面是怎么访问到相当于祖先级别的 <code>ArrayList</code> 呢？</p>
<p>貌似还挺简单的，直接使用 <code>ArrayList.this</code> 就可以访问到外部类的成员（但是我以前还真不知道这种操作，所以特地记下来，哈哈哈~~）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList.<span class="keyword">this</span>.modCount</span><br><span class="line"></span><br><span class="line">ArrayList.<span class="keyword">this</span>.elementData</span><br><span class="line"></span><br><span class="line">ArrayList.<span class="keyword">this</span>.set(offset + lastRet, e)</span><br></pre></td></tr></table></figure>

<p>由于内部类占用了 <code>this</code>，为了和外部类区分开来，就加上了外部类的类名前缀 <code>ArrayList.this</code>。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayDeque</title>
    <url>/lang/java/source/jdk8/collection/ArrayDeque/</url>
    <content><![CDATA[<h1 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>ArrayDeque</code> 实现了 <code>Deque</code> 接口，是一个数组实现的双向队列。</p>
<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p><code>ArrayDeque</code> 底层数据存储结构是数组：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列存储数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列头</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列尾</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br></pre></td></tr></table></figure>

<p>在用数组实现队列时，为充分利用起数组的空间，是采用的环形存放来实现的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___ ___ ___ ___ ___ ___ ___ ___</span><br><span class="line">| 5 | 6 |   |   | 1 | 2 | 3 | 4 |</span><br></pre></td></tr></table></figure>

<p>就类似这样，数组是循环存放队列数据的，队头 <code>head</code> 指向 <code>1</code> 的位置，而队尾则指向 <code>6</code> 之后的位置（注意不是指向 <code>6</code>，而是下一个）。</p>
<h3 id="2-2-扩容机制"><a href="#2-2-扩容机制" class="headerlink" title="2.2 扩容机制"></a>2.2 扩容机制</h3><p>虽然是数组实现，但是实际上和 <code>ArrayList</code> 这种一样，会随着队列元素的增多而自动扩容。</p>
<p><code>ArrayDeque</code> 的底层数组 <code>elements</code> 的长度始终是 <code>2的倍数</code>，就是说，<code>elements</code> 的扩容增长也必须遵守这个规则。</p>
<p>首先，在初始化队列时，如果提供了初始容量，但是这个初试容量不满足 <code>2的倍数</code>，那就会对它进行修正：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        initialCapacity++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说，在实例化队列时，传入参数 <code>numElements = 9</code>，但是因为9不是 <code>2的倍数</code>，所以会对它进行修正，这个时候满足条件的最小值是16，因此初始容量实际上是16。</p>
<p>注意一点，如果 <code>numElements &lt; MIN_INITIAL_CAPACITY</code>，也就是小于最小容量（实际上就是8）时，就直接取最小容量。</p>
<p>实际扩容时，也要保持数组容量是 <code>2的倍数</code>，所以扩容时是直接是 <code>以2倍增长</code> 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">int</span> n = elements.length;</span><br><span class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">    elements = a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，如果当前容量是16，那么下一次扩容后，容量就应该是32了。</p>
<p>至于为什么数组容量一定要是 <code>2的倍数</code>，我估计可能和性能有关：</p>
<p>1） 计算机对于2倍数计算是很快的，直接通过移位操作（<code>n &lt;&lt; 1</code>）就可以实现；</p>
<p>2）采用数组循环时，经常需要执行取模，如果容量是2的倍数，那么取模就可以用掩码（<code>head = (head - 1) &amp; (elements.length - 1)</code>）来实现，相对而言会更高效一些。</p>
<h3 id="2-3-集合操作"><a href="#2-3-集合操作" class="headerlink" title="2.3 集合操作"></a>2.3 集合操作</h3><p>由于底层是数组，实际上增删查改都很简单。</p>
<p><strong>1）添加元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是双向队列，添加元素可以分为追加队头，或者追加队尾。两种实现代码都差不多，添加元素之后还需要验证是否数组已满，满了的话，就要进行扩容。</p>
<p><strong>2）删除元素</strong></p>
<p>删除元素会稍微麻烦一些，毕竟是数组，当删除中间的元素时，需要移动一部分数组元素。</p>
<p>由于数组是循环存放的，所以实际上会分为2种情况：</p>
<p>1、<code>head &lt; tail</code> 正常型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___ ___ ___ ___ ___ ___ ___ ___</span><br><span class="line">|   | 1 | 2 | 3 | 4 | 5 | 6 |   |</span><br></pre></td></tr></table></figure>

<p>2、<code>tail &lt; head</code> 环绕型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___ ___ ___ ___ ___ ___ ___ ___</span><br><span class="line">| 5 | 6 |   |   | 1 | 2 | 3 | 4 |</span><br></pre></td></tr></table></figure>

<p>根据删除的位置，处理不同的情况就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    checkInvariants();</span><br><span class="line">    <span class="keyword">final</span> Object[] elements = <span class="keyword">this</span>.elements;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mask = elements.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> h = head;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> t = tail;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> front = (i - h) &amp; mask;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> back  = (t - i) &amp; mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: head &lt;= i &lt; tail mod circularity</span></span><br><span class="line">    <span class="keyword">if</span> (front &gt;= ((t - h) &amp; mask))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最少元素移动优化</span></span><br><span class="line">    <span class="keyword">if</span> (front &lt; back) &#123;</span><br><span class="line">        <span class="comment">// 左边元素少</span></span><br><span class="line">        <span class="keyword">if</span> (h &lt;= i) &#123;</span><br><span class="line">            <span class="comment">// 正常型</span></span><br><span class="line">            System.arraycopy(elements, h, elements, h + <span class="number">1</span>, front);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 环绕型</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, elements, <span class="number">1</span>, i);</span><br><span class="line">            elements[<span class="number">0</span>] = elements[mask];</span><br><span class="line">            System.arraycopy(elements, h, elements, h + <span class="number">1</span>, mask - h);</span><br><span class="line">        &#125;</span><br><span class="line">        elements[h] = <span class="keyword">null</span>;</span><br><span class="line">        head = (h + <span class="number">1</span>) &amp; mask;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 右边元素少</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; t) &#123;</span><br><span class="line">            <span class="comment">// 正常型</span></span><br><span class="line">            System.arraycopy(elements, i + <span class="number">1</span>, elements, i, back);</span><br><span class="line">            tail = t - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 环绕型</span></span><br><span class="line">            System.arraycopy(elements, i + <span class="number">1</span>, elements, i, mask - i);</span><br><span class="line">            elements[mask] = elements[<span class="number">0</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">1</span>, elements, <span class="number">0</span>, t);</span><br><span class="line">            tail = (t - <span class="number">1</span>) &amp; mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现虽然有点长，不过原理其实也很简单。</p>
<p>代码实现中，为了减少数组元素的移动，对移动进行了优化，移动时采用最少元素移动原则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final int h = head;</span><br><span class="line">final int t = tail;</span><br><span class="line">final int front = (i - h) &amp; mask;</span><br><span class="line">final int back  = (t - i) &amp; mask;</span><br><span class="line">if (front &lt; back) &#123;</span><br><span class="line">    // 左边元素少</span><br><span class="line">    // 移动左边的元素</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 右边元素少</span><br><span class="line">    // 移动右边的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，要删除元素 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___ ___ ___ ___ ___ ___ ___ ___</span><br><span class="line">|   | 1 | 2 | 3 | 4 | 5 | 6 |   |</span><br></pre></td></tr></table></figure>

<p>这个时候，3 左边的元素数量是 2，右边元素数量是 3，那么在删除 3 之后，就会移动左边的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___ ___ ___ ___ ___ ___ ___ ___</span><br><span class="line">|   |   | 1 | 2 | 4 | 5 | 6 |   |</span><br></pre></td></tr></table></figure>

<p>当然，对于环绕型数组的删除，原理是一样的，只是代码处理上会稍微麻烦一些。</p>
<p>比如，要删除元素 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___ ___ ___ ___ ___ ___ ___ ___</span><br><span class="line">| 5 | 6 |   |   | 1 | 2 | 3 | 4 |</span><br></pre></td></tr></table></figure>

<p>这个时候右边元素比较少，所以移动右边的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ___ ___ ___ ___ ___ ___ ___ ___</span><br><span class="line">| 6 |   |   |   | 1 | 2 | 3 | 5 |</span><br></pre></td></tr></table></figure>

<p>反正不管怎么样，删除时总是移动元素少的一边。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>AbstractQueue</title>
    <url>/lang/java/source/jdk8/collection/AbstractQueue/</url>
    <content><![CDATA[<h1 id="AbstractQueue"><a href="#AbstractQueue" class="headerlink" title="AbstractQueue"></a>AbstractQueue</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractQueue</code> 只是一个抽取类，其目的主要是为接口 <code>Queue</code> 的一些方法提供了基础的实现模板。</p>
<span id="more"></span>

<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><p><code>AbstractQueue</code> 只是一个模板类，可以为子类在实现接口 <code>Queue</code> 时提供一些通用代码，减少子类实现时的代码量。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似这种常用方法，<code>AbstractQueue</code> 直接就实现了，避免子类每次都要自己实现的麻烦。</p>
<p>从代码上来说，<code>AbstractQueue</code> 没有什么特殊的代码，都是一些通用的基础代码。</p>
<p>总之，<code>AbstractQueue</code> 就是提供了一个简易实现模板，减少子类在实现接口 <code>Queue</code> 时的代码，提高效率。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>AbstractSet</title>
    <url>/lang/java/source/jdk8/collection/AbstractSet/</url>
    <content><![CDATA[<h1 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet"></a>AbstractSet</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractSet</code> 提供了接口 <code>Set</code> 的模板实现，也就是提供了 <code>Set</code> 中某些方法的实现，减少实现 <code>Set</code> 接口时的代码。</p>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><span id="more"></span>

<p>主要实现了几个方法：</p>
<p><strong>1）<code>equals</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span><br><span class="line">    <span class="keyword">if</span> (c.size() != size())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> containsAll(c);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较两个集合是是否相等：</p>
<ol>
<li>是否是自己</li>
<li>是否是Set集合</li>
<li>大小size是否相等</li>
<li>2个集合内的元素是否全等</li>
</ol>
<p>根据第4条规则，只要集合内的元素全等，就表明两个集合是相等的。</p>
<p>但是有些集合是有序的，也就是说，如果一个有序集合和一个无序集合比较，是有可能相等的，因为第4条规则并不会判断集合内元素的顺序。</p>
<p>当然，如果子类重写了 <code>equals</code> 方法，那就另外说了。</p>
<p><strong>2）<code>hashCode</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    Iterator&lt;E&gt; i = iterator();</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        E obj = i.next();</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>)</span><br><span class="line">            h += obj.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集合 <code>Set</code> 的 <code>hashCode</code> 就等于集合内所有元素的 <code>hashCode</code> 的总和。</p>
<p><strong>3）<code>removeAll</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; c.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); )</span><br><span class="line">            modified |= remove(i.next());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除时，遍历集合数量较少的那个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (size() &gt; c.size()) &#123;</span><br><span class="line">    <span class="comment">// 另一个集合元素数量少</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当前集合元素数量少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>AbstractMap</title>
    <url>/lang/java/source/jdk8/collection/AbstractMap/</url>
    <content><![CDATA[<h1 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractMap</code> 就是接口 <code>Map</code> 的模板实现类，提供一些已经实现好的方法，后续子类继承时就不用重复写了。</p>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><h3 id="2-1-entrySet"><a href="#2-1-entrySet" class="headerlink" title="2.1 entrySet"></a>2.1 entrySet</h3><p>实际上，<code>AbstractMap</code> 里面的方法实现都是依赖 <code>entrySet()</code> 方法来实现的，具体看看代码吧：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entrySet().size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    Entry&lt;K,V&gt; correctEntry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (correctEntry==<span class="keyword">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (correctEntry==<span class="keyword">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (correctEntry !=<span class="keyword">null</span>) &#123;</span><br><span class="line">        oldValue = correctEntry.getValue();</span><br><span class="line">        i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    entrySet().clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余实现方法也差不多是这样的，都是通过 <code>entrySet()</code> 来实现，这里就不多贴代码了。</p>
<p>所以，子类只要再实现 <code>entrySet()</code>，基本上就可以正常使用了。</p>
<p>当然，如果需要其他代码优化之类的，再重写就好。</p>
<h3 id="2-2-Entry"><a href="#2-2-Entry" class="headerlink" title="2.2 Entry"></a>2.2 Entry</h3><p>在 <code>AbstractMap</code> 中，还提供了2个接口 <code>Entry</code> 的实现类 <code>SimpleEntry</code> 和 <code>SimpleImmutableEntry</code>。</p>
<p>一个是可修改的 <code>SimpleEntry</code>；</p>
<p>一个是不可修改的 <code>SimpleImmutableEntry</code>。</p>
<p>这2个 <code>Entry</code> 实现类，代码其实都差不多，下面分别看一下这2个实现类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key   == <span class="keyword">null</span> ? <span class="number">0</span> :   key.hashCode()) ^</span><br><span class="line">               (value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>SimpleImmutableEntry</code> 和 <code>SimpleEntry</code> 唯一的区别就是 <code>setValue</code> 方法。<code>SimpleEntry</code> 可以用 <code>setValue</code> 方法，而 <code>SimpleImmutableEntry</code> 使用 <code>setValue</code> 方法则会抛异常。：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key   == <span class="keyword">null</span> ? <span class="number">0</span> :   key.hashCode()) ^</span><br><span class="line">               (value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中这里面的 <code>eq</code> 就是一个内部私有静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1 == <span class="keyword">null</span> ? o2 == <span class="keyword">null</span> : o1.equals(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>AbstractList</title>
    <url>/lang/java/source/jdk8/collection/AbstractList/</url>
    <content><![CDATA[<h1 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p><code>AbstractList</code> 是一个抽象类，是一个 <code>List</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h2><p>在 <code>AbstractList</code> 中，有一个特殊的属性 <code>modCount</code>，用于统计列表被修改的次数（例如删除、添加等）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><code>modCount</code> 属性的作用是为了在并发修改列表时，能够快速失败（fail-fast）并抛出并发异常。例如多个线程同时修改列表时，就有可能对正在访问列表元素的线程造成影响，<code>modCount</code> 属性可用于判断当前列表是否是异常状态。</p>
<span id="more"></span>

<h2 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h2><p>一般的实现方法没什么特别的，只要了解其中一些有趣的实现。</p>
<h3 id="2-1-indexOf-和-lastIndexOf"><a href="#2-1-indexOf-和-lastIndexOf" class="headerlink" title="2.1 indexOf 和 lastIndexOf"></a>2.1 indexOf 和 lastIndexOf</h3><p>从 <code>indexOf</code> 的实现代码可以看出，<code>List</code> 是允许放置 <code>null</code> 元素的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 列表中的元素有可能是null</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 <code>indexOf()</code> 和 <code>lastIndexOf()</code> 的实现效果，有不同的返回值：</p>
<ul>
<li>使用 <code>indexOf()</code> 方法查询 <code>null</code> 时，会返回列表中第一个出现的 <code>null</code> 元素</li>
<li>使用 <code>lastIndexOf()</code> 方法查询 <code>null</code> 时，会返回列表中最后一个出现的 <code>null</code> 元素</li>
</ul>
<h3 id="2-2-hashCode"><a href="#2-2-hashCode" class="headerlink" title="2.2 hashCode"></a>2.2 hashCode</h3><p>对于一个列表集合而言，它的 <code>hashCode</code> 是根据列表集合中的所有元素计算得到的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : <span class="keyword">this</span>)</span><br><span class="line">        hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，对于每个空列表对象（也就是 <code>size()</code> 等于 0），它的 <code>hashCode</code> 值始终是 1。</p>
<p>另外，即使两个列表包含的元素一样，但只要元素的排列顺序不同，它的 <code>hashCode</code> 也是不同的。</p>
<h3 id="2-3-Itr-和-ListItr"><a href="#2-3-Itr-和-ListItr" class="headerlink" title="2.3 Itr 和 ListItr"></a>2.3 Itr 和 ListItr</h3><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><p><code>Itr</code> 和 <code>ListItr</code> 是迭代器的两个实现。</p>
<p><code>Itr</code> 是普通的迭代器实现，可以单向访问列表元素;<code>ListItr</code> 是列表专门的迭代器实现，可以用于双向访问列表元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ListItr</code> 本质上是在 <code>Itr</code> 的基础上进行了扩展，使得可以双向访问集合元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-属性-expectedModCount"><a href="#2-3-2-属性-expectedModCount" class="headerlink" title="2.3.2 属性 expectedModCount"></a>2.3.2 属性 expectedModCount</h4><p>在 <code>Itr</code> 和 <code>ListItr</code> 两个迭代器中，有一个特殊的属性 <code>expectedModCount</code>，可以用于检测列表并发修改。</p>
<p>在前面说过，<code>AbstractList</code> 中有一个属性 <code>modCount</code> 用于记录列表的修改次数。而 <code>expectedModCount</code> 则是记录列表在正常情况下的修改次数，当 <code>modCount ！= expectedModCount</code> 时，就认为列表发生了并发修改。</p>
<p><code>expectedModCount</code> 的值是在迭代器初始化时初始化的，初始值就是列表此时的修改次数 <code>modCount</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure>

<p>在使用迭代器访问元素时，都会先检测列表是否发生了并发修改，如果发生了并发修改，迭代器则会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代获取元素之前，都会验证列表是否发生了并发修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expectedModCount</code> 的值并不是一成不变的，因为迭代器可以进行 <code>remove</code> 等修改列表的操作，因此在迭代中使用了这些方法后，还需要再次同步列表的 <code>modCount</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">            cursor--;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 在迭代中修改后，同步列表中的修改次数，防止抛出并发异常</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-SubList-和-RandomAccessSubList"><a href="#2-4-SubList-和-RandomAccessSubList" class="headerlink" title="2.4 SubList 和 RandomAccessSubList"></a>2.4 SubList 和 RandomAccessSubList</h3><h4 id="2-4-1-SubList"><a href="#2-4-1-SubList" class="headerlink" title="2.4.1 SubList"></a>2.4.1 SubList</h4><p><code>SubList</code> 是 <code>AbstractList</code> 的内部子类，用于返回 <code>AbstractList</code> 的子列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 子列表的原始列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; l;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子列表在原始列表的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子列表的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    SubList(AbstractList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;fromIndex = &quot;</span> + fromIndex);</span><br><span class="line">        <span class="keyword">if</span> (toIndex &gt; list.size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;toIndex = &quot;</span> + toIndex);</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;fromIndex(&quot;</span> + fromIndex +</span><br><span class="line">                                               <span class="string">&quot;) &gt; toIndex(&quot;</span> + toIndex + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        l = list;</span><br><span class="line">        offset = fromIndex;</span><br><span class="line">        size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以直接看出，子列表 <code>SubList</code> 实际上只是一个代理，它实际返回的还是原始列表的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">return</span> l.get(index+offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，由于子列表是共用原始列表的元素，因此还需要考虑并发的问题，和迭代器同样地，是通过检测列表的修改次数来检测的。因为 <code>SubList</code>继承自 <code>AbstractList</code>，所以在子列表中，和 <code>expectedModCount</code> 相同功能的属性就是 <code>modCount</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.modCount != l.modCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-RandomAccessSubList"><a href="#2-4-2-RandomAccessSubList" class="headerlink" title="2.4.2 RandomAccessSubList"></a>2.4.2 RandomAccessSubList</h4><p><code>RandomAccessSubList</code> 也是一个子列表，继承自 <code>SubList</code>，它的含义是可以随机访问元素的子列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomAccessSubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    RandomAccessSubList(AbstractList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">super</span>(list, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomAccessSubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是实际上，由于 <code>SubList</code> 已经实现了随机访问的功能，因此 <code>RandomAccessSubList</code> 并没有再进行任何其他的扩展，只是单纯继承了 <code>SubList</code>，并实现了 <code>RandomAccess</code> 接口而已。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>注解@Enumerated</title>
    <url>/lang/java/core/enumerated/</url>
    <content><![CDATA[<h1 id="Enumerated"><a href="#Enumerated" class="headerlink" title="@Enumerated"></a>@Enumerated</h1><p><code>@Enumerated</code> 是JDK中 <code>javax.persistence</code> 包下的注解，用在持久化实体类属性或字段上，表示该属性或字段应该按照枚举类型 <code>Enum</code> 来持久化。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">    MALE,</span><br><span class="line">    FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="meta">@Enumerated</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他属性方法，后面也是</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性或字段按照枚举类型来持久化时，可以分为两种情况：原始类型和字符串类型。</p>
<span id="more"></span>

<p>枚举持久化类型可以在 <code>javax.persistence.EnumType</code> 类中找到，其中 <code>ORDINAL</code> 表示原始类型；<code>STRING</code> 表示字符串类型。例如字符串类型的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有特别指定类型，枚举属性或字段默认按照 <code>ORDINAL</code> 来持久化。</p>
<h2 id="1-原始类型"><a href="#1-原始类型" class="headerlink" title="1. 原始类型"></a>1. 原始类型</h2><p><code>ORDINAL</code> 表示将枚举类按照其原始类型，也就是整数，来持久化。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="meta">@Enumerated(EnumType.ORDINAL)</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果按照上述的代码执行，枚举字段 <code>gender</code> 将被转成数据库的整型字段（以Mysql为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA    &lt;---&gt;  Mysql</span><br><span class="line">gender  &lt;---&gt;  int(11)</span><br></pre></td></tr></table></figure>

<p>也就是当 <code>Person</code> 对象被持久化到数据库时，枚举字段 <code>gender</code> 的值将按照其整数值来保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gender  &lt;---&gt;  Mysql</span><br><span class="line">MALE    &lt;---&gt;  0</span><br><span class="line">FEMALE  &lt;---&gt;  1</span><br></pre></td></tr></table></figure>

<h2 id="2-字符串类型"><a href="#2-字符串类型" class="headerlink" title="2. 字符串类型"></a>2. 字符串类型</h2><p><code>STRING</code> 表示将枚举类按照字符串类型持久化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果按照上述的代码执行，枚举字段 <code>gender</code> 将被转成数据库的字符串字段（以Mysql为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA    &lt;---&gt;  Mysql</span><br><span class="line">gender  &lt;---&gt;  varchar(255)</span><br></pre></td></tr></table></figure>

<p>当 <code>Person</code> 对象被持久化到数据库时，枚举字段 <code>gender</code> 的值不再按照原始整数来保存，而是将按照其字符串值来保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gender  &lt;---&gt;  Mysql</span><br><span class="line">MALE    &lt;---&gt;  MALE</span><br><span class="line">FEMALE  &lt;---&gt;  FEMALE</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>总的来说，<code>@Enumerated</code> 注解是用来标识枚举字段是按照什么方式来持久化的，也就是保存到数据库的数据类型：</p>
<ol>
<li><code>@Enumerated(EnumType.ORDINAL)</code> 就是保存枚举字段的的整数值（序号）；</li>
<li><code>@Enumerated(EnumType.STRING)</code> 就是保存枚举字段的字符串值。</li>
</ol>
<p>另外，不指定类型的 <code>@Enumerated</code> 等于 <code>@Enumerated(EnumType.ORDINAL)</code> 。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON数据格式</title>
    <url>/lang/js/json_data/</url>
    <content><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON 是一种数据格式，不是一种编程语言。一般用于Web服务的前后端的数据交流格式。</p>
<h2 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h2><p>JSON 的语法可以有3种类型的值：</p>
<ul>
<li>简单值：包括字符串、数值、布尔值和 null（但是不支持 Javascript 中的 undefined）</li>
<li>对象：表示一组无序的键值对</li>
<li>数组：表示一组有序的值的列表</li>
</ul>
<h2 id="二、与-Jsvacript-的区别"><a href="#二、与-Jsvacript-的区别" class="headerlink" title="二、与 Jsvacript 的区别"></a>二、与 Jsvacript 的区别</h2><span id="more"></span>

<ul>
<li>Javascript 是一种编程语言，JSON只是一种数据格式</li>
<li>JSON 没有变量声明，也没有末尾的分号<code>;</code></li>
<li>JSON 字符串必须使用双引号（单引号会导致语法错误）</li>
</ul>
<p>Javascript 的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>，</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON 的语法：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Zhangsan&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、解析与序列化"><a href="#三、解析与序列化" class="headerlink" title="三、解析与序列化"></a>三、解析与序列化</h2><p>JSON 数据是 Web 服务中数据交换的格式，因此它可以与 Javascript 对象相互转换。</p>
<p>早期的浏览器，一般使用 <code>eval()</code> 函数来解析、解释 JSON 字符串并返回 Javascript 对象或数组。</p>
<p>ECMAScript 5 对解析 JSON 的行为进行来规范，定义了全局对象 JSON。</p>
<p>JSON 对象有两个方法：<code>stringify()</code> 和 <code>parse()</code>。其中 <code>stringify()</code> 用于将 Javascript 对象或数组序列化成 JSON 字符串，<code>parse()</code> 方法用于将 JSON 字符串解析成 avascript 对象或数组。</p>
<h3 id="3-1-序列化"><a href="#3-1-序列化" class="headerlink" title="3.1 序列化"></a>3.1 序列化</h3><p>JSON 序列化负责将 Javascript 对象或数组序列化成 JSON 字符串，实现这个功能的方法是 <code>JSON.stringify()</code>。</p>
<p><code>stringify</code> 方法的参数有3个：</p>
<ul>
<li>需要序列化的 Javascript 对象</li>
<li>过滤器，可以是数组，也可以是函数</li>
<li>JSON 字符串的缩进值，可以是数值，也可以是字符串</li>
</ul>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Zhangsan&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-1-过滤器"><a href="#3-1-1-过滤器" class="headerlink" title="3.1.1 过滤器"></a>3.1.1 过滤器</h4><p>使用 <code>stringify</code> 的第2个参数，可以自定义过滤序列化的结果。</p>
<p>过滤器参数可以有2种格式：数组和函数。</p>
<p>1）如果过滤器参数是数组，那么 <code>stringify</code> 序列化的结果只会返回包含在数组中的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器是数组</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj, [<span class="string">&#x27;name&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Zhangsan&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>2）如果过滤器参数是函数，该函数会接收2个参数：属性（键）名和属性值。</p>
<p>函数返回值就是对应属性（键）名的值，如果函数返回值是 <code>undefined</code>，那么相应的属性会被忽略：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器是函数</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Zhangsan&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-缩进"><a href="#3-1-2-缩进" class="headerlink" title="3.1.2 缩进"></a>3.1.2 缩进</h4><p>默认情况下，<code>JSON.stringify()</code> 输出的 JSON 字符串是不包含任何空格字符或缩进的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Zhangsan&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>stringify</code> 方法的第3个参数，可以控制序列化结果中的缩进和空白符。</p>
<p>缩进参数可以有2种格式：数值和字符串。</p>
<p>1）如果缩进参数是数值，表示的是每个缩进级别的空格数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj, <span class="literal">null</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为（缩进空格数为4）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Zhangsan&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要传入了有效的缩进参数值，结果字符串也会包含换行符（因为只缩进不换行意义不大）。</p>
<p>最大缩进格数为10，所有大于10的值都会自动转换为10。</p>
<p>2）如果缩进参数是字符串，则这个字符串将会被用作缩进字符（不再使用空格）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj, <span class="literal">null</span>, <span class="string">&#x27;----&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为（缩进字符不再是空格）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">----<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Zhangsan&quot;</span>,</span><br><span class="line">----<span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩进字符最大长度也不能超过10，如果字符长度超过了10，就会被截取成10个字符。</p>
<h4 id="3-1-3-toJSON"><a href="#3-1-3-toJSON" class="headerlink" title="3.1.3 toJSON"></a>3.1.3 toJSON</h4><p>有时候，<code>JSON.stringify()</code> 还不能满足自定义序列化的需求，因此可以给对象定义 <code>toJSON</code> 方法，返回自定义的 JSON 数据格式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">toJSON</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;sex&quot;</span>: <span class="string">&quot;female&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Javascript 对象序列化</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonText</code> 的值为（缩进字符不再是空格）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;sex&quot;</span>: <span class="string">&quot;female&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-4-序列化顺序"><a href="#3-1-4-序列化顺序" class="headerlink" title="3.1.4 序列化顺序"></a>3.1.4 序列化顺序</h4><ol>
<li>如果存在 <code>toJSON</code> 方法，返回该方法的返回值，否则，返回对象本身</li>
<li>如果提供了第2个参数，对第1步返回的值进行过滤</li>
<li>对第2步返回的每个值进行序列化</li>
<li>如果提供了第3个参数，执行相应的格式化</li>
</ol>
<h3 id="3-2-解析"><a href="#3-2-解析" class="headerlink" title="3.2 解析"></a>3.2 解析</h3><p>JSON 解析负责将 JSON 字符串解析成 Javascript 对象，实现这个功能的方法是 <code>JSON.parse()</code>。</p>
<p><code>parse</code> 方法的参数有2个：</p>
<ul>
<li>需要解析的 JSON 字符串</li>
<li>还原函数，和过滤器函数类似</li>
</ul>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;Zhangsan&quot;,&quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 数据解析</span></span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(jsonText);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonObj</code> 的值为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Zhangsan&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-还原函数"><a href="#3-2-1-还原函数" class="headerlink" title="3.2.1 还原函数"></a>3.2.1 还原函数</h4><p>还原函数和过滤器函数类似，也是接收2个参数：属性（键）名和属性值。</p>
<p>还原函数的返回值将作为属性（键）名的值，如果函数返回 <code>undefined</code>，表示从结果中删除相应的键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;Zhangsan&quot;,&quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 数据解析，增加还原函数</span></span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>则 <code>jsonObj</code> 的值为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Zhangsan&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js如何处理错误</title>
    <url>/lang/js/error/</url>
    <content><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>在 Javascript 中，处理异常的方式一般有两种：</p>
<ul>
<li>try-catch 语句捕获异常</li>
<li>onerror 事件捕获异常</li>
</ul>
<h2 id="一、try-catch-语句"><a href="#一、try-catch-语句" class="headerlink" title="一、try-catch 语句"></a>一、try-catch 语句</h2><span id="more"></span>

<p>try-catch 语句是 Javascript 中处理异常的一种标准方式，基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会导致错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 在错误发生时处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 catch 捕获的异常对象 error，在不同浏览器中它包含的信息可能不太一样。一般来说，error 中通用的属性仅包括 message，也就是说，在跨浏览器编写代码时，最好只使用 message 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会导致错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 跨浏览器的通用属性仅有 message</span></span><br><span class="line">    alert(error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，try-catch 语句还包括了 finally 块，用于表示 finally 块内的语句一定会执行。</p>
<p>无论代码怎么处理，下述代码最后返回的结果始终是 finally 块的 0：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 错误处理代码</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外需要注意的是，如果代码中包含了 finally 语句，那么 try 块和 catch 块内的 return 语句都将会被忽略，下述代码返回的既不是 1 也不是 -1,实际返回的是 finally 的代码结果，但是由于 finally 块内没有 return 语句，因此会默认返回 <code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 错误处理代码</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="comment">// 实际上这里会返回 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此在使用 finally 块时，需要注意它的返回值。</p>
<p>还有一点需要说的就是，IE7 以前的版本有一个 bug，如果没有 catch 语句，finally 也不会执行。因此在写 IE7 以前版本的代码时，使用 finally 语句时必须要先写 catch 语句。</p>
<h3 id="1-1-错误类型"><a href="#1-1-错误类型" class="headerlink" title="1.1 错误类型"></a>1.1 错误类型</h3><p>ECMA-262 定义了7种错误类型：</p>
<ul>
<li>Error</li>
<li>EvalError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<h4 id="1-1-1-Error"><a href="#1-1-1-Error" class="headerlink" title="1.1.1 Error"></a>1.1.1 Error</h4><p><code>Error</code> 是基类型，其他错误类型均继承自该类型。</p>
<h4 id="1-1-2-EvalError"><a href="#1-1-2-EvalError" class="headerlink" title="1.1.2 EvalError"></a>1.1.2 EvalError</h4><p><code>EvalError</code> 会在使用 <code>eval()</code> 函数时发生异常而被抛出，比如如果没有把 eval 当作函数来调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些会抛出异常</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">eval</span>();</span><br><span class="line"><span class="built_in">eval</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-RangeError"><a href="#1-1-3-RangeError" class="headerlink" title="1.1.3 RangeError"></a>1.1.3 RangeError</h4><p><code>RangeError</code> 会在数值超出相应范围时触发。比如数组的大小超出了范围：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非法范围会抛出异常</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(-<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Number</span>.MAX_VALUE);</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-ReferenceError"><a href="#1-1-4-ReferenceError" class="headerlink" title="1.1.4 ReferenceError"></a>1.1.4 ReferenceError</h4><p><code>ReferenceError</code> 会在访问不存在的变量时触发，比如把未声明的变量用来赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// firstname 未定义时会抛出异常</span></span><br><span class="line"><span class="keyword">var</span> name = firstname;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-5-SyntaxError"><a href="#1-1-5-SyntaxError" class="headerlink" title="1.1.5 SyntaxError"></a>1.1.5 SyntaxError</h4><p><code>SyntaxError</code> 一般是因为语法错误引起，比如将语法错误的字符串传进 eval 中执行时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法错误异常</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;a ++ b&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-1-6-TypeError"><a href="#1-1-6-TypeError" class="headerlink" title="1.1.6 TypeError"></a>1.1.6 TypeError</h4><p><code>TypeError</code> 会在变量中保存着意外的类型，或者在访问不存在的方法时触发。比如传给函数的参数类型与预期的类型不相符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-1-7-URIError"><a href="#1-1-7-URIError" class="headerlink" title="1.1.7 URIError"></a>1.1.7 URIError</h4><p><code>URIError</code> 一般会在使用 <code>encodeURI()</code> 或 <code>decodeURI()</code>，而 URI 格式不正确时触发。不过这两个方法的容错率比较高，不容易触发这个错误。</p>
<h3 id="1-2-throw-抛出异常"><a href="#1-2-throw-抛出异常" class="headerlink" title="1.2 throw 抛出异常"></a>1.2 throw 抛出异常</h3><p>与 try-catch 语句相配的还有一个 throw 操作符，用于抛出自定义错误。</p>
<p>使用 throw 抛出错误时，必须指定一个错误值，但是这个错误值的类型没有要求，可以是任意类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">123</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>但是一般来说，抛出 Error 错误类型会更好一些，因为这样会比较方便 catch 处理该异常信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">EvalError</span>(<span class="string">&quot;eval error!&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;type error!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>也可以自定义错误，利用原型链继承 Error 来创建自定义的错误类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomError</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;CustomError&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">&quot;custom error!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="二、onerror-事件"><a href="#二、onerror-事件" class="headerlink" title="二、onerror 事件"></a>二、onerror 事件</h2><p>任何没有通过 try-catch 语句处理的错误都会触发 window 对象的 error 事件（Opera、Safari 浏览器不支持 error 事件）。</p>
<p>在任何 Web 浏览器中，onerror 事件处理程序都不会创建 event 对象，只会接收3个参数：</p>
<ul>
<li>错误信息</li>
<li>错误所在的 URL</li>
<li>错误所在行号</li>
</ul>
<p>只要发生错误，无论是不是浏览器生成的，都会触发 error 事件。</p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>事件的监听以及处理</title>
    <url>/lang/js/events/</url>
    <content><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件，是文档或浏览器窗口中发生的一些特定的交互瞬间。</p>
<p>下面分别介绍事件中的几个重要特性：</p>
<ul>
<li>事件流</li>
<li>事件处理程序</li>
<li>事件对象</li>
</ul>
<h2 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h2><p>事件流是用于描述页面接收事件的顺序。</p>
<span id="more"></span>

<p>根据事件的捕获顺序不同，事件流分为2种：</p>
<ul>
<li>事件冒泡流</li>
<li>事件捕获流</li>
</ul>
<h3 id="1-1-事件冒泡"><a href="#1-1-事件冒泡" class="headerlink" title="1.1 事件冒泡"></a>1.1 事件冒泡</h3><p>事件冒泡，是指事件由最具体的元素（即最底层的节点）接收，然后逐级向上传播到较为不具体的节点（即最顶层的节点，文档），属于由下向上传播事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果点击了页面中的 div 元素，那么这个 click 事件会按照以下顺序传播：</p>
<ol>
<li><code>&lt;div&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>document</code></li>
</ol>
<p>所有浏览器都支持事件冒泡。</p>
<h3 id="1-2-事件捕获"><a href="#1-2-事件捕获" class="headerlink" title="1.2 事件捕获"></a>1.2 事件捕获</h3><p>事件冒泡，是指事件由较不具体的元素（即最顶层的节点，文档）接收，然后逐级向下传播到最不具体的节点（即最底层的节点），属于由上到下传播事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果点击了页面中的 div 元素，那么这个 click 事件会按照以下顺序传播：</p>
<ol>
<li><code>document</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;div&gt;</code></li>
</ol>
<p>老版本的浏览器不支持事件捕获。</p>
<h3 id="1-3-DOM-事件流"><a href="#1-3-DOM-事件流" class="headerlink" title="1.3 DOM 事件流"></a>1.3 DOM 事件流</h3><p>“DOM2级事件”规定的事件流包括3个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以 div 的点击事件为例，事件流的顺序是：</p>
<ol>
<li><code>document</code>（捕获）</li>
<li><code>&lt;html&gt;</code>（捕获）</li>
<li><code>&lt;body&gt;</code>（捕获）</li>
<li><code>&lt;div&gt;</code>（目标、冒泡）</li>
<li><code>&lt;body&gt;</code>（冒泡）</li>
<li><code>&lt;html&gt;</code>（冒泡）</li>
<li><code>document</code>（冒泡）</li>
</ol>
<p>另外，在 DOM 事件流中，实际目标接收事件的时候不是处于捕获阶段，而是属于冒泡阶段。</p>
<p>也就是说，实际上只分为2个阶段：事件捕获阶段、事件冒泡阶段（包括处于目标阶段）。</p>
<h2 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h2><p>事件是用户或浏览器自身执行的某种动作，而事件处理程序就是响应某个事件的函数。</p>
<p>一般情况下，事件处理程序的名字以<code>on</code>开头，具体形式为<code>“on” + 事件名</code>。</p>
<p>例如 <code>click</code> 事件的事件处理程序就是 <code>onclick</code>，<code>load</code> 事件的事件处理程序就是<code>onload</code>。</p>
<p>为事件指定事件处理程序的方式有几种：</p>
<ul>
<li>HTML事件处理程序</li>
<li>DOM0级事件处理程序</li>
<li>DOM2级事件处理程序</li>
<li>IE事件处理程序</li>
</ul>
<h3 id="2-1-HTML事件处理程序"><a href="#2-1-HTML事件处理程序" class="headerlink" title="2.1 HTML事件处理程序"></a>2.1 HTML事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来执行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;click&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如 div 的<code>click</code>事件就可以用<code>onclick</code>来指定事件处理程序。</p>
<p>以这种方式来指定事件处理程序，有一些特别的性质：</p>
<ul>
<li>会创建一个封装着元素属性值的函数；</li>
<li>事件处理程序的<code>this</code>值等于当前事件的目标元素；</li>
<li>事件处理函数中有一个局部变量事件对象<code>event</code>，不需要自己定义，也不需要从函数的参数列表获取。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(event.type) <span class="comment">// </span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">value</span>=<span class="string">&quot;Click&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(this.value)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- event 属性不需要定义，也不需要从参数列表中拿 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;handleClick(event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样指定事件处理程序实际上会创建一个函数来执行指定的事件代码，差不多类似于以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  handleClick(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种指定的方式也有一些缺点：</p>
<ul>
<li>存在时差问题。由于事件处理程序是直接绑定在HTML元素上面的，因此有可能在HTML元素渲染时就触发了事件处理程序，但是当时的事件处理程序有可能还不具备执行条件，从而导致执行出现异常；</li>
<li>在不同的浏览器中，事件处理程序的作用域链有可能存在一些差异，从而导致不同的结果；</li>
<li>HTML与Javascript代码紧密耦合，不方便后续的维护。</li>
</ul>
<h3 id="2-2-DOM0-级事件处理程序"><a href="#2-2-DOM0-级事件处理程序" class="headerlink" title="2.2 DOM0 级事件处理程序"></a>2.2 DOM0 级事件处理程序</h3><p>由于用 HTML 来指定事件处理程序，会使得 HTML 代码和 Javascript 代码耦合，并且不好维护。</p>
<p>因此为了处理这种情况，可以只使用 Javascript 来指定事件处理程序，这样不仅简单，在跨浏览器上兼容也比较容易。</p>
<p>每个 DOM 元素（包括 window 和 document）都有自己的事件处理程序属性，通常都是全部小写，例如 <code>onclick</code>。把事件处理程序属性设置为一个函数，就可以指定事件处理程序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式称为 DOM0 级方法指定事件处理程序。</p>
<p>这种方式有几个特点：</p>
<ul>
<li>事件处理程序中的 <code>this</code> 表示当前元素；</li>
<li>事件处理程序会在事件流的冒泡阶段被处理。</li>
</ul>
<p>删除 DOM0 级方法指定的事件处理程序也很简单，直接赋值为 <code>null</code> 就可以了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除事件处理程序</span></span><br><span class="line">btn.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-DOM2-级事件处理程序"><a href="#2-3-DOM2-级事件处理程序" class="headerlink" title="2.3 DOM2 级事件处理程序"></a>2.3 DOM2 级事件处理程序</h3><p>DOM0 级方式指定事件处理程序时，只能指定一个事件处理程序，当需要多个处理程序对同一个对象的同一个事件进行处理时，没有办法做到。</p>
<p>因此在 DOM2 级中，添加了2个方法，用于处理指定和删除事件处理程序的操作：</p>
<ul>
<li>addEventListener()</li>
<li>removeEventListener()</li>
</ul>
<p>所有 DOM 节点都包含这2个方法，这2个方法都接收3个参数：</p>
<ul>
<li>要处理的事件名，比如 <code>onclick</code></li>
<li>指定的事件处理函数</li>
<li>一个布尔值，true 表示在捕获阶段调用事件处理函数，false 表示在冒泡阶段调用事件处理函数。</li>
</ul>
<p>以这种方式来指定事件处理程序，有几个特点：</p>
<ul>
<li>可以添加多个事件处理程序；</li>
<li>事件处理函数中的 <code>this</code> 表示当前元素；</li>
<li>移除事件处理程序时，必现传入和添加处理程序时使用的参数相同。也就是说，如果添加的事件处理程序是匿名函数，将无法对它进行移除。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加匿名函数，意味着无法移除</span></span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以添加多个事件处理程序，按添加顺序执行</span></span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件处理时，传入的参数必须和添加时相同</span></span><br><span class="line">btn.removeEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-IE-事件处理程序"><a href="#2-4-IE-事件处理程序" class="headerlink" title="2.4 IE 事件处理程序"></a>2.4 IE 事件处理程序</h3><p>和 DOM 中不同的是，IE 并没有实现 <code>addEventListener</code> 和 <code>removeEventListener</code>，而是另外实现了和这2个方法功能相近的方法：</p>
<ul>
<li>attachEvent()</li>
<li>detachEvent()</li>
</ul>
<p>IE 的事件处理和 DOM2 的事件处理有几点区别：</p>
<ul>
<li>IE8 以前只支持事件冒泡，所以 <code>attachEvent</code> 添加的事件处理只能在冒泡阶段被执行；</li>
<li><code>attachEvent</code> 的事件参数是 <code>onclick</code>，而 <code>addEventListener</code> 的事件参数是 <code>click</code>，没有加上 <code>on</code>；</li>
<li><code>attachEvent</code> 的事件处理函数的作用域是全局作用域，而 <code>addEventListener</code> 的则是所属元素的作用域；</li>
<li><code>attachEvent</code> 添加的事件处理程序是按添加顺序反序执行的，而 <code>addEventListener</code> 是按添加顺序执行的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里是 onclick，而不是 DOM 的 click</span></span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在全局作用域下运行</span></span><br><span class="line">  alert(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">&#125;); <span class="comment">// 没有第3个参数，事件处理只会在冒泡阶段执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以添加多个事件处理程序，按添加顺序反序执行</span></span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件处理时，传入的参数必须和添加时相同</span></span><br><span class="line">btn.detachEvent(<span class="string">&quot;onclick&quot;</span>, handler);</span><br></pre></td></tr></table></figure>

<p>ps：需要特别注意的就是，使用<code>attachEvent</code>绑定的事件处理程序的作用域比较特殊，它的<code>this</code>并不是代表当前所属元素。</p>
<h3 id="2-5-跨浏览器事件处理程序"><a href="#2-5-跨浏览器事件处理程序" class="headerlink" title="2.5 跨浏览器事件处理程序"></a>2.5 跨浏览器事件处理程序</h3><p>针对不同的浏览器，可以写出跨浏览器的方式处理事件。</p>
<p>跨浏览器事件处理只需要处理冒泡阶段，因为有些浏览器版本是不支持捕获事件的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="attr">addHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">removeHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h2><p>在触发 DOM 上的某个事件时，都会产生一个事件对象 event，这个对象包含着所有与事件有关的信息。</p>
<p>事件对象包括导致事件的元素、事件类型以及其他相关信息。</p>
<p>所有浏览器都支持事件对象，但是不同浏览器有不同的实现。</p>
<p>针对不同的浏览器，事件对象 event 也有不同的实现：</p>
<ul>
<li>DOM 中的事件对象</li>
<li>IE 中的事件对象</li>
</ul>
<h3 id="3-1-DOM-中的事件对象"><a href="#3-1-DOM-中的事件对象" class="headerlink" title="3.1 DOM 中的事件对象"></a>3.1 DOM 中的事件对象</h3><p>对于不同的绑定事件处理程序的方式，获取事件对象的方式也不一样。</p>
<p>1）HTML 事件处理程序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(event.type)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 HTML 指定事件程序这种方法中，事件对象 event 是保存在变量 event 中的，可以直接拿到。 </p>
<p>2）DOM0/DOM2 级事件处理程序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准 DOM0 级</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准 DOM2 级</span></span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>对于 DOM2/DOM2 级指定事件处理程序的方式，event 对象可以直接在事件处理程序的参数中获取。</p>
<p>DOM 中的事件对象有一些特殊的属性和方法：</p>
<table>
<thead>
<tr>
<th align="left">属性/方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bubbles</td>
<td align="left">表明事件是否可以冒泡</td>
</tr>
<tr>
<td align="left">cancelable</td>
<td align="left">表明是否可以取消事件的默认行为</td>
</tr>
<tr>
<td align="left">currentTarget</td>
<td align="left">当前事件处理程序绑定的元素</td>
</tr>
<tr>
<td align="left">defaultPrevented</td>
<td align="left">为 true 表示已经调用过 preventDefault() 了</td>
</tr>
<tr>
<td align="left">eventPhase</td>
<td align="left">当前事件流阶段。1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段</td>
</tr>
<tr>
<td align="left">target</td>
<td align="left">触发事件的元素</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">事件类型</td>
</tr>
<tr>
<td align="left">preventDefault()</td>
<td align="left">取消默认的事件行为。只有 cancelable=true 时才能生效</td>
</tr>
<tr>
<td align="left">stopPropagation()</td>
<td align="left">取消事件的进一步捕获或冒泡。只有 bubbles=true 时才能生效</td>
</tr>
<tr>
<td align="left">stopImmediatePropagation()</td>
<td align="left">取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用</td>
</tr>
</tbody></table>
<h4 id="3-1-1-target"><a href="#3-1-1-target" class="headerlink" title="3.1.1 target"></a>3.1.1 target</h4><p>在事件处理程序内部，<code>this</code> 始终等于 <code>currentTarget</code>，而 <code>target</code> 则只是事件的目标对象（即触发事件的元素）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的元素的事件处理</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.currentTarget === <span class="built_in">this</span>); <span class="comment">// true</span></span><br><span class="line">  alert(event.target === <span class="built_in">this</span>);        <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获/冒泡阶段的事件处理</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// currentTarget 执行的是当前事件处理程序的绑定元素</span></span><br><span class="line">  alert(event.currentTarget === <span class="built_in">this</span>);          <span class="comment">// true</span></span><br><span class="line">  alert(event.currentTarget === <span class="built_in">document</span>.body); <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// target 始终指向的是触发事件的元素</span></span><br><span class="line">  alert(event.target === <span class="built_in">this</span>);                 <span class="comment">// false</span></span><br><span class="line">  alert(event.target === btn);                  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-preventDefault"><a href="#3-1-2-preventDefault" class="headerlink" title="3.1.2 preventDefault()"></a>3.1.2 preventDefault()</h4><p>为了阻止事件的默认行为，可以使用 <code>preventDefault()</code> 方法，但是要使用这个方法，必须确保 <code>cancelable=true</code> 才行，否则方法不会生效。</p>
<p>默认行为指的是 dom 元素的默认动作，比如 <code>&lt;a hrtf=&quot;&quot;&gt;</code> 元素的默认行为就是在 <code>click</code> 触发时导航到 href 指定的 URL。使用 <code>preventDefault()</code> 可以阻止其跳转。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myLink&quot;</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-stopPropagation"><a href="#3-1-3-stopPropagation" class="headerlink" title="3.1.3 stopPropagation()"></a>3.1.3 stopPropagation()</h4><p>为了阻止事件继续在事件流里传播，可以使用 <code>stopPropagation()</code> 方法，但是使用这个方法前，要确保 <code>bubbles=true</code> 才行，否则方法不会生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的元素的事件处理</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;btn click&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获/冒泡阶段的事件处理</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;doc click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，由于事件的冒泡，当点击按钮时，会弹出2个警告框。</p>
<p>因此为了避免这种情况，可以使用 <code>stopPropagation()</code> 方法来阻止事件进一步传播：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的元素的事件处理</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;btn click&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 阻止事件继续传播</span></span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获/冒泡阶段的事件处理</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;doc click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，点击按钮时，只会弹出1个警告框。</p>
<p>但是 <code>stopPropagation()</code> 还存在一个问题，它只能阻止事件的冒泡，但是不能阻止同级事件处理程序的执行。前面说过，一个事件可以绑定多个事件处理程序，<code>stopPropagation()</code> 是没有阻止当前目标元素的其他事件处理程序的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;handler1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻止事件继续传播</span></span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> handler2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;handler2&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以添加多个事件处理程序，按添加顺序执行</span></span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler1, <span class="literal">false</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler2, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>这个时候点击按钮，依旧会弹出2个警告框，因为<code>stopPropagation()</code>只是阻止了事件冒泡，但是同级事件处理程序还是会执行的。</p>
<p>所以在 DOM3 中，添加了一个新的方法<code>stopImmediatePropagation()</code>，它可以阻止后续的所有事件处理程序执行，包括同级别的事件处理程序。</p>
<h3 id="3-2-IE-中的事件对象"><a href="#3-2-IE-中的事件对象" class="headerlink" title="3.2 IE 中的事件对象"></a>3.2 IE 中的事件对象</h3><p>IE 中的事件对象获取方式有些不同，它取决于在IE中指定事件处理程序的方法。例如：</p>
<p>在IE中使用DOM0级方法添加事件处理程序时，event 事件对象是作为 window 对象的一个属性存在的；</p>
<p>但是在 IE 中使用 <code>attachEvent()</code> 添加事件处理程序时，event 对象是作为事件处理函数的参数存在的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE 下的 DOM0 级</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE 下的 DOM2 级</span></span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>IE 中的事件对象有一些特殊的属性和方法：</p>
<table>
<thead>
<tr>
<th align="left">属性/方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cancelBubble</td>
<td align="left">用于是否取消事件冒泡，与stopPropagation()作用相同</td>
</tr>
<tr>
<td align="left">returnValue</td>
<td align="left">用于是否取消事件的默认行为，与preventDefault()作用相同</td>
</tr>
<tr>
<td align="left">srcElement</td>
<td align="left">当前事件处理程序绑定的元素，与target属性相同</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">事件类型</td>
</tr>
</tbody></table>
<h4 id="3-2-1-srcElement"><a href="#3-2-1-srcElement" class="headerlink" title="3.2.1 srcElement"></a>3.2.1 srcElement</h4><p>事件处理程序的作用域是由指定它的方式来确定的，因此在写代码时需要特别注意，最好还是使用<code>event.srcElement</code>来替代``this`来作为当前目标对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE 下的 DOM0 级</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  alert(event.srcElement === <span class="built_in">this</span>); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE 下的 DOM2 级</span></span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.srcElement === <span class="built_in">this</span>); <span class="comment">// false</span></span><br><span class="line">  alert(<span class="built_in">window</span> === <span class="built_in">this</span>);           <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-retrunValue"><a href="#3-3-2-retrunValue" class="headerlink" title="3.3.2 retrunValue"></a>3.3.2 retrunValue</h4><p>IE 中取消事件默认行为的方法是使用<code>returnValue=false</code>，与<code>preventDefault()</code>作用相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myLink&quot;</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  event.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和标准 DOM 不同的是，IE 中没有方法确定事件是否可以被取消。</p>
<h4 id="3-2-3-cancelBubble"><a href="#3-2-3-cancelBubble" class="headerlink" title="3.2.3 cancelBubble"></a>3.2.3 cancelBubble</h4><p>IE 中阻止事件冒泡的方法是使用<code>cancelBubble=true</code>，与<code>stopPropagation()</code>作用相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的元素的事件处理</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  alert(<span class="string">&quot;btn click&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 阻止事件继续传播</span></span><br><span class="line">  event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获/冒泡阶段的事件处理</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;doc click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击按钮，只会弹出一个警告框。</p>
<h3 id="3-3-跨浏览器的事件对象"><a href="#3-3-跨浏览器的事件对象" class="headerlink" title="3.3 跨浏览器的事件对象"></a>3.3 跨浏览器的事件对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="attr">addHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">removeHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getEvent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getTarget</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">preventDefault</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">stopPropagation</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器中的BOM对象</title>
    <url>/lang/js/bom/</url>
    <content><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM 是指浏览器对象模型。</p>
<p>主要用于开发人员控制浏览器显示的界面以外的部分，例如浏览器窗口的位置、浏览器的地址信息、浏览历史界面的前进后退等。</p>
<h2 id="一、window"><a href="#一、window" class="headerlink" title="一、window"></a>一、window</h2><p>window 对象是 BOM 的核心对象，表示浏览器的一个实例。</p>
<h3 id="1-1-全局声明"><a href="#1-1-全局声明" class="headerlink" title="1.1 全局声明"></a>1.1 全局声明</h3><p>window 既是访问浏览器窗口的接口，也是 ECMAScript 的全局对象（Global）。</p>
<span id="more"></span>

<p>直接在全局作用域声明的变量、函数等都会变成 window 对象的属性和方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> name = <span class="string">&#x27;zhangsan&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  </span></span><br><span class="line"><span class="javascript">  alert(name)              <span class="comment">// zhangsan</span></span></span><br><span class="line"><span class="javascript">  alert(getName())         <span class="comment">// zhangsan</span></span></span><br><span class="line"><span class="javascript">  alert(<span class="built_in">window</span>.name)       <span class="comment">// zhangsan </span></span></span><br><span class="line"><span class="javascript">  alert(<span class="built_in">window</span>.getName())  <span class="comment">// zhangsan</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然定义全局变量会直接归到 window 中，但是还是和直接在 window 中定义的属性有点不同。</p>
<p>全局变量不能使用 <code>delete</code> 删除变量，但是在 window 中定义的属性是可以的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> name = <span class="string">&#x27;zhangsan&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.age = <span class="number">12</span></span></span><br><span class="line"><span class="javascript">  </span></span><br><span class="line"><span class="javascript">  alert(<span class="built_in">window</span>.name) <span class="comment">// zhangsan </span></span></span><br><span class="line"><span class="javascript">  alter(<span class="built_in">window</span>.age)  <span class="comment">// 12</span></span></span><br><span class="line"><span class="javascript">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 删除无用</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">delete</span> <span class="built_in">window</span>.name</span></span><br><span class="line"><span class="javascript">  alter(<span class="built_in">window</span>.name) <span class="comment">// zhangsan</span></span></span><br><span class="line"><span class="javascript">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 可以删除</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">delete</span> <span class="built_in">window</span>.age</span></span><br><span class="line"><span class="javascript">  alter(<span class="built_in">window</span>.age)  <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>产生这种情况的原因是，全局声明的变量，虽然被归到 window 中，但是它的一个特性值 <code>[[Configurable]]</code> 默认会被设为 <code>false</code>，导致全局声明的变量没有办法使用 <code>delete</code> 进行删除。</p>
<h3 id="1-2-窗口和框架"><a href="#1-2-窗口和框架" class="headerlink" title="1.2 窗口和框架"></a>1.2 窗口和框架</h3><p>框架，一般指的是 <code>HTML</code> 中的 <code>&lt;frame&gt;</code> 标签所表述的元素。</p>
<ul>
<li><p>每个框架都类似于一个浏览窗口，因此每个框架都有自己的 window 对象。</p>
</li>
<li><p>框架的 window 对象会保存在父框架或父窗口的 <code>window.frames</code> 中。</p>
</li>
<li><p>一般情况下框架的 window 对象都会有一个 name 属性。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;top.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;topFrame&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;bottom-left.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;bottomLeftFrame&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;bottom-right.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;bottomRightFrame&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于当前的 window 而言，<code>window.frames</code> 将会包含3个 window 对象，分别是框架 <code>topFrame</code>、<code>bottomLeftFrame</code> 和 <code>bottomRightFrame</code> 的 window 对象。</p>
<p>可以通过 <code>window.frames[1]</code> 或者 <code>window.frames[&#39;bottomLeftFrame&#39;]</code> 来访问指定的框架 window 对象。</p>
<h4 id="1-2-1-top"><a href="#1-2-1-top" class="headerlink" title="1.2.1 top"></a>1.2.1 top</h4><p>top（window.top）对象始终指向最高（最外）层的框架，也就是浏览器窗口。</p>
<h4 id="1-2-2-parent"><a href="#1-2-2-parent" class="headerlink" title="1.2.2 parent"></a>1.2.2 parent</h4><p>parent（window.parent）对象指的是当前框架的直接上层框架（父框架）。</p>
<p>在没有框架的情况下，<code>parent === top</code>。</p>
<p>加入上述代码中的 top.html 文件如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;topInnerLeft.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;topInnerLeftFrame&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;topInnerRight.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;topInnerRightFrame&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么对于框架 topInnerLeftFrame 的 window 对象而言，它的 <code>window.parent</code> 指的就是框架 topFrame 的 window 对象。</p>
<h4 id="1-2-3-self"><a href="#1-2-3-self" class="headerlink" title="1.2.3 self"></a>1.2.3 self</h4><p>self（window.self）指的是 window 对象本身。</p>
<p>引入 self 只是为了和 top、parent 对应，貌似没什么特别作用。</p>
<h3 id="1-3-窗口位置"><a href="#1-3-窗口位置" class="headerlink" title="1.3 窗口位置"></a>1.3 窗口位置</h3><p>窗口位置指的是浏览器窗口在屏幕上的位置信息。不同浏览器提供的位置属性不一样。</p>
<p>IE、Safari、Opera 和 Chrome 都提供 <code>screenLeft</code> 和 <code>screenRight</code>，分用于表示窗口相对于屏幕的左边和上边的位置。</p>
<p>FireFox、Safari、Chrome 提供 <code>screenX</code> 和 <code>screenY</code> ，对应相同的位置信息。</p>
<p>跨浏览器获取浏览器窗口的位置信息，可以用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">&#x27;number&#x27;</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">&#x27;number&#x27;</span>) ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure>

<p>移动窗口位置，可以使用 <code>moveTo</code> 和 <code>moveBy</code> 方法，<code>moveTo</code> 是移动到指定的位置， <code>moveBy</code> 是移动的方向距离。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将窗口移动到(100, 200)</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将窗口向右移动100，向下移动200</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>不过这两个方法有可能被浏览器禁用，因此最好不要使用。</p>
<h3 id="1-4-窗口大小"><a href="#1-4-窗口大小" class="headerlink" title="1.4 窗口大小"></a>1.4 窗口大小</h3><p>IE9+、Firefox、Safari、Opera 和 Chrome 提供了4个属性来获取窗口的大小：<code>innerWidth</code>、<code>innerHeight</code>、<code>outerWidth</code>、<code>outerHeight</code>，不过不同浏览器返回的值不太相同。有些是返回浏览器窗口本身的大小，有些是返回视口（viewport）的大小。</p>
<p>获取视口大小的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">window</span>.innerHeight</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">&#x27;CSS1Compat&#x27;</span>) &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.body.clientWidth</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>resizeTo</code> 和 <code>resizeBy</code> 可以改变浏览器窗口的大小。<code>resizeTo</code> 是指定改变后浏览器窗口的大小，<code>resizeBy</code> 是指定改变窗口的宽高差值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将窗口大小改变为(100, 200)</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将窗口宽度减少100，高度减少200</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>不过这两个方法也有可能被浏览器禁用，因此也是最好不要使用。</p>
<h3 id="1-5-导航和打开窗口"><a href="#1-5-导航和打开窗口" class="headerlink" title="1.5 导航和打开窗口"></a>1.5 导航和打开窗口</h3><p><code>window.open()</code> 方法可以导航到特定的 URL，也可以打开一个新的浏览器窗口。</p>
<p>接收的参数可以有4个：</p>
<ul>
<li>URL：要加载的URL</li>
<li>窗口目标：指定打开窗口的位置，是在当前窗口打开，还是新窗口打开</li>
<li>特性字符串：指定打开窗口的相关信息，例如窗口的高度、宽度等</li>
<li>标志位：用于标识新页面是否设置为浏览器历史记录中的当前加载页面</li>
</ul>
<p>第二个参数的可选值有：</p>
<ul>
<li>_self：当前框架或窗口打开</li>
<li>_parent：父框架或父窗口打开</li>
<li>_top：当前浏览器窗口打开</li>
<li>_blank：新的浏览器窗口打开</li>
<li>frameName：指定的框架打开，不存在该框架时，新窗口打开</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于&lt;a href=&quot;http://ww.baidu.com&quot;, target=&quot;topFrame&quot;&gt;</span></span><br><span class="line"><span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;topFrame&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码会在 topFrame 框架中加载新页面，如果框架不存在，则会新窗口打开。</p>
<h4 id="1-5-1-窗口引用"><a href="#1-5-1-窗口引用" class="headerlink" title="1.5.1 窗口引用"></a>1.5.1 窗口引用</h4><p><code>window.open()</code> 方法会返回一个指向新窗口的引用，该引用和 window 对象差不多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;topFrame&#x27;</span>)</span><br><span class="line">newWin.moveTo(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">newWin.resizeTo(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line">newWin.close()</span><br></pre></td></tr></table></figure>

<p>同时，新打开窗口也拥有一个属性 opener 指向创建它的原始窗口对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;topFrame&#x27;</span>)</span><br><span class="line">alert(newWin.opener == <span class="built_in">window</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-窗口屏蔽"><a href="#1-5-2-窗口屏蔽" class="headerlink" title="1.5.2 窗口屏蔽"></a>1.5.2 窗口屏蔽</h4><p>大多数浏览器有内置的弹出窗口屏蔽程序，因此 <code>window.open()</code> 有可能返回 null。因此使用 <code>window.open()</code> 时，最好封装在一个 <code>try-catch</code> 块中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (newWin == <span class="literal">null</span>) &#123;</span><br><span class="line">      blocked = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  blocked = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;open window was blocked&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-location"><a href="#1-6-location" class="headerlink" title="1.6 location"></a>1.6 location</h3><p>location（window.location）对象提供了当前窗口中加载的文档的有关信息，还有导航功能。</p>
<p>另外，在 window 和 document 中，有 <code>window.location == document.location</code>。</p>
<p>location 对象中包含的属性有：</p>
<ul>
<li>href：当前加载页面的完整 URL，如 <a href="http://www.baidu.com/">http://www.baidu.com</a></li>
<li>procotol：页面使用的协议，如 http:、https:</li>
<li>host：服务器名称以及端口，如 <a href="http://www.baidu.com/">www.baidu.com:80</a></li>
<li>hostname：服务器名称，不包括端口，如 <a href="http://www.baidu.com/">www.baidu.com</a></li>
<li>port：端口号，如 80</li>
<li>pathname：URL 路径，如 /uers/info</li>
<li>search：URL 查询字符串，如 ?age=12&amp;&amp;city=guangzhou</li>
<li>hash：URL 中的散列值，如 #content</li>
</ul>
<h4 id="1-6-1-位置操作"><a href="#1-6-1-位置操作" class="headerlink" title="1.6.1 位置操作"></a>1.6.1 位置操作</h4><p>直接改变 location 代表的值，就可以直接打开新的 URL：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这几种方式效果是一样的</span></span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">location.href = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">location.assign(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>也可以单独修改 location 里面的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://www.baidu.com:80/users/</span></span><br><span class="line"><span class="built_in">window</span>.location</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.baidu.com:80/users/#content</span></span><br><span class="line">location.hash = <span class="string">&#x27;#content&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.baidu.com:80/another/</span></span><br><span class="line">location.pathname = <span class="string">&#x27;another&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.baidu.com:8080/users/</span></span><br><span class="line">location.port = <span class="string">&#x27;8080&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用上述的修改方式，会在浏览器的历史记录中生成一条新的记录，因此用户通过单击“后退”按钮后可以返回到上一个页面。</p>
<h4 id="1-6-2-相关方法"><a href="#1-6-2-相关方法" class="headerlink" title="1.6.2 相关方法"></a>1.6.2 相关方法</h4><p>使用 <code>location.repalce()</code> 方法可以禁用这种行为，它会导航到一个新的页面，但是不会在浏览器历史记录中生成新的记录。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不会生成新的历史记录，因此跳转后无法回到前一个页面</span></span><br><span class="line">location.replace(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用 <code>location.reload()</code> 方法可以重新加载当前显示的页面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有可能从缓存中加载</span></span><br><span class="line">location.reload()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制从服务器加载</span></span><br><span class="line">location.reload(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-7-navigator"><a href="#1-7-navigator" class="headerlink" title="1.7 navigator"></a>1.7 navigator</h3><p>navigator（window.navigator） 对象用于识别客户端浏览器的类型等信息。</p>
<p>主要实现属性包括（还有很多属性没列出来）：</p>
<ul>
<li>appCodeName：浏览器名称</li>
<li>appName：完整的浏览器名称</li>
<li>appVersion：浏览器的版本</li>
<li>cookieEnabled：表示 cookie 是否启用</li>
<li>mimeTypes：在浏览器中注册的MIME类型数组</li>
<li>platform：浏览器所在的系统平台</li>
<li>plugins：浏览器安装的插件</li>
<li>userAgent：浏览器的用户代理字符串</li>
</ul>
<p>navigator 对象主要提供来比较多来`客户端浏览器的相关信息，不同的浏览器实现还不一样。</p>
<h3 id="1-8-screen"><a href="#1-8-screen" class="headerlink" title="1.8 screen"></a>1.8 screen</h3><p>screen（window.screen）对象用来表明客户端的一些属性，包括浏览器窗口外部的显示器的信息，例如像素宽度和高度。</p>
<p>其中包含的属性有：</p>
<ul>
<li>height：屏幕的像素高度</li>
<li>width：·屏幕的像素宽度</li>
<li>left：当前屏幕距左边的像素距离</li>
<li>top：当前屏幕距上边的像素距离</li>
<li>colorDepth：用于表示颜色的位数</li>
</ul>
<p>screen 对象不常用，而且在涉及移动设备时，使用前还需要进行相应的调整。</p>
<h3 id="1-9-history"><a href="#1-9-history" class="headerlink" title="1.9 history"></a>1.9 history</h3><p>history（window.history）对象用于保存用户上网的历史记录，从打开窗口的那一刻算起。</p>
<p>history 是 window 的属性，因此不同的浏览器窗口、标签页、框架等都有自己的 history 对象。</p>
<p>出于安全考虑，history 对象不能看到用户浏览过的 URL，只能指导历史记录条数等一些信息。</p>
<p>使用 <code>go()</code> 方法可以在历史记录中进行任意的跳转，可以向前或者向后。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.go(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进两页</span></span><br><span class="line">history.go(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><code>go()</code> 还可以使用字符串，表示跳转到包含该字符串的记录，因此有可能是前进，也可能是后退：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳到最近的 baidu.com 页面</span></span><br><span class="line">history.go(<span class="string">&#x27;baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用简写的 <code>forward()</code> 和 <code>back()</code> 可以用来替代 <code>go(1)</code> 和 <code>go(-1)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.back()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML中的DOM对象</title>
    <url>/lang/js/dom/</url>
    <content><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM（文档对象模型）是针对 HTML 和 XML 文档的一个API。</p>
<ul>
<li>主流浏览器都完成了 DOM1 级的实现</li>
<li>IE 的 DOM 对象都是以 COM 对象的形式存在，和原始的 DOM 对象行为并不一致</li>
</ul>
<h2 id="一、节点层次"><a href="#一、节点层次" class="headerlink" title="一、节点层次"></a>一、节点层次</h2><p>DOM 可以将 HTML 或 XML 文档描绘成一个由多层节点构成的结构，简单点说，就是一个树结构。</p>
<span id="more"></span>

<h3 id="1-1-文档节点"><a href="#1-1-文档节点" class="headerlink" title="1.1 文档节点"></a>1.1 文档节点</h3><p>文档节点是每个文档的根节点。</p>
<p>文档节点不直接表现在文档定义中，是一个内置的节点。</p>
<h3 id="1-2-文档元素"><a href="#1-2-文档元素" class="headerlink" title="1.2 文档元素"></a>1.2 文档元素</h3><p>文档元素是文档的最外层元素，文档中的所有其他元素都包含在文档元素中。</p>
<p>每个文档只能有一个文档元素。</p>
<p>在 HTML 页面中，文档元素始终是 <code>&lt;html&gt;</code> 元素。</p>
<h3 id="1-3-节点结构"><a href="#1-3-节点结构" class="headerlink" title="1.3 节点结构"></a>1.3 节点结构</h3><p>以 HTML 文档为例，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- Document</span><br><span class="line">    |-- html</span><br><span class="line">        |-- head</span><br><span class="line">            |-- title</span><br><span class="line">        |-- body</span><br><span class="line">            |-- p</span><br><span class="line">            |-- div</span><br></pre></td></tr></table></figure>

<p>其中，<code>Document</code> 是文档节点，它在 HTML 文档中是没有定义的；<code>html</code> 是文档元素，所有其他的元素都在它里面。</p>
<h2 id="二、节点类型"><a href="#二、节点类型" class="headerlink" title="二、节点类型"></a>二、节点类型</h2><h3 id="2-1-Node-类型"><a href="#2-1-Node-类型" class="headerlink" title="2.1 Node 类型"></a>2.1 Node 类型</h3><p>Node 在 DOM1级定义中，是一个接口，由 DOM 中的所有节点类型实现。</p>
<p>在 JavaScript 中，Node 接口是作为 Node 类型实现的。</p>
<ul>
<li>JavaScript 中的所有节点类型都继承自 Node 类型</li>
<li>每个节点都有一个 nodeType 属性，用于表明节点的类型</li>
<li>除 IE 外，其他浏览器均可以访问 Node 类型（IE 没有公开它的 Node 类型的构造函数）</li>
</ul>
<h4 id="2-1-1-公共属性"><a href="#2-1-1-公共属性" class="headerlink" title="2.1.1 公共属性"></a>2.1.1 公共属性</h4><p><strong>(1) nodeType</strong></p>
<p>每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型总共有12种（括号内的是它的常量值）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Node.ELEMENT_NODE(1)</span><br><span class="line">- Node.ATTRIBUTE_NODE(2)</span><br><span class="line">- Node.TEXT_NODE(3)</span><br><span class="line">- Node.CDATA_SECTION_NODE(4)</span><br><span class="line">- Node.ENTITY_REFERENCE_NODE(5)</span><br><span class="line">- Node.ENTITY_NODE(6)</span><br><span class="line">- Node.PROCESSING_INSTRUCTION_NODE(7)</span><br><span class="line">- Node.COMMENT_NODE(8)</span><br><span class="line">- Node.DOCUMENT_NODE(9)</span><br><span class="line">- Node.DOCUMENT_TYPE_NODE(10)</span><br><span class="line">- Node.DOCUMENT_FRAGMENT_NODE(11)</span><br><span class="line">- Node.NOTATION_NODE(12)</span><br></pre></td></tr></table></figure>

<p>需要说明的是，并不是所有 Web 浏览器都支持全部的节点类型。</p>
<p>由于 IE 无法访问 Node 类型，因此在判断节点类型时，为了确保浏览器兼容性，最好将 nodeType 与数值作比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IE 下无效</span></span><br><span class="line"><span class="keyword">if</span> (node.nodeType === Node.ELEMENT_NODE) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于所有浏览器</span></span><br><span class="line"><span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2) nodeName 和 nodeValue</strong></p>
<p>这两个值取决于节点的类型，有可能取值为 null。</p>
<p>在 <code>Node.ELEMENT_NODE</code> 元素类型中，nodeName 始终保存的是元素的标签名，而 nodeValue 的值则始终是 null。</p>
<p><strong>(3) childNodes</strong></p>
<p>每个节点都有一个 childNodes 属性，用于保存它的子节点。</p>
<p>childNodes 是一个 NodeList 对象，是一种类数组对象（不是数组），其中保存着一组有序的节点。</p>
<p>NodeList 对象是一个动态查询的结果，也就是说，当 DOM 结构发生变化时，它能够实时更新数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 NodeList 对象的长度</span></span><br><span class="line"><span class="keyword">var</span> length = node.childNodes.length</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类似数组的[]下标访问</span></span><br><span class="line"><span class="keyword">var</span> firstChild = node.childNodes[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 item() 方法访问</span></span><br><span class="line"><span class="keyword">var</span> lastChild = node.childNodes.item(length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>需要说明的是，虽然所有节点都继承自 Node 类型，但并不是每种节点都有子节点。</p>
<p><strong>(4) 其他属性</strong></p>
<ul>
<li>parentNode：父节点</li>
<li>previousSibling：同级节点的前一个节点</li>
<li>nextSibling：同级节点的下一个节点</li>
<li>firstChild：第一个子节点</li>
<li>lastChild：最后一个子节点</li>
<li>ownerDocument：节点所在的文档</li>
</ul>
<h4 id="2-1-2-公共方法"><a href="#2-1-2-公共方法" class="headerlink" title="2.1.2 公共方法"></a>2.1.2 公共方法</h4><p><strong>(1) appendChild</strong></p>
<p><code>appendChild()</code> 方法用于向 childNodes 列表末尾追加一个节点。</p>
<p>如果追加的节点已经在 childNodes 中，则会将该节点移动到 childNodes 列表的末尾。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 追加到末尾</span></span><br><span class="line"><span class="keyword">var</span> newNode = parentNode.appendChild(newChildNode)</span><br><span class="line">alert(newNode === parentNode.lastChild)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动到末尾</span></span><br><span class="line"><span class="keyword">var</span> firstChild = parentNode.firstChild</span><br><span class="line"><span class="keyword">var</span> moveNode = parentNode.appendChild(firstChild)</span><br><span class="line">alert(moveNode === parentNode.lastChild)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>(2) insertBefore</strong></p>
<p><code>insertBefore()</code> 方法用于在 childNodes 列表的某个位置中插入一个节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入到末尾</span></span><br><span class="line"><span class="keyword">var</span> newNode = parentNode.insertBefore(newChildNode, <span class="literal">null</span>)</span><br><span class="line">alert(newNode === parentNode.lastChild)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入后成为第一个节点</span></span><br><span class="line"><span class="keyword">var</span> insertNode = parentNode.insertBefore(newChildNode, parentNode.firstChild)</span><br><span class="line">alert(insertNode === parentNode.firstChild)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>(3) replaceChild</strong></p>
<p><code>replaceChild()</code> 方法用于将旧节点替换成新节点，实际上是做了一个删除节点操作和插入节点操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换指定的子节点</span></span><br><span class="line"><span class="keyword">var</span> replaceNode = parentNode.replaceChild(newChildNode, parentNode.firstChild)</span><br><span class="line">alert(replaceNode === parentNode.firstChild)</span><br></pre></td></tr></table></figure>

<p><strong>(4) removeChild</strong></p>
<p><code>removeChild()</code> 方法用于移除子节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> removeNode = parentNode.removeChild(parentNode.firstChild)</span><br></pre></td></tr></table></figure>

<p><strong>(5) 其他方法</strong></p>
<ul>
<li>cloneNode：用于创建调用节点的副本，<code>cloneNode(true)</code> 为深复制，<code>cloneNode(false)</code> 为浅复制。</li>
<li>normalize：用于处理后代的文本节点，后代中如果存在空的文本节点，则删除它；如果出现相邻的文本节点，则合并它们。</li>
</ul>
<h3 id="2-2-Document-类型"><a href="#2-2-Document-类型" class="headerlink" title="2.2 Document 类型"></a>2.2 Document 类型</h3><p>Document 类型用于表示文档，可以是 HTML 页面或者基于 XML 的文档。</p>
<ul>
<li>在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面</li>
<li>document 对象是 window 对象的一个属性，可作全局对象访问</li>
</ul>
<p>具有的特征包括：</p>
<ul>
<li>nodeName 的值为 <code>#document</code></li>
<li>nodeValue 的值为 <code>null</code></li>
<li>parentNode 的值为 <code>null</code></li>
<li>ownerDocument 的值为 <code>null</code></li>
</ul>
<p><strong>(1) 文档子节点</strong></p>
<p>DOM 标准规定 Documnet 节点的子节点可以是：</p>
<ul>
<li>DocumentType（最多一个）</li>
<li>Element（最多一个）</li>
<li>ProcessingInstruction</li>
<li>Comment</li>
</ul>
<p>document 对象拥有两个内置的访问其子节点的快捷方式，一个是 <code>documentElement</code>，另一个是 <code>body</code>。</p>
<ul>
<li><code>document.documentElement</code> 可以直接访问文档的 <code>&lt;html&gt;</code> 元素（因为文档最多只会有一个 Element 元素）</li>
<li>作为 HTMLDocument 的实例，<code>document.body</code> 还可以直接访问文档的 <code>&lt;body&gt;</code> 元素</li>
</ul>
<p>其他子节点属性：</p>
<ul>
<li>DocumentType：<code>document.doctype</code> 用来表示文档类型子节点，但是由于浏览器对 <code>document.doctype</code> 的支持不一致，因此这个属性的用处不大</li>
<li>Comment：理论上出现在 <code>&lt;html&gt;</code> 外面的注释，都属于 document 的子节点，但是不同浏览器对于这种注释的处理也存在差异，因此文档注释的意义也不大</li>
</ul>
<p><strong>(2) 文档信息</strong></p>
<ul>
<li>title：<code>document.title</code> 表示文档标题元素 <code>&lt;title&gt;</code> ，修改 <code>document.title</code> 的值会直接改变 <code>&lt;title&gt;</code> 元素。</li>
<li>URL：<code>document.URL</code> 表示当前页面的完整 URL（即地址栏显示的 URL）</li>
<li>domain：<code>document.domain</code> 表示页面的域名，与 URL 相关联</li>
<li>referer：<code>document.refreer</code> 表示来源页面的 URL（即跳转到当前页面的上一个页面 URL）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改页面标题</span></span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">&#x27;新标题&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.baidu.com/</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL</span><br><span class="line"></span><br><span class="line"><span class="comment">// www.baidu.com</span></span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">document</span>.domain</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.google.com/</span></span><br><span class="line"><span class="keyword">var</span> referer = <span class="built_in">document</span>.refreer</span><br></pre></td></tr></table></figure>

<p>在 URL、domain、referer 中，只有 domain 可以修改，其他两个都是只读属性。</p>
<ul>
<li>domain 只能设置成 URL 的子域名，不能修改为 URL 中不包含的域</li>
<li>修改为子域名之后，不能再修改回原域名（即修改只能收缩，不能扩张）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://www.baidu.com/</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL</span><br><span class="line"></span><br><span class="line"><span class="comment">// www.baidu.com</span></span><br><span class="line"><span class="keyword">var</span> domain  = <span class="built_in">document</span>.domain</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以从父域名修改为子域名</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;baidu.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以修改为 URL 不包含的域名</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;google.com&#x27;</span> <span class="comment">// 出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改为子域名以后，不可以再修改回原域名</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;www.baidu.com&#x27;</span> <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>

<p>domain 的限制来源于跨域安全：<strong>来自不同子域的页面不能通过 Javascript 通信</strong>。也就是说，如果一个页面包含了一个内嵌框架，而且内嵌框架的域名和页面的域名不同，那它们之间就不能互相访问对方的 Javascript 对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 假设当前页面来自 http://wwww.baidu.com/outer.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;http://www.google.com/inner.html&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;innerFrame&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 由于页面和内置框架不同域名，因此会受到跨域安全的限制</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 导致在这里无法正常访问内嵌框架的 Javascript 对象</span></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要通过 Javascript 实现跨域访问，可以使用 <code>window.postMessage() </code> 方法。</p>
<p><strong>(3) 特征检测</strong></p>
<p>由于 DOM 分为多个级别，也包含多个部分，因此在使用某些特征功能之前，需要检测一下浏览器是否实现来该功能。</p>
<p><code>document.implemetation</code> 属性提供了浏览器实现的相应信息和功能，其中 DOM1 级规定了一个方法 <code>hasFeature()</code> 用于检测 DOM 功能以及版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasXmlDom = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">&#x27;XML&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>hasFeature()</code> 方法判断可能存在错误，因为功能是由浏览器负责实现的，但它未必完全按照 DOM 规范来实现，因此即使是在 <code>hasFeature()</code> 返回 true情况下，也未必能正确使用该功能，所以除了使用 <code>hasFeature()</code> 以外，应该还要加上能力检测。</p>
<p><strong>(4) 查找元素</strong></p>
<p>Document 类型查找元素的方法有，搜索的范围是整个文档：</p>
<ul>
<li>getElementById：通过元素的 ID 获取，区分大小写。如果文档中有多个相同 ID 的元素，则返回第一次出现的元素</li>
<li>getElementsByTagName：通过元素的标签名获取，返回的是包含0个或多个元素的 NodeList</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照 ID 获取</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;divId&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照标签获取</span></span><br><span class="line"><span class="keyword">var</span> images = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有元素</span></span><br><span class="line"><span class="keyword">var</span> allElements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>另外，<strong>对于 HTMLDocument 类型而言</strong>，还有另外的方法：</p>
<ul>
<li>getElementsByName：通过元素的name特性获取，返回的是包含0个或多个元素的 NodeList</li>
</ul>
<p><code>getElementsByName()</code> 方法常用在获取同一组单选按钮的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照name属性获取</span></span><br><span class="line"><span class="keyword">var</span> radios = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;radioName&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>另外，文档为常用的元素提供了快捷方式，可以免去我们自己查找：</p>
<ul>
<li><code>document.anchors</code>：文档中所有带有 name 特性的 <code>&lt;a&gt;</code> 元素</li>
<li><code>document.links</code>：文档中所有带有 href 特性的 <code>&lt;a&gt;</code> 元素</li>
<li><code>document.applets</code>：文档中所有的 <code>&lt;applet&gt;</code> 元素（不建议使用）</li>
<li><code>document.forms</code>：文档中所有的 <code>&lt;form&gt;</code> 元素</li>
<li><code>document.images</code>：文档中所有的 <code>&lt;img&gt;</code> 元素</li>
</ul>
<p><strong>(5) 文档写入</strong></p>
<p>document 对象可以直接将输出流写入网页中，主要的方法有几个：</p>
<ul>
<li>write：写入字符串</li>
<li>writeln：写入字符串，并在末尾添加一个换行符（<code>\n</code>）</li>
<li>open：打开输出流</li>
<li>close：关闭输出流</li>
</ul>
<p>需要注意的是，在<strong>文档加载期间</strong>使用 <code>write()</code> 和 <code>writeln()</code> 是不需要使用 <code>open()</code> 和 <code>close()</code> 方法的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 处于文档加载期间，不需要使用 open() 和 close() 方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">&#x27;Hello world!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;btnClick()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">btnClick</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 文档加载完毕，需要使用 open() 和 close() 方法</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.open();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">&#x27;Hello world!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.close();</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-Element-类型"><a href="#2-3-Element-类型" class="headerlink" title="2.3 Element 类型"></a>2.3 Element 类型</h3><p>元素 Element 类型用于表示 XML 或 HTML 元素，具有的特征包括：</p>
<ul>
<li>nodeType 的值为 1</li>
<li>nodeName 的值为元素的标签名</li>
<li>nodeValue 的值为 null</li>
<li>parentNode 可能是 Document 或 Element</li>
</ul>
<p>访问元素的标签名可以使用 nodeName 或 tagName，在 Element 类型中这两个是相等的。</p>
<ul>
<li>在 HTMl 中，标签名始终是全部大写表示</li>
<li>在 XML 中，标签名则始终和源代码中保持一致</li>
</ul>
<p>因此在判断标签名时，最好转换一下大小写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.tagName.toUpperCase() === <span class="string">&#x27;DIV&#x27;</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(1) HTML 元素</strong></p>
<p>所有 HTML 元素都由 HTMLElement 类型表示，而 HTMLElement 继承自 Element，并添加了一些属性：</p>
<ul>
<li>id：元素的唯一标识符</li>
<li>title：元素的附加说明信息，一般用于工具提示条显示</li>
<li>lang：元素内容的语言代码，少用</li>
<li>dir：语言的方向，少用</li>
<li>className：元素的 class 特征，即元素的 CSS 类（class 是 ECMAScript 保留字，所以用 className 表示）</li>
</ul>
<p><strong>(2) 元素特性</strong></p>
<p>特性是用于给出元素及其内容的附加信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id、class、title、align、data-custom-attr 等称为元素特性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my-cls&quot;</span> <span class="attr">title</span>=<span class="string">&quot;my-title&quot;</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span> <span class="attr">data-custom-attr</span>=<span class="string">&quot;custom attribution&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>操作特性的 DOM 方法有几个：</p>
<ul>
<li>getAttribute：获取特性</li>
<li>setAttribute：设置特性</li>
<li>removeAttribute：删除特性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置特性</span></span><br><span class="line">myDiv.setAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;new_id&#x27;</span>)</span><br><span class="line">myDiv.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;new-my-cls&#x27;</span>)</span><br><span class="line">myDiv.setAttribute(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;New title&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取特性</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;id&#x27;</span>))    <span class="comment">// &quot;new_id&quot;</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;class&#x27;</span>)) <span class="comment">// &quot;new-my-cls&quot;</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;title&#x27;</span>)) <span class="comment">// &quot;New title&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除特性</span></span><br><span class="line">myDiv.removeAttribute(<span class="string">&#x27;class&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>(3) 元素属性</strong></p>
<p>通过元素属性还可以访问元素特性，元素特性与元素属性的关系如下：</p>
<ul>
<li>元素的特性可以通过 DOM 元素对象的属性访问</li>
<li>只有公认的（非自定义的）特性才会以属性的形式添加到 DOM 对象中（如 id、title 等）</li>
<li>通过属性获取得到的特性是经过解析的，是一个对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// element.id、element.className、element.title 等称为元素属性</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line">alert(myDiv.id)                  <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line">alert(myDiv.className)           <span class="comment">// &quot;my-cls&quot;（class 是保留字的原因）</span></span><br><span class="line">alert(myDiv.title)               <span class="comment">// &quot;my-title&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义特性不会以属性的形式直接显示</span></span><br><span class="line">alert(myDiv[<span class="string">&#x27;data-custom-attr&#x27;</span>])              <span class="comment">// undefined（IE除外）</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;data-custom-attr&#x27;</span>)) <span class="comment">// &quot;custom attribution&quot;</span></span><br></pre></td></tr></table></figure>

<p>有两类特性，它们虽然有对应属性名，但是属性值和通过 <code>getAttribute()</code> 拿到的特性值不同，<strong>属性值是经过解析的对象，而特性值是未经解析的字符串</strong>。这两类特性分别是样式 style，事件处理程序（onclick 等）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:100px;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会直接得到原始的字符串</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;style&#x27;</span>))   <span class="comment">// &quot;height:100px;&quot;</span></span><br><span class="line">alert(myDiv.getAttribute(<span class="string">&#x27;onclick&#x27;</span>)) <span class="comment">// &quot;btnClick&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会得到解析过的对象/方法</span></span><br><span class="line">alert(myDiv.style)   <span class="comment">// object</span></span><br><span class="line">alert(myDiv.onclick) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>另外，Element 类型还有一个属性 <code>attributes</code> 用于保存元素所有的元素特性。<code>element.attributes</code> 属性包含一个 NamedNodeMap，是一个“动态”的集合，能够动态实时获取元素的所有特征。</p>
<p><strong>(4) 创建元素</strong></p>
<p>使用 <code>document.createElement()</code> 可以创建新元素，创建的同时，也为新元素设置了 <code>ownerDocument</code> 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var newDiv = document.createElement(&#x27;div&#x27;)</span><br><span class="line"></span><br><span class="line">// 新元素需要添加到文档树中，才会在页面上显示</span><br><span class="line">document.body.appendChild(newDiv)</span><br></pre></td></tr></table></figure>

<p><strong>(5) 查找元素</strong></p>
<p>元素支持 <code>getElementsByTagName()</code> 方法，搜索起点为当前元素，范围是当前元素的子元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找指定元素下面的图片</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> images = myDiv.getElementsByTagName(<span class="string">&#x27;img&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Text-类型"><a href="#2-4-Text-类型" class="headerlink" title="2.4 Text 类型"></a>2.4 Text 类型</h3><p>文本节点由 Text 类型表示，包含的是纯文本内容，不能包含 HTML 代码，具有的特征：</p>
<ul>
<li>nodeType 的值为 3</li>
<li>nodeName 的值为 “#text”</li>
<li>nodeValue 的值为节点所包含的文本</li>
<li>parentNode 是一个 Element</li>
<li>不支持（没有）子节点</li>
</ul>
<p>文本节点的文本可以通过 nodeValue 或 data 属性获取，它们是相同的。</p>
<ul>
<li>默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在</li>
<li>修改文本时，字符串会经过 HTML （或 XML）编码（例如大于号、小于号等被转义成其他字符串）</li>
<li>如果两个文本节点是相邻的同胞节点，那它们的文本就会连起来显示，并且不会存在任何空格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示结果是 &quot;&amp;lt;p&amp;gt;New text content&amp;lt;/p&amp;gt;&quot;</span></span><br><span class="line">textNode.nodeValue = <span class="string">&quot;&lt;p&gt;New text content&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>(1) 创建文本节点</strong></p>
<p>创建文本节点使用 <code>document.createTextNode()</code> 方法，方法接收文本作为参数，创建节点的同时，也会设置节点的 <code>ownerDocument</code> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，和设值一样，创建时的参数文本也会经过 HTML （或 XML）编码。</p>
<p>默认情况下，元素只有一个文本节点，但是通过 Javascript 可以为元素创建多个文本子节点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newTextNode1 = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> newTextNode2 = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27; world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">myDiv.appendChild(newTextNode1)</span><br><span class="line">myDiv.appendChild(newTextNode2)</span><br></pre></td></tr></table></figure>

<p><strong>(2) 规范化文本</strong></p>
<p>前面说过，如果两个节点是相邻的同胞节点，它们的文本会连起来显示，但是这样会导致分不清哪个字符串是哪个文本节点的，因此为了合并相邻的同胞文本节点，DOM 提供了一个方法 <code>normalize()</code>，用于合并相邻的文本节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newTextNode1 = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> newTextNode2 = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27; world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">myDiv.appendChild(newTextNode1)</span><br><span class="line">myDiv.appendChild(newTextNode2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并同胞文本节点</span></span><br><span class="line">myDiv.normalize()</span><br></pre></td></tr></table></figure>

<p><strong>(3) 分割文本</strong></p>
<p>Text类型除了可以合并以外，还可以进行分割：<code>splitText()</code>。这个方法会将1个文本节点分割成2个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello world!&#x27;</span>)</span><br><span class="line">myDiv.appendChild(newTextNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> splitNode = myDiv.firstChild.splitText(<span class="number">5</span>)</span><br><span class="line">alert(myDiv.firstChild.nodeValue) <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">alert(splitNode.nodeValue)        <span class="comment">// &quot; world!&quot;</span></span><br><span class="line">alert(myDiv.childNodes.length)    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-Comment-类型"><a href="#2-5-Comment-类型" class="headerlink" title="2.5 Comment 类型"></a>2.5 Comment 类型</h3><p>Comment 类型用于表示注释，与 Text 类型类似，具有特征如下：</p>
<ul>
<li>nodeType 的值为 8</li>
<li>nodeName 的值为 “#comment”</li>
<li>nodeValue 的值是注释的内容</li>
<li>不支持（没有）子节点</li>
</ul>
<p>Comment 类型和 Text 类型继承自相同的基类，因此拥有除了 <code>splitText()</code> 方法以外的所有字符串操作方法。</p>
<p>创建注释节点可以通过使用 <code>document.createComment()</code>，参数是注释内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">&#x27;new comment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-6-CDATASection-类型"><a href="#2-6-CDATASection-类型" class="headerlink" title="2.6 CDATASection 类型"></a>2.6 CDATASection 类型</h3><p>CDATASection 类型只针对基于 XML 的文档，表示的是 CDATA 区域。具有的特征如下：</p>
<ul>
<li>nodeType 的值为4</li>
<li>nodeName 的值为 “#cdata-section”</li>
<li>nodeValue 的值是 CDATA 区域的内容</li>
<li>不支持（没有）子节点</li>
</ul>
<p>与 Comment 类型类似，CDATASection 类型继承自 Text 类型，因此拥有除了 <code>splitText()</code> 方法以外的所有字符串操作方法。</p>
<p>CDATA 区域只会出现在 XML 文档中，因此浏览器一般会把 CDATA 区域错误解析为 Comment 或 Element。</p>
<p>在 XML 文档中创建 CDATA 区域，可以使用 <code>document.createCDATASection()</code> 方法，参数是区域的内容。</p>
<h3 id="2-7-DocumentType-类型"><a href="#2-7-DocumentType-类型" class="headerlink" title="2.7 DocumentType 类型"></a>2.7 DocumentType 类型</h3><p>DocumentType 类型包含着与文档的 doctype 有关的所有信息。具有的特征包括：</p>
<ul>
<li>nodeType 的值为 10</li>
<li>nodeName 的值为 doctype 的名称</li>
<li>nodeValue 的值为 null</li>
<li>parentNode 为 Document</li>
<li>不支持（没有）子节点</li>
</ul>
<p>在 DOM1 级中，DocumentType 对象不能动态创建，只能通过文档解析的方式创建。支持 DocumentType 的浏览器会将生成的 DoocumentType 对象保存在 <code>document.doctype</code> 中。</p>
<h3 id="2-8-DocumentFragment-类型"><a href="#2-8-DocumentFragment-类型" class="headerlink" title="2.8 DocumentFragment 类型"></a>2.8 DocumentFragment 类型</h3><p>DocumentFragment 类型表示文档片段，是一种“轻量级”的文档，可以包含和控制部分节点，但是不像完整文档那样占用额外的资源。在所有的节点类型中，只有 DocumentFragment 类型在文档中没有对应的标记。具有的特征包括：</p>
<ul>
<li>nodeType 的值为 11</li>
<li>nodeName 的值为 “#document-fragment”</li>
<li>nodeValue 的值为 null</li>
<li>parentNode 的值为 null</li>
</ul>
<p>文档片段不能直接添加到文档中，但是可以把文档片段中的节点添加到文档中。因此文档片段相当于一个节点临时仓库，可以将临时生成的节点保存在文档片段中，最后再将生成的节点都添加到文档中。</p>
<p>创建文档片段可以使用 <code>document.createDocumentFragment()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br></pre></td></tr></table></figure>

<ul>
<li>如果将文档中的节点添加到文档片段中，该节点就会从文档树中移除（也就是浏览器看不到了）</li>
<li>将文档片段的子节点添加到文档中，节点会从文档片段中移除，但是文档片段不会添加到文档树上</li>
<li>文档片段有类似于缓存的作用，可以用于避免浏览器反复渲染新信息</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul <span class="built_in">document</span>.createElement(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以暂时保存到文档片段中，避免浏览器多次渲染新节点</span></span><br><span class="line"><span class="keyword">var</span> li = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">  fragment.appendChild(li)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul.appendChild(fragment)</span><br></pre></td></tr></table></figure>

<h3 id="2-9-Attr-类型"><a href="#2-9-Attr-类型" class="headerlink" title="2.9 Attr 类型"></a>2.9 Attr 类型</h3><p>元素的特性在 DOM 中以 Attr 类型来表示。在所有浏览器中，都可以访问 Attr 类型的构造器和原型。从技术角度讲，特性就是存在于元素的 <code>attributes</code> 属性中的节点。具有的特征包括：</p>
<ul>
<li>ndoeType 的值为 2</li>
<li>nodeName 的值就是特性的名称</li>
<li>nodeValue 的值是特性的值</li>
<li>parentNode 的值为 null</li>
<li>在 HTML 中不支持（没有）子节点</li>
<li>在 XML 中可以有 Text 或者 EntityReference 子节点</li>
</ul>
<p>创建 Attr 节点可以使用 <code>document.createAttribute()</code> 方法，Attr 节点创建完成后，还需要使用 <code>setAttribute()</code> 方法来将属性值设到元素中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">&#x27;align&#x27;</span>)</span><br><span class="line">attr.value = <span class="string">&#x27;left&#x27;</span></span><br><span class="line"></span><br><span class="line">myDiv.setAttribute(attr)</span><br></pre></td></tr></table></figure>

<p>但是在开发中，直接使用 <code>setAttribute()</code> 方法会更加直接一些：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>)</span><br><span class="line">myDiv.setAttribute(<span class="string">&#x27;align&#x27;</span>, <span class="string">&#x27;left&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>对象变化侦测原理（三）</title>
    <url>/framework/vuejs/dection03/</url>
    <content><![CDATA[<h2 id="三、Array-数组侦测"><a href="#三、Array-数组侦测" class="headerlink" title="三、Array 数组侦测"></a>三、Array 数组侦测</h2><p>数组 Array 虽然也是属于对象类型，但还是存在一些差别，它没办法像 Object 对象那样，通过 <code>setter/getter</code> 的方式来监听属性的变化，因此对于 Array 而言，需要用到另外一套变化侦测方案。</p>
<h3 id="3-1-如何追踪变化"><a href="#3-1-如何追踪变化" class="headerlink" title="3.1 如何追踪变化"></a>3.1 如何追踪变化</h3><p>我们知道，Array 数组有很多个内置方法可以改变数组的值，比如 <code>push</code>,<code>pop</code>,<code>shift</code>等，这些方法都可以改变数组的内容，所以可以尝试通过监听这些方法的调用，来达到监听数组变化的目的。</p>
<p>但是，这些方法都是内置方法，而且 js 中并没有提供接口给我们覆盖，因此要如何修改这些方法，以达到我们需要的效果呢？</p>
<span id="more"></span>

<p>答案是，原型方法覆盖。</p>
<p>方法覆盖的方式可以分为2种：自定义同名私有方法，数组对象原型覆盖。</p>
<ul>
<li>1、自定义同名私有方法</li>
</ul>
<p>比如说，我们通过给数组对象添加同名的私有方法，就可以覆盖数组的内置方法。</p>
<p>假设数组对象 <code>arr</code> 本身自带有内置方法 <code>push</code>，我们可以通过添加同名私有方法 <code>arr.push</code> 来覆盖它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.push = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 里面再调回数组的内置方法</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.push.apply(arr, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过利用私有方法调用优先级的方式，就可以实现内置方法的代理。</p>
<p>每当我们调用 <code>push</code> 方法时，效果依旧和原来的一样，只不过实际上调用的是被我们包装代理过后的方法。</p>
<ul>
<li>2、数组对象原型覆盖</li>
</ul>
<p>除了使用私有方法覆盖的方式以外，还可以通过覆盖数组对象原型 <code>Array.prototype</code> 来实现。</p>
<p>我们都知道，在调用方法时，会优先从当前对象中查找该方法，如果没有，则会继续往上查找对象的原型中有没有该方法，然后这样一直向上，直到找到对应的方法为止，因此我们可以通过覆盖原型对象来实现方法代理。</p>
<p>比如说，数组对象 <code>arr</code> 在调用方法 <code>push</code> 时，会先查找本身有没有这个方法，如果没有，它就会去找原型 <code>Array.prototype</code> 中有没有该方法，这个时候找到了，就可以顺利调用 <code>push</code> 方法了。</p>
<p>假设这个时候，我把 <code>arr</code> 的原型换掉，换成我们自己封装过的，那么在数组对象向上寻找方法时，就会去我们换过的原型中查找方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="comment">// 覆盖原型对象</span></span><br><span class="line">arr.__proto__ = &#123;</span><br><span class="line">  <span class="attr">push</span>: <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 里面再调回数组的内置方法</span></span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.apply(arr, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这种原型对象替换的方式，也可以实现内置方法的代理。</p>
<h3 id="3-2-方法拦截器"><a href="#3-2-方法拦截器" class="headerlink" title="3.2 方法拦截器"></a>3.2 方法拦截器</h3><p>方法拦截器就是前面介绍的2种代理方式，其实对于这2种代理方式，Vue 中都有相应的实现。</p>
<p>首先，需要代理的方法是能够修改数组对象的方法，包括7个方法：<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>。</p>
<p>其实，我们再构造拦截方法，具体看 Vue 的代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个和原始数组原型一样的对象</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要拦截的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现方法拦截</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 里面再调回原始的方法</span></span><br><span class="line">      <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      <span class="comment">// 后面还可以做其他事情</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过这种方法，我们就可以拦截数组对象的方法调用。</p>
<p>然后，将构造好的拦截方法设置到数组对象上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否支持 `__proto__` 属性</span></span><br><span class="line"><span class="keyword">const</span> hasProto = <span class="string">&#x27;__proto__&#x27;</span> <span class="keyword">in</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 需要拦截的方法名称集合</span></span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="built_in">Object</span>.getOwnPropertyNames(arrayMethods)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 数组的方法拦截处理</span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="comment">// 原型替换</span></span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义私有方法</span></span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换原型拦截代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src</span>) </span>&#123;</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义私有方法拦截代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target, src, keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">      <span class="attr">value</span>: src[key],</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要2种实现方式呢？只用自定义私有方法不就可以实现了吗？</p>
<p>其实是 Vue 优先使用原型替换来实现拦截，但是由于原型属性 <code>__proto__</code> 在 ES6 之前并不属于官方标准属性，也就是说，通过 <code>__proto__</code>  访问原型的方式并不是所有浏览器都支持！！！</p>
<p>所以，当浏览器不支持 <code>__proto__</code> 时，就使用自定义方法拦截的方式实现。</p>
<h3 id="3-3-收集依赖"><a href="#3-3-收集依赖" class="headerlink" title="3.3 收集依赖"></a>3.3 收集依赖</h3><p>既然方法拦截已经实现了，那么接下来就应该要实现依赖收集了。</p>
<p>依旧是按3步走：在哪里收集依赖、收集到哪里、什么时候触发依赖。</p>
<ul>
<li>在哪里收集依赖</li>
</ul>
<p>这个其实和 Objec 对象一样，数组对象的依赖也是在 <code>getter</code> 中收集的。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，访问数组对象实际上都是通过访问另外一个对象的属性来得到的，例如这里的 <code>obj.arr</code>。</p>
<p>也就是说，在收集 <code>obj.arr</code> 属性的依赖时，可以顺便收集数组的依赖，记住，是顺便收集~~。</p>
<p>因此，Array 数组对象的依赖收集，也是在 <code>defineReactive</code> 中收集的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集对象属性的依赖</span></span><br><span class="line">      dep.depend()</span><br><span class="line">      <span class="comment">// 如果val是数组，则顺便收集数组的依赖</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(val)) &#123;</span><br><span class="line">        <span class="comment">// 这里收集数组依赖</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在收集值为数组对象依赖时，实际上收集了2次依赖，一次是对象属性 <code>obj.arr</code> 的依赖），一次是属性对应的数组值 <code>[1, 2, 3]</code> 的依赖。</p>
<p>综上，Array 数组对象的依赖是在 <code>getter</code> 中收集，而依赖的触发则是在方法拦截器中。</p>
<ul>
<li>收集到哪里</li>
</ul>
<p>Array 数组对象依赖收集起来的地方，和 Object 对象的稍微有点不同。</p>
<p>原因在于，Object 对象的依赖收集和依赖触发，都是放在同一个作用域内的，也就是 <code>getter/setter</code> 方法，因此依赖只要保存在收集和触发的方法都能访问到的地方即可，在代码中也就是在 <code>defineReactive</code> 方法内。</p>
<p>而 Array 数组对象的话，依赖收集是在 <code>getter</code> 方法中，依赖触发则是在方法拦截器中，需要保证它们俩都能访问到依赖才行。</p>
<p>其实也很简单，只要找到它们的公共父作用域即可，而数组对象本身就可以满足这个条件。</p>
<p>为了能够让收集和触发访问到依赖对象，我们可以将依赖对象保存到数组对象中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="comment">// 把依赖对象保存在数组对象中，这样两边都可以访问</span></span><br><span class="line">    <span class="built_in">this</span>.value.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 数组的方法拦截处理</span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="comment">// 原型替换</span></span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义私有方法</span></span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="keyword">let</span> childOb</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    childOb = <span class="keyword">new</span> Observer(val) <span class="comment">// 修改</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集对象属性的依赖</span></span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="comment">// 如果有子对象/子数组</span></span><br><span class="line">      <span class="keyword">if</span> (childOb &amp;&amp; childOb.value.dep) &#123; <span class="comment">// 修改</span></span><br><span class="line">        childOb.value.dep.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法拦截</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 里面再调回原始的方法</span></span><br><span class="line">      <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      <span class="comment">// 前面已经把依赖保存到数组的属性中，可以直接调用</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.dep) &#123; <span class="comment">// 修改</span></span><br><span class="line">        <span class="built_in">this</span>.dep.notify() </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然这种方式也可以使得收集和触发都能访问到 <code>dep</code> 依赖对象，但是感觉不是很优雅，代码中直接在 <code>value</code> 上赋值了 <code>value.dep</code> 属性，这样很容易造成冲突。</p>
<p>所以 Vue 使用了另外一种方式，不是直接在 <code>value</code> 上添加属性 <code>value.dep</code>，而是在 <code>value</code> 上加了一个私有属性 <code>__ob__</code>，表示观察者 <code>Observer</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep() <span class="comment">// 修改，直接把依赖放在观察者下</span></span><br><span class="line">    <span class="built_in">this</span>.value.__ob__ = <span class="built_in">this</span> <span class="comment">// 修改，保存到 value.__ob__ 中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 数组的方法拦截处理</span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="comment">// 原型替换</span></span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义私有方法</span></span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="keyword">let</span> childOb</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    childOb = <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集对象属性的依赖</span></span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="comment">// 如果有子对象/子数组</span></span><br><span class="line">      <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">        childOb.dep.depend() <span class="comment">// 修改</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法拦截</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 里面再调回原始的方法</span></span><br><span class="line">      <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 先获取观察者，再得到依赖</span></span><br><span class="line">      <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__ <span class="comment">// 修改</span></span><br><span class="line">      <span class="keyword">if</span> (ob) &#123;</span><br><span class="line">        ob.dep.notify() </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-存在问题"><a href="#3-4-存在问题" class="headerlink" title="3.4 存在问题"></a>3.4 存在问题</h3><p>数组的变化侦测存在的问题，其实很明显。从上面的介绍可知，数组的变化侦测是通过代理数组的原型方法来实现的，所以只要是不经过代理方法调用的，都不会被侦测到。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">arr.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>类似这种直接修改数组的值，就不会被变化侦测检测到。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>对象变化侦测原理（二）</title>
    <url>/framework/vuejs/dection02/</url>
    <content><![CDATA[<h2 id="二、Object-变化侦测"><a href="#二、Object-变化侦测" class="headerlink" title="二、Object 变化侦测"></a>二、Object 变化侦测</h2><p>变化侦测指的是，当运行时的状态发生变化时，应用程序可以知道哪个状态发生了变化，并作出相应的动作。</p>
<p>变化侦测的方式可以分为2种：一种是“推（push）”，一种是“拉（pull）”。</p>
<p>Vue 的变化侦测就属于“推，当状态发生变化时，它就会通知相应的依赖对象进行更新。</p>
<h3 id="2-1-追踪变化"><a href="#2-1-追踪变化" class="headerlink" title="2.1 追踪变化"></a>2.1 追踪变化</h3><span id="more"></span>

<p>前面说过，Object 的属性可以分为2种：数据属性和访问属性。</p>
<p>Vue 就是通过利用访问属性的 <code>setter</code> 和 <code>getter</code> 函数来追踪对象的变化的。</p>
<p>每当对象属性被读取时，<code>getter</code> 函数就会被触发；每当对象属性更新时，<code>setter</code> 函数就会被触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isStateChange = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    obj.data = val;</span><br><span class="line">    isStateChange = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">objProxy.access</span><br><span class="line">alert(isStateChange)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">objProxy.access = <span class="string">&#x27;111&#x27;</span></span><br><span class="line">alert(isStateChange)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-收集依赖"><a href="#2-2-收集依赖" class="headerlink" title="2.2 收集依赖"></a>2.2 收集依赖</h3><p>知道了如何监听对象的变化，但是应该如何收集依赖呢？也就是说当状态发生变化后，该向谁通知状态变更呢？</p>
<p>收集依赖需要分为3步：要收集什么？什么时候收集？收集到哪里？</p>
<ul>
<li>1、要收集什么？</li>
</ul>
<p>哪些算是依赖？其实就是用到了对象属性的地方就是依赖。比如说：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; obj.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于上述模板，它调用了 <code>name</code> 属性，也就是对 <code>obj.name</code> 产生了依赖，当 <code>obj.name</code> 发生变化时，就需要通知模板进行重新渲染。</p>
<p>对于这种调用了对象属性的地方，都是需要收集起来的。</p>
<ul>
<li>2、什么时候收集？</li>
</ul>
<p>前面已经说过了，Vue 是通过利用访问属性的 <code>setter</code> 和 <code>getter</code> 函数来进行侦听变化的。</p>
<p>因此收集原理也很简单，在 <code>getter</code> 中收集依赖，在 <code>setter</code> 中触发依赖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isStateChange = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    obj.data = val;</span><br><span class="line">    isStateChange = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">objProxy.access</span><br><span class="line">alert(isStateChange)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">objProxy.access = <span class="string">&#x27;111&#x27;</span></span><br><span class="line">alert(isStateChange)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>3、收集到哪里？</li>
</ul>
<p>对于这个，可以简单地为每一个属性创建一个局部变量 <code>dep</code> 来保存。</p>
<p>假设依赖对象是一个函数，并且保存在 <code>window.target</code> 中，那么依赖的收集和通知实现可以如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = []; <span class="comment">// 保存依赖的地方</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="comment">// 假设依赖对象保存在 window.target 中</span></span><br><span class="line">      dep.push(<span class="built_in">window</span>.target);</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dep.length; i++) &#123;</span><br><span class="line">        dep[i](newVal, val)</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照这种实现方式，每个对象属性都拥有自己的依赖收集器 <code>dep</code>。</p>
<p>当然，实际的 <code>dep</code> 并不是那么简单的一个数组，为了减低代码的耦合性，Vue 中把它实现为一个类 <code>Dep</code>，下面是它的简单实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 依赖，订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="comment">// 假设依赖对象保存在 window.target 中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.target) &#123;</span><br><span class="line">      <span class="built_in">this</span>.addSub(<span class="built_in">window</span>.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subd.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 通知依赖（订阅者）更新</span></span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</span><br><span class="line">    <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据新的 <code>dep</code>，修改 <code>defineReactive</code> 实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep(); <span class="comment">// 修改1</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集依赖</span></span><br><span class="line">      dep.depend(); <span class="comment">// 修改2</span></span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify(); <span class="comment">// 修改3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，收集依赖的工作基本完成了。</p>
<p>等等，还有一件重要的事，究竟什么是依赖呢？它到底从哪来的？虽然在前面的代码里，假设依赖是一个函数，并且已经设置到了 <code>window.target</code> 中， 但是并没有具体说明它是从哪里来的，是什么时候设置到 <code>window.target</code> 的。下面详细说明一下它。</p>
<ul>
<li>依赖对象</li>
</ul>
<p>前面说过，依赖实际上是用到对象属性的地方，但是用到对象属性的地方太多了，而且类型可能不一样，环境也不一样。这个时候为了能够统一处理依赖对象，需要将其抽象成一个依赖对象，这个依赖对象就称为观察者 <code>Watcher</code>，它就像是一直在观察对象属性的变化一样，当对象属性发生变化后，它就可以通过“观察”发现，从而进行相应的动作。</p>
<p>在 Vue 中，<code>Watcher</code> 是一个中介对象，当数据发生变化时，会通知到观察者 <code>Watcher</code>，然后 <code>Watcher</code> 再通知其他地方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">vm, expOrFn, cb</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="comment">// 先把this设置到window.target中，然后再读取对象属性</span></span><br><span class="line">    <span class="built_in">window</span>.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 这时候被读到的对象属性就会把当前this收集到它的依赖集合里面</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.vm);</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="built_in">this</span>.cb(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.value, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收集依赖的过程实际上就在 <code>getter</code> 函数被调用的时候，那么 <code>getter</code> 函数具体是什么呢？也就是 <code>parsePath</code> 的实现是怎么样的呢？</p>
<p>其实 <code>parsePath</code> 的参数 <code>path</code> 是类似 <code>a.b.c</code> 这样的形式，如果用过 Vue 的话，就应该知道 Vue 中可以利用 <code>vm.$watch(&#39;a,b.c&#39;, function()&#123;&#125;)</code> 这种形式来监听对象属性的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际原理很简单，<code>parsePath</code> 只是按照分隔符 <code>.</code> 来逐层地访问对象属性。</p>
<p>而前面说过，当读取对象的访问属性时，会触发依赖收集。所以当 <code>getter</code> 函数执行时，它其实就是在读取对象的访问属性，这个时候就会触发依赖收集的逻辑。</p>
<h3 id="2-3-监测所有属性"><a href="#2-3-监测所有属性" class="headerlink" title="2.3 监测所有属性"></a>2.3 监测所有属性</h3><p>对于每个属性，如果需要监测它的变化，必须经过 <code>defineReactive</code> 来处理，这样它才能像访问属性那样收集依赖，实现响应式侦听。</p>
<p>为了提高代码的封装，Vue 中封装了一个监听类 <code>Observer</code> 类，用于监听对象的所有属性。</p>
<p>类 <code>Observer</code> 的作用就是将对象的所有属性都转换成访问属性，通过访问属性的 <code>setter</code> 和 <code>getter</code> 来实现变化追踪：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  walk (obj) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 收集依赖</span></span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 <code>Observer</code> 的实现原理很简单，就是把所有属性都遍历一遍，利用 <code>defineReactive</code> 将属性都转成可追踪的访问属性。</p>
<h3 id="2-4-存在问题"><a href="#2-4-存在问题" class="headerlink" title="2.4 存在问题"></a>2.4 存在问题</h3><p>Object 类型数据的变化侦听，其原理是通过访问属性 <code>setter/getter</code> 方法来实现的。</p>
<p>但是这种方式还存在一些问题，比如添加新属性、删除新属性时，<code>setter/getter</code> 是不会触发的，这些情况就没办法追踪属性的变化了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isStateChange = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    isStateChange = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    obj.data = val;</span><br><span class="line">    isStateChange = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除属性不会触发set/get</span></span><br><span class="line"><span class="keyword">delete</span> objProxy.access</span><br><span class="line">alert(isStateChange)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增属性也不会触发set/get</span></span><br><span class="line">objProxy.name = <span class="string">&#x27;newProp&#x27;</span></span><br><span class="line">alert(isStateChange)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>setter/getter</code> 只能跟踪属性值是否发生修改，但是没办法侦测到新增属性和删除属性。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>对象变化侦测原理（一）</title>
    <url>/framework/vuejs/dection01/</url>
    <content><![CDATA[<h1 id="变化侦测原理"><a href="#变化侦测原理" class="headerlink" title="变化侦测原理"></a>变化侦测原理</h1><h2 id="一、对象属性"><a href="#一、对象属性" class="headerlink" title="一、对象属性"></a>一、对象属性</h2><p>对于 js 对象的属性，可以分为2种：数据属性和访问属性。</p>
<h3 id="1-1-数据属性"><a href="#1-1-数据属性" class="headerlink" title="1.1 数据属性"></a>1.1 数据属性</h3><p>数据属性就是普通的对象属性值，可以读入和写入值。</p>
<p>例如，下述的属性 <code>data</code> 就是数据属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.data = <span class="string">&#x27;data&#x27;</span>;</span><br><span class="line"></span><br><span class="line">alert(obj.data) <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于数据属性，它有4个特性：</p>
<span id="more"></span>

<ul>
<li>[[Configureable]]：表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问属性。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li>
<li>[[Writable]]：表示能否修改数据的值。</li>
<li>[[Value]]：这个属性的值。</li>
</ul>
<p>这些属性特性一般是不能通过一般的方式获取到，需要通过使用方法 <code>Object.getOwnPropertyDescriptor(obj, key)</code>来获取特性值。以上面的代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;data&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一般设置的对象属性，默认都是数据属性，而除了 <code>value</code> 特性以外，其他特性的值都是默认为 <code>true</code>。</p>
<p>如果需要修改特性的值，必须使用方法 <code>Object.defineProperty(obj, key, option)</code>来修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;data&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再查看属性的特性，此时 <code>writable</code> 特性的值就已经发生变化了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;data&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>writable=false</code> 表示属性不能修改，因此修改属性值是不生效的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(obj.data)  <span class="comment">// &quot;data&quot;</span></span><br><span class="line">obj.data = <span class="string">&quot;123&quot;</span> <span class="comment">// 此时修改的话也不生效</span></span><br><span class="line">alert(obj.data)  <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以多次调用 <code>Object.defineProperty</code> 来修改属性特性。</p>
<p>接下来看一下特性 <code>configurable</code> 的作用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>configurable=false</code> 表示属性无法通过 <code>delete</code> 删除，再重新定义属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(obj.data)  <span class="comment">// &quot;data&quot;</span></span><br><span class="line"><span class="keyword">delete</span> obj.data  <span class="comment">// 无法删除</span></span><br><span class="line">alert(obj.data)  <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure>

<p>而且，还有一个比较重要的点，那就是一旦把 <code>configurable</code> 设置为 <code>false</code> 之后，就不能再把它重新恢复为 <code>true</code> 了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置失败，抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-访问属性"><a href="#1-2-访问属性" class="headerlink" title="1.2 访问属性"></a>1.2 访问属性</h3><p>访问属性不包括数据，实际上是通过一对函数 <code>setter</code> 和 <code>getter</code> 进行属性的读取访问和设置。</p>
<p>访问属性不能通过一般的对象属性进行定义，必须使用 <code>Object.defineProperty(obj, key, option)</code> 进行定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.data = <span class="string">&#x27;data&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问属性</span></span><br><span class="line"><span class="keyword">var</span> objProxy = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    obj.data = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(obj.data)        <span class="comment">// &quot;data&quot;</span></span><br><span class="line">alert(objProxy.access) <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure>

<p>属性 <code>access</code> 就是所谓的访问属性，它和一般的数据属性 <code>data</code> 一样，它也有 4 个特性：</p>
<ul>
<li>[[Configureable]]：表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问属性。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li>
<li>[[Get]]：在读取属性时调用的函数。</li>
<li>[[Set]]：在设置属性时调用的函数。</li>
</ul>
<p>其中特性 <code>Configureable</code> 和 <code>Enumerable</code> 和数据属性中的是一样的。</p>
<p>获取属性特性的值也和数据属性的一样，通过方法 <code>Object.getOwnPropertyDescriptor(obj, key)</code> 来获取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(objProxy, <span class="string">&#x27;access&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: [<span class="function"><span class="keyword">function</span> (<span class="params"></span>)],</span></span><br><span class="line"><span class="function">    <span class="title">set</span>: [<span class="function"><span class="keyword">function</span> (<span class="params"></span>)]</span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>访问属性比较特别，可以通过在访问函数 <code>setter</code> 和 <code>getter</code><br>中做一些中间操作，获得其他的效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readTimes = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> writeTimes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProxy, <span class="string">&#x27;access&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    readTimes++;</span><br><span class="line">    <span class="keyword">return</span> obj.data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    writeTimes++;</span><br><span class="line">    obj.data = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">objProxy.access</span><br><span class="line">objProxy.access</span><br><span class="line">alert(readTimes)  <span class="comment">// 2</span></span><br><span class="line">alert(writeTimes) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">objProxy.access = <span class="string">&#x27;111&#x27;</span></span><br><span class="line">alert(readTimes)  <span class="comment">// 2</span></span><br><span class="line">alert(writeTimes) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这种利用访问函数的方式，其实就是 <code>Vue</code> 定义响应式属性所用的方法，通过利用访问属性的 <code>setter</code> 和 <code>getter</code> 来收集和通知属性发生了变更，就可以实现响应式属性。</p>
<p>也许，访问属性叫访问方法更好，虽然操作上和数据属性类似，但是它本身并不算一个属性，只是通过方法 <code>setter</code> 和 <code>getter</code> 进行了定义，然后拿的还是其他数据属性的值。</p>
<p>定义 <code>setter</code> 和 <code>getter</code> 实际上就是在定义 <code>objProxy.access=</code> 和 <code>objProxy.access</code>。调用 <code>objProxy.access</code> 就是在调用 <code>getter</code> 函数，调用 <code>objProxy.access=</code> 就是在调用 <code>setter</code> 函数。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>格式</title>
    <url>/book/clean_code/formatter/</url>
    <content><![CDATA[<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="1-垂直格式"><a href="#1-垂直格式" class="headerlink" title="1. 垂直格式"></a>1. 垂直格式</h2><ul>
<li>短的源文件比长的源文件会更好，一般在200行~500行之间为好</li>
<li>源文件的结构应该是从上往下展开，顶部是高层次概念，底下是实现细节，可以简单理解为 public 放在前，private 放在后</li>
<li>每组代码应该是完整的一条思路，不同组代码之间应该用空白行隔开</li>
<li>相关代码应该靠近，避免把相关的概念放到不同文件中，即避免过度使用 protected</li>
<li>变量声明应该尽可能靠近其使用位置</li>
<li>实体变量应该在类的顶部声明</li>
<li>函数调用应该放在一起，也就是被调用者在调用者的下面，保持程序的顺序性</li>
<li>概念相关的代码应该放在一起，相关性越强，彼此之间的距离就应该越短</li>
</ul>
<h2 id="2-水平格式"><a href="#2-水平格式" class="headerlink" title="2. 水平格式"></a>2. 水平格式</h2><span id="more"></span>

<ul>
<li>代码行尽量短小，控制在120个字符以内最好</li>
<li>操作符左/右加上空格，例如 <code>=</code>、<code>+</code>、<code>-</code>、<code>？</code>等左右都应该加上空格，而 <code>,</code> 则是右边加空格</li>
<li>函数名和左括号不加空格</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明时不要加空格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时不要加空格</span></span><br><span class="line">print();</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数之间用逗号和空格隔开，可以明显区分参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数之间加上空格分隔</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(String prefix, String name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有时为了强调运算符之间的关系，使用空格或括号分隔</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 这种方式也可以，但是会被格式化工具清理掉</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span> <span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b*b - <span class="number">4</span>*a*c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 所以建议用括号分隔不同的计算，明确区分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span> <span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b * b) - (<span class="number">4</span> * a * c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不建议使用对齐的变量声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有人喜欢把变量名对齐，</span></span><br><span class="line">    <span class="comment">// 但是格式化工具会把排版清理掉，所以不建议这样写</span></span><br><span class="line">    <span class="keyword">private</span> String  firstName;</span><br><span class="line">    <span class="keyword">private</span> String  lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">private</span> String  address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>即使是单条语句，判断语句 <code>if</code>，<code>while</code>，以及函数都应该用大括号 <code>&#123;&#125;</code> 将代码包起来</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不建议这么写</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该用大括号</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使这样也应该用大括号</span></span><br><span class="line"><span class="keyword">while</span> (isTrue()) &#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不要违反缩进规则，特别是 <code>if</code>，<code>while</code> 和短函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有人会这么写</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123; reurn a &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议缩进</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/book/clean_code/annotation/</url>
    <content><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="1-注释的作用"><a href="#1-注释的作用" class="headerlink" title="1. 注释的作用"></a>1. 注释的作用</h2><ul>
<li>为了弥补代码表达某种意图时不够清晰的一种手段</li>
</ul>
<h2 id="2-注释的缺点"><a href="#2-注释的缺点" class="headerlink" title="2. 注释的缺点"></a>2. 注释的缺点</h2><ul>
<li>需要写注释，就说明代码很糟糕，代码不能够清晰表达它的意思</li>
<li>注释会随着时间变得腐烂，离其描述的代码越来越远，甚至变得全部是错误的，因为程序员往往不能坚持维护注释</li>
</ul>
<h2 id="3-好注释"><a href="#3-好注释" class="headerlink" title="3. 好注释"></a>3. 好注释</h2><span id="more"></span>

<ul>
<li>不需要写注释就是最好的注释，由代码自己来阐述自己的意义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File tempDirectory = FileUtils.getTempDirectory();</span><br></pre></td></tr></table></figure>

<ul>
<li>法律信息类型的注释，例如版权及著作权声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"> * contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"> * this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"> * The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"> * (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"> * the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提供有用信息的注释，凡是能够根据注释去理解代码所代表的含义的信息，都可以称为有用信息，这个范围比较广</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(<span class="keyword">final</span> File file1, <span class="keyword">final</span> File file2)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> file1Exists = file1.exists();</span><br><span class="line">    <span class="keyword">if</span> (file1Exists != file2.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file1Exists) &#123;</span><br><span class="line">        <span class="comment">// two not existing files are equal</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对意图解释的注释，用于解释当前代码这么做的原因，往往是因为代码中进行了特殊处理，例如性能优化，特例处理等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!directory.mkdirs()) &#123;</span><br><span class="line">    <span class="comment">// Double-check that some other thread or process hasn&#x27;t made</span></span><br><span class="line">    <span class="comment">// the directory in the background</span></span><br><span class="line">    <span class="keyword">if</span> (!directory.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">final</span> String message =</span><br><span class="line">                <span class="string">&quot;Unable to create directory &quot;</span> + directory;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>阐释型注释，这类注释一般是由于代码结构和含义比较难以理解，因而专门进行介绍，例如算法，多参数函数等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Implementation notes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This map usually acts as a binned (bucketed) hash table, but</span></span><br><span class="line"><span class="comment"> * when bins get too large, they are transformed into bins of</span></span><br><span class="line"><span class="comment"> * TreeNodes, each structured similarly to those in</span></span><br><span class="line"><span class="comment"> * java.util.TreeMap. Most methods try to use normal bins, but</span></span><br><span class="line"><span class="comment"> * relay to TreeNode methods when applicable (simply by checking</span></span><br><span class="line"><span class="comment"> * instanceof a node).  Bins of TreeNodes may be traversed and</span></span><br><span class="line"><span class="comment"> * used like any others, but additionally support faster lookup</span></span><br><span class="line"><span class="comment"> * when overpopulated. However, since the vast majority of bins in</span></span><br><span class="line"><span class="comment"> * normal use are not overpopulated, checking for existence of</span></span><br><span class="line"><span class="comment"> * tree bins may be delayed in the course of table methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>警示型注释，用于警告其他程序员不要随便修改此处的代码，或者这里的代码会产生什么后果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SimpleDateFormat is not thread safe,</span></span><br><span class="line"><span class="comment">// so need to create each instance independently</span></span><br><span class="line">SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>TODO 列表注释，一般是由于某些原因暂时还没有做的留空，或者为了以后方便扩展留下的空门</p>
</li>
<li><p>Javadoc 文档注释，用于介绍代码整体结构，提供公共 API 方便别人调用的注释</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An object that maps keys to values.  A map cannot contain duplicate keys;</span></span><br><span class="line"><span class="comment"> * each key can map to at most one value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface takes the place of the &lt;tt&gt;Dictionary&lt;/tt&gt; class, which</span></span><br><span class="line"><span class="comment"> * was a totally abstract class rather than an interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &lt;tt&gt;Map&lt;/tt&gt; interface provides three &lt;i&gt;collection views&lt;/i&gt;, which</span></span><br><span class="line"><span class="comment"> * allow a map&#x27;s contents to be viewed as a set of keys, collection of values,</span></span><br><span class="line"><span class="comment"> * or set of key-value mappings.  The &lt;i&gt;order&lt;/i&gt; of a map is defined as</span></span><br><span class="line"><span class="comment"> * the order in which the iterators on the map&#x27;s collection views return their</span></span><br><span class="line"><span class="comment"> * elements.  Some map implementations, like the &lt;tt&gt;TreeMap&lt;/tt&gt; class, make</span></span><br><span class="line"><span class="comment"> * specific guarantees as to their order; others, like the &lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * class, do not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="4-坏注释"><a href="#4-坏注释" class="headerlink" title="4. 坏注释"></a>4. 坏注释</h2><ul>
<li>不明确的注释，这类注释介绍不清楚，说不清楚代码的含义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Calculate</span></span><br><span class="line"><span class="keyword">double</span> value = money * <span class="number">50</span> + <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>多余的注释，代码本身就很明确，不需要进行多余的注释说明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check null</span></span><br><span class="line"><span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// return if null</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>误导性的注释，有些注释表达不精确，什么具有误导性，注释的内容和代码存在差异</li>
<li>循规式注释，一成不变地遵循每个函数或每个变量都要有注释的规矩，会使得代码中充满注释，结构变得散乱</li>
<li>日志式注释，把注释当成日志在写，每次修改都在注释中添加修改日志。这是旧代码的写法，因为现在已经有代码版本控制系统，不再需要这种写法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Changes log</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2020-04-01: Fixed bug ...</span></span><br><span class="line"><span class="comment"> * 2020-05-01: Add a ...</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>废话注释，像讲故事一样，天马行空，不够简洁，大部分内容都和代码毫无关系</li>
<li>位置标记注释，就是用于特别标记某个代码位置的注释，没有特别价值尽量少用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **************** Start ************** //</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// **************** End   ************** //</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结束括号的标记注释，一般是为了识别每个括号的意义，实际上这类注释没有必要，除非是深层嵌套结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="comment">// if</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">&#125; <span class="comment">// if</span></span><br></pre></td></tr></table></figure>

<ul>
<li>归属或署名，由于当前已经有代码版本控制系统，已经不需要这种注释了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add by xxx at 2020/04/01</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注释的代码，其他程序员可能不敢随便删除注释的代码，因为它们可能还有用处。但是现在已经有了代码版本控制系统，代码可以找回，不需要留着被注释掉的代码</li>
</ul>
<h2 id="5-注释优化"><a href="#5-注释优化" class="headerlink" title="5. 注释优化"></a>5. 注释优化</h2><ul>
<li>尽量用函数或变量来替换注释</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check is validate</span></span><br><span class="line"><span class="keyword">if</span> (length &gt; <span class="number">0</span> &amp;&amp; str != <span class="keyword">null</span> &amp;&amp; str.indexOf(<span class="string">&quot;s&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用变量进行替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isValid = length &gt; <span class="number">0</span> &amp;&amp; str != <span class="keyword">null</span> &amp;&amp; str.indexOf(<span class="string">&quot;s&quot;</span>) &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>提炼废话较多的注释，将不相关的注释内容去掉</li>
<li>短函数不需要太多描述，选择一个好的函数名会比注释来的好</li>
</ul>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/book/clean_code/method/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-短小"><a href="#1-短小" class="headerlink" title="1. 短小"></a>1. 短小</h2><ul>
<li>函数在保证完整性的情况下，越短越好</li>
<li>每个函数都应该一目了然</li>
<li>长度为 20 行最佳</li>
</ul>
<h2 id="2-只做一件事"><a href="#2-只做一件事" class="headerlink" title="2. 只做一件事"></a>2. 只做一件事</h2><ul>
<li>每个函数应该保证只做一件事</li>
<li>要判断函数是否只做了一件事，可以看是否还能再拆出一个函数</li>
<li>一件事是指在同一抽象层次上完成的动作</li>
</ul>
<h2 id="3-每个函数一个抽象层级"><a href="#3-每个函数一个抽象层级" class="headerlink" title="3. 每个函数一个抽象层级"></a>3. 每个函数一个抽象层级</h2><span id="more"></span>

<ul>
<li>抽象层级类似于动作的抽象程度，例如 <code>getData</code> 和 <code>data.push(item)</code> 就属于不同的层次，<code>getData</code> 属于高层级别，而 <code>data.push(item)</code> 已经是属于比较低级别，因为它深入到了数据操作的底层</li>
<li>函数调用一般是高级别调用低级别，这样一层一层深入，是一种自顶向下的规则</li>
<li>如果出现同级别的函数调用，那可能是还有隐含的低层次还未抽象出来</li>
</ul>
<h2 id="4-switch-语句"><a href="#4-switch-语句" class="headerlink" title="4. switch 语句"></a>4. switch 语句</h2><ul>
<li>switch 天生是做多件事的，因此无法满足只做一件事的要求</li>
<li>switch 难以写出较为短小的语句</li>
<li>可以利用抽象工厂的方式，将 switch 抽象到父类中，利用多态来隐藏 switch 语句</li>
</ul>
<h2 id="5-使用描述性的名称"><a href="#5-使用描述性的名称" class="headerlink" title="5. 使用描述性的名称"></a>5. 使用描述性的名称</h2><ul>
<li>好的函数名称可以清晰地说明函数的作用</li>
<li>不要害怕长名称，长而具有描述性的名称，比短而令人费解的名称要好</li>
<li>长而具有描述性的名称，也比描述性的长注释要好</li>
<li>命名应该保持一致，使用与模块名一致的短语、名词或动词</li>
</ul>
<h2 id="6-函数参数"><a href="#6-函数参数" class="headerlink" title="6. 函数参数"></a>6. 函数参数</h2><ul>
<li>函数参数不要多，0个最好，1个比较好，2个还行，3个以上基本不考虑</li>
<li>不要使用输出参数（不是输出值），而应该使用返回值，输出参数已经是以前旧代码的写法了。例如有返回值 <code>StringBuffer transform(StringBuffer in)</code> 会比输出参数 <code>void transform(StringBuffer in)</code> 更好一些</li>
<li>不建议使用标识参数（即 bool 参数），因为违反了一个函数只做一件事的原则，解决方法是拆分成两个函数</li>
<li>3个及以上的参数，应该考虑将其封装成类，从而减少参数数量</li>
</ul>
<h2 id="7-分隔指令与查询"><a href="#7-分隔指令与查询" class="headerlink" title="7. 分隔指令与查询"></a>7. 分隔指令与查询</h2><ul>
<li>函数要么做修改对象的状态，要么返回对象的有关信息，二者不可兼得。例如 <code>boolean set(String attr, String value)</code> 就属于既修改来对象的状态，又返回了有关信息</li>
<li>正确的做法是将指令与查询分开，即利用 <code>set</code> 和 <code>get</code> 来实现</li>
</ul>
<h2 id="8-使用异常替代返回错误码"><a href="#8-使用异常替代返回错误码" class="headerlink" title="8. 使用异常替代返回错误码"></a>8. 使用异常替代返回错误码</h2><ul>
<li>返回错误码轻微违反了指令与查询分隔的规则</li>
<li>返回错误码容易导致多层次的嵌套，因为主流程代码需要根据不同的返回错误码进行不同的错误处理</li>
<li>使用异常替代返回错误码，可以将错误处理代码和主流程代码分离开来</li>
<li>将 try/catch 块抽取出来，单独作为一个函数，因为它容易导致函数结构混乱</li>
<li>使用异常替代错误码，可以使用新异常类从基本异常类中派生出来</li>
</ul>
<h2 id="9-消除重复代码"><a href="#9-消除重复代码" class="headerlink" title="9. 消除重复代码"></a>9. 消除重复代码</h2><ul>
<li>重复代码是影响代码整洁性的罪魁祸首之一</li>
<li>要尽量清除掉代码中的重复代码</li>
</ul>
<h2 id="10-反复调整"><a href="#10-反复调整" class="headerlink" title="10. 反复调整"></a>10. 反复调整</h2><ul>
<li>不要想着一开始就把函数写好，都是反复重构的</li>
<li>将函数的功能实现后，再根据基本原则对代码，对代码进行修改调整</li>
<li>最好给函数加上测试用例，调整完成后要保证函数都能通过测试</li>
</ul>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>有意义的命名</title>
    <url>/book/clean_code/meaningful_naming/</url>
    <content><![CDATA[<h1 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h1><h2 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1. 名副其实"></a>1. 名副其实</h2><ul>
<li><p>变量、函数或类的名称应该能够准确地说明它的意义，比如它存在的意义，它做什么事，以及它应该怎么用。</p>
</li>
<li><p>一旦发现好的命名，就应该换掉旧的名称（当然要确定修改的难易程度）。</p>
</li>
</ul>
<h2 id="2-避免误导"><a href="#2-避免误导" class="headerlink" title="2. 避免误导"></a>2. 避免误导</h2><span id="more"></span>

<ul>
<li><p>避免使用与本意相悖的词语，例如变量名 <code>userList</code>，如果不是 <code>List</code> 类型的变量，就不应该用这种命名。</p>
</li>
<li><p>提防使用区别很小的名称，因为很容易拼写错误。</p>
</li>
<li><p>避免使用误导性比较大的字母，例如 <code>0</code>，<code>O</code>，<code>1</code>，<code>l</code>，因为变量之间的区别只是这些字母的话，看错的可能性比较高。</p>
</li>
</ul>
<h2 id="3-做有意义的区分"><a href="#3-做有意义的区分" class="headerlink" title="3. 做有意义的区分"></a>3. 做有意义的区分</h2><ul>
<li><p>名称不同，那么其意义应该也不同才对。</p>
</li>
<li><p>不要使用数字序列作为名称的区分，会让人搞不清楚用途，例如 <code>a1</code>，<code>a2</code>。</p>
</li>
<li><p>多余的废话是冗余的区分，例如 <code>getProduct</code> 和 <code>getProductData</code> 这种就让人比较疑惑，意思区别不大。</p>
</li>
</ul>
<h2 id="4-使用可读性好的名称"><a href="#4-使用可读性好的名称" class="headerlink" title="4. 使用可读性好的名称"></a>4. 使用可读性好的名称</h2><ul>
<li>名称中的单词应该是可读的词语，或者公认的常见缩写，不要自造词语，例如 <code>modymdhms</code> 和 <code>modifinationTimestamp</code>。</li>
</ul>
<h2 id="5-使用可搜索的名称"><a href="#5-使用可搜索的名称" class="headerlink" title="5. 使用可搜索的名称"></a>5. 使用可搜索的名称</h2><ul>
<li><p>名称长短应该与其作用域大小相对应，长名称要优于短名称。</p>
</li>
<li><p>单字母名字应仅用于短方法中的本地变量，例如 <code>i</code>，<code>j</code>。</p>
</li>
<li><p>对于在代码中多次使用的变量或者常量，应该为其定义便于搜索的名称。例如数字常量 7，可以在代码中定义为 <code>DAYS_PER_WEEK</code>，这会比 7 好找得多。</p>
</li>
</ul>
<h2 id="6-避免使用编码"><a href="#6-避免使用编码" class="headerlink" title="6. 避免使用编码"></a>6. 避免使用编码</h2><ul>
<li><p>不要添加成员前缀（或后缀），例如类成员 <code>m_name</code> 和 <code>name</code>，前后缀是以前旧代码所使用的，现在已经废弃了。</p>
</li>
<li><p>不要使用前导字母 <code>I</code> 来编码区分接口和实现，使用 <code>impl</code> 来标识实现类或许更好。</p>
</li>
</ul>
<h2 id="7-别用俗语"><a href="#7-别用俗语" class="headerlink" title="7. 别用俗语"></a>7. 别用俗语</h2><ul>
<li>不要使用俗语或典故作为名称，因为别人有可能不了解这方面的知识。</li>
</ul>
<h2 id="8-每个概念对应一个词"><a href="#8-每个概念对应一个词" class="headerlink" title="8. 每个概念对应一个词"></a>8. 每个概念对应一个词</h2><ul>
<li>给每个抽象概念都选定一个词，并且一以贯之。例如获取这个概念，<code>fetch</code>，<code>get</code>，<code>retrieve</code> 等都可以拿来使用，但是不要在代码中混杂着写，这里用 <code>fetch</code>，那边用 <code>get</code>，除非有明确说明，否则这很容易会让人受到误导。</li>
</ul>
<h2 id="9-别用双关语"><a href="#9-别用双关语" class="headerlink" title="9. 别用双关语"></a>9. 别用双关语</h2><ul>
<li>避免将同一单词用于不用的目的。例如 <code>add</code> 方法，在这个类中用来表示将两个数加起来，而在另一个类中则表示将对象放入集合中。因此可以修改第二个方法名称为 <code>append</code> 来作出区分。</li>
</ul>
<h2 id="10-添加有意义的语境"><a href="#10-添加有意义的语境" class="headerlink" title="10. 添加有意义的语境"></a>10. 添加有意义的语境</h2><ul>
<li><p>如果语境不够清晰，可以为变量加上前缀。假如成员变量 <code>state</code> 在当前上下文中不是很明确时，因为 <code>state</code> 有可能在多个类中都存在。因此可以为其加上前缀 <code>addrState</code>，这样就能表明 <code>state</code> 是属于 <code>Address</code> 类了。</p>
</li>
<li><p>不要添加没用的语境。例如为每个名称都加上 <code>app</code> 的前缀，如 <code>appUser</code>，<code>appAddress</code>，这根本就是毫无意义的冗余。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>人的精力</title>
    <url>/life/human_energy/</url>
    <content><![CDATA[<h1 id="人的精力"><a href="#人的精力" class="headerlink" title="人的精力"></a>人的精力</h1><blockquote>
<p>摘自：<a href="https://zhuanlan.zhihu.com/p/266759994">https://zhuanlan.zhihu.com/p/266759994</a></p>
</blockquote>
<h2 id="一、人的精力是有限的"><a href="#一、人的精力是有限的" class="headerlink" title="一、人的精力是有限的"></a>一、人的精力是有限的</h2><p>人的精力是有限的，做任何有益于自身成长的事情，都需要耗费大量的精力，这也就要求人要有节制地使用这一无形资本。</p>
<blockquote>
<p>曾经有很长的一段时间我不明白为什么每当我参加一些人数众多，气氛热闹，互动频繁的活动时就会情绪低落，即使是参加大型同学聚会，面对大家欢快的讨论，我也多少有些拘谨。直到很久以后，我才明白这种性格特质叫：内向。而内向意味着个体在独处或面对有限的对象时精力充沛，而却对超出自我界限的对象则感到茫然无助，乃至疲惫不堪。</p>
</blockquote>
<h2 id="二、精力的损失"><a href="#二、精力的损失" class="headerlink" title="二、精力的损失"></a>二、精力的损失</h2><span id="more"></span>

<p>有很多人喜欢抱怨“无聊”，“无聊”其实就是精力不济的一种标志。在这种状态下，你几乎不可能做任何“有意义”的事情——比如高效率的工作、学习。你只能做一些娱乐性较高看似放松的事情，比如吃零食，上网，看肥皂剧，玩游戏等等。但在这一过程中，你内心的斗志实质上是被逐渐消磨的。随着时间逐渐拉长，你的精力愈发的懈怠，往往会坠入更深的无聊之中。</p>
<p>追究到底，人的精力是有限的，即使是“无聊”的事情，也会耗费精力。所以，当你发现自己很“无聊”时，就不应该再用“无聊”的事来打发时间，这样只会让自己陷入更“无聊”的无限死循环。</p>
<p>想要打破这个循环，就要从根本上了解自己的精力状况，合理的分配和使用精力。</p>
<h2 id="三、精力与体力"><a href="#三、精力与体力" class="headerlink" title="三、精力与体力"></a>三、精力与体力</h2><p>体力是一个非常重要的存在，它可以说是精力存在的保证，乃至来源。</p>
<p>体力是一个人健康程度的象征，如果不够健康的话，自然会常受各种因素影响，没有办法把注意力集中到做有益的事情上去。</p>
<p>体力和精力都是一种可快速恢复的，弹性十足且通过训练可以显着提高的能量，尤其对于那些已经进行过训练的人而言。而当人因体育锻炼而精神焕发的时候，他的精力也随之反弹，而且这一过程经常性并不随着体力值的降低而呈正相关。</p>
<p>你是不是有过这样一种体验：有时候你经过一天的奔波，体力运动，你反而感到精力旺盛，异常兴奋，甚至不能快速睡着。也许这种特例并不能说明体力值降低时人们的精力甚至能随之增长，但它也说明了运动的重要性。</p>
<p>显而易见的是，如果你一整天甚至更长的时间都待在家里，那你恐怕根本没法保持精力旺盛。</p>
<h2 id="四、保护精力"><a href="#四、保护精力" class="headerlink" title="四、保护精力"></a>四、保护精力</h2><h3 id="4-1-避免关注于己无关-没有意义的事情"><a href="#4-1-避免关注于己无关-没有意义的事情" class="headerlink" title="4.1 避免关注于己无关/没有意义的事情"></a>4.1 避免关注于己无关/没有意义的事情</h3><p>有太多的人每天把注意力放在与自己完全无关的事情上，以此消磨自己的意志、精力和时间，原因只是因为他们很“无聊”，不得不说这是一种恶劣的恶性循环。</p>
<h3 id="4-2-避免情绪的波动"><a href="#4-2-避免情绪的波动" class="headerlink" title="4.2 避免情绪的波动"></a>4.2 避免情绪的波动</h3><p>没有什么比强烈的情绪更能直接损耗一个人的精力。如果是强烈的快乐和兴奋还好，但如果是强烈的负面情绪，则会直接让一个人的精力陷入瘫痪。</p>
<h3 id="4-3-保持生活的平衡"><a href="#4-3-保持生活的平衡" class="headerlink" title="4.3 保持生活的平衡"></a>4.3 保持生活的平衡</h3><p>保持生活的平衡包括两部分，身体的平衡和心理的平衡。</p>
<p>身体的平衡要求人们对自己的摄入、睡眠、运动保持掌控，对需要身体的任何情况应对自如。</p>
<p>心理平衡则是同理，它是在“避免情绪波动”之上的一个范畴。这是一个很玄乎的状态，很难用文字表达出来。但当你处于这种状态时，则会时常感觉到平和、富足，而如果这种状态鲜有出现，则应该努力往这个方向靠拢。</p>
<h3 id="4-4-不要在精力充沛的时候做一些损害精力的事情"><a href="#4-4-不要在精力充沛的时候做一些损害精力的事情" class="headerlink" title="4.4 不要在精力充沛的时候做一些损害精力的事情"></a>4.4 不要在精力充沛的时候做一些损害精力的事情</h3><p>错误的放松方式是一种恶性循环，你会在不知不觉之中毁掉自己良好的状态和之前的努力。不要在精力充沛的时间做一些“无聊”的事来消耗自己的精力。</p>
<h2 id="五、获取精力"><a href="#五、获取精力" class="headerlink" title="五、获取精力"></a>五、获取精力</h2><p>获取精力其实是和保护精力不受损害对应的概念，但它更侧重于我们要去做什么，而不是不去做什么。</p>
<h3 id="5-1-保持规律而充足的睡眠"><a href="#5-1-保持规律而充足的睡眠" class="headerlink" title="5.1 保持规律而充足的睡眠"></a>5.1 保持规律而充足的睡眠</h3><p>保持规律而充足的睡眠是如此的重要，重要到那些即使在生活其他方面一团糟的人经过睡眠的修复，也能快速的恢复到一个不错的状态。</p>
<p>大多数人晚睡的原因都不是什么正经的事儿，将注意力集中在没有必要的事情上让人疲惫，睡前刷新网页，玩手机更是会直接损害睡眠质量……何必呢？看看书，保持沉静，安稳睡去，你的七到八个小时睡眠时间绝对不会在白天辜负你。</p>
<p>至于睡眠时间，最好的一种莫过于每天早晨在一个准确的时间起床，并长期坚持。</p>
<h3 id="5-2-培养正确的爱好"><a href="#5-2-培养正确的爱好" class="headerlink" title="5.2 培养正确的爱好"></a>5.2 培养正确的爱好</h3><p>有些爱好就是比其他爱好要更好，比如阅读、观影、写作、摄影、画画，等等。这些爱好会让你感到开心，愉悦，幸福，满足，起到一些其他爱好无法满足的作用。</p>
<p>有些看起来并不怎么有意义的爱好会因人而异产生完全不同的效果。如果你做了而使自己获得了真正的放松——比如狂欢之后感到情绪被宣泄（换到我只会感觉到空虚）。归根结底还是要弄清自己真正适合做的是什么。</p>
<h3 id="5-3-保持活动"><a href="#5-3-保持活动" class="headerlink" title="5.3 保持活动"></a>5.3 保持活动</h3><p>谨记：生命是一种流动中的形式，一个不动的人是很难有活力的。</p>
<h2 id="六、训练精力"><a href="#六、训练精力" class="headerlink" title="六、训练精力"></a>六、训练精力</h2><p>任何事情都需要训练，运动员要训练肌肉记忆，做学问的要训练神经突触，蓄养精力也是同样的道理。将做有意义的事情时的精力上限提高并不仅仅意味着下次再做这件事情的时候能坚持的时间更长，而是意味着即使你只做一定的时间，你的效率也会大为增强。</p>
<p>比如，每天坚持读一个小时的书，或运动一个小时，而当一个小时之后，就可以休息一小会儿或看些轻松的东西。</p>
<p>在逐步的训练中，做某件事的精力值逐步提高了，而因为其趣味性也不断增强，你做其他相较之“不重要”的事情的时间也就缩短了。你的生活将变得更有意义，更加充实，对自我的成长帮助也越大。</p>
<h2 id="七、分配精力"><a href="#七、分配精力" class="headerlink" title="七、分配精力"></a>七、分配精力</h2><h3 id="7-1-不要一次性做完乐意的事"><a href="#7-1-不要一次性做完乐意的事" class="headerlink" title="7.1 不要一次性做完乐意的事"></a>7.1 不要一次性做完乐意的事</h3><p>人的精力是有限的，如果一大早就把自己乐意做的事情都做完了，难的不想做的事留在后面，那么后面的时间里，你整个人都会感到非常疲惫、倦怠。</p>
<p>而且很多人经常用错误的方法去放松自己，也就是做更“无聊”的事，周而复始，很多人的生活就会呈现出一种下滑的状态。</p>
<p>所以，合理分配自己的精力，保持充足的精神，是相当重要的，这样可以避免自己去做“无聊”的事情来打发时间。</p>
<h3 id="7-2-交叉进行耗费和恢复精力的事情"><a href="#7-2-交叉进行耗费和恢复精力的事情" class="headerlink" title="7.2 交叉进行耗费和恢复精力的事情"></a>7.2 交叉进行耗费和恢复精力的事情</h3><p>把一些乐意做的事和不想做的事交叉来做，这样两者都能够完成，并且还可以持续保持状态。</p>
<p>为了做那些我们需要耗费很大精力去完成的事情——比如工作——我们需要做充足的准备，留出足够的空档，并在其后对自己进行恢复。</p>
<p>在除了学习和工作以外的其他时间，分配同样重要。如果你决定每天晚上回家的时间是自己的充电时间——看书，看电影，写作——那你就不可以让自己回家的时候已经感到难受和疲惫。你可以将事情挪到其他时间去做，可以在下班后先做一些让自己兴奋的事情，可以通过训练让自己在某些事情上如鱼得水……不管怎样，你总要找到办法让自己每天的生活更加均衡，而不是完成中间的某一个部分之后就做不了别的事情了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>要知道，我们所有人都会老去，而我们中的几乎所有人都会比自己想像之中更早的老去，而老去时最常见的语言莫过于“精力有限”，“心有余而力不足”。</p>
<p>等到这一能量无可救药离我们远去的时候，我们应该有让自己骄傲的珍惜。到时候你才不会后悔的说，当我在还有机会发挥潜能的时候，却让财富从我的生命中偷偷流走。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
